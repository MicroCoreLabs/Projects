//
//
//  File Name   :  Microcode_MCL86.txt
//  Used on     :  MCL86
//  Author      :  Ted Fried, MicroCore Labs
//  Creation    :  1/25/2020
//  Code Type   :  Microcode
//
//   Description:
//   ============
//   
//  Microcode for the MCL86
//
//------------------------------------------------------------------------
//
// Modification History:
// =====================
//
// Revision 1.0 1/25/2020
// Initial revision
//
// Revision 2.0 8/20/2022
// Fixed accidental clearing of prefix override for all string opcodes
//
// Revision 3.0 10/30/2022
// For 0xF6 opcodes CF/OV flags were always being cleared which is incorrect for NOT
// Moved these flag clears to IDIV and DIV which need them cleared
//
// Revision 4.0 12/2/2022
// Assigned values to unused flags[1,3,5] for opcode LAHF
//
//
//------------------------------------------------------------------------
//
// Copyright (c) 2020 Ted Fried
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
//------------------------------------------------------------------------

// Microcode and microsequencer notes:
//  
# 
# // Consolidated system signals
# assign system_signals[15] 
# assign system_signals[14] 
# assign system_signals[13] = eu_add_carry8;      
# assign system_signals[12] = clock_cycle_counter_zero;   
# assign system_signals[11] = eu_add_overflow16;     
# assign system_signals[10] 
# assign system_signals[9]  = eu_add_overflow8;   
# assign system_signals[8]  = eu_flag_t_asserted;     
# assign system_signals[7]  = ~pfq_empty;     
# assign system_signals[6]  = biu_done_caught;    
# assign system_signals[5]  = test_n_int;     
# assign system_signals[4]  = eu_add_aux_carry;   
# assign system_signals[3]  = nmi_caught;     
# assign system_signals[2]  = eu_parity;      
# assign system_signals[1]  = int_asserted;   
# assign system_signals[0]  = eu_add_carry16;     
# 
# 
# assign eu_prefix_repnz  = eu_flags[15];
# assign eu_prefix_repz   = eu_flags[14];
# assign eu_prefix_lock   = eu_flags[13];
# assign eu_nmi_debounce  = eu_flags[12];
# assign eu_flag_o        = eu_flags[11];
# assign eu_flag_d        = eu_flags[10];
# assign eu_flag_i        = eu_flags[9];
# assign eu_flag_t        = eu_flags[8];
# assign eu_flag_s        = eu_flags[7];
# assign eu_flag_z        = eu_flags[6];
# assign eu_tf_debounce   = eu_flags[5];
# assign eu_flag_a        = eu_flags[4];
# assign eu_flag_temp       = eu_flags[3];
# assign eu_flag_p        = eu_flags[2];
# assign eu_flag_temp       = eu_flags[1];
# assign eu_flag_c        = eu_flags[0];
# 
# 
# BIU Command
# -------------
# // Signals from the EU to request BIU processing
# //  eu_biu_strobe[1:0] are available for only one clock cycle and cause BIU to take immediate action.
# //  eu_biu_req stays asserted until the BIU is available to service the request.
# //  
#                               = eu_biu_command[15];
# eu_segment_override             = eu_biu_command[14];
# eu_biu_strobe[1:0]              = eu_biu_command[13:12]; // 01=opcode fetch 10=clock load 11=load biu register(eu_biu_req_code has the register#)
# eu_biu_segment[1:0]             = eu_biu_command[11:10];
# eu_biu_req                      = eu_biu_command[9];
# eu_biu_req_code                 = eu_biu_command[8:4];
# eu_qs_out[1:0]                  = eu_biu_command[3:2];  // Updated for every opcode fetch strobe using biu_strobe and Jump request using eu_biu_rq
# eu_segment_override_value[1:0]  = eu_biu_command[1:0];
#   
# 
# EU Registers
# --------------
# 
# Destination                   Operand0                    Operand1
# -----------------------------------------------------------------------------------------------
# 0 AX                      0   AX                      0   ES
# 1 BX                      1   BX                      1   SS
# 2 CX                      2   CX                      2   CS
# 3 DX                      3   DX                      3   DS
# 4 SP                      4   SP                      4   { 8'h00 , pfq_top_byte } 
# 5 BP                      5   BP                      5   EA_RM from BIU
# 6 SI                      6   SI                      6   EA_REG from BIU
# 7 DI                      7   DI                      7   BIU Return Data 
# 8 Flags                   8   Flags                   8   Prefetch Queue Address (Current IP)
# 9 r0                      9   r0                      9   r0
# A r1                      A   r1                      A   r1
# B r2                      B   r2                      B   r2
# C r3                      C   r3                      C   r3
# D BIU Command             D   BIU Command             D   ALU Last Result
# E   Dummy Reg               E   System Signals          E System Signals
# F BIU Dataout             F   16'h0000                F   Opcode Immediate[15:0]
# 
# 
# EU Opcodes
# -----------
# 0x1 - JUMP
# ----------------
# Bits[31:28] : 0x1
# Bits[27:24] : CALL  1=Store next IP address
# Bits[22:20] : Jump Source:        
#               0x0=Immediate[12:0] 
#                 0x1={immediate[4:0]&pfq_top_byte} 
#                 0x2={immediate[4:0]&pfq_top_byte[7:6]&pfq_top_byte[2:0]&000}  
#               0x3=Return to CALL stored IP address
#               0x4={immediate[8:0], eu_biu_dataout[3:0] , 1'b0 }     // For register fetch
#               0x5={immediate[7:0], eu_biu_dataout[3:0] , 2'b00 }    // For register writeback
#               0x6={eu_opcode_immediate[12:3], eu_biu_dataout[5:3]}  // For opcode group decoding
# 
# Bits[19:16] : Jump Condition: 
#               0x0=Unconditional   
#               0x1=Last_ALU_Result!=0      
#               0x2=Last_ALU_Result==0
# Bits[12:0]  : Immediate[12:0]
# 
# 0x2 - ADD
# 0x3 - BYTESWAP op0
# 0x4 - AND
# 0x5 - OR
# 0x6 - XOR
# 0x7 - Shift Right { eu_operand1[0] , eu_operand0[15:1] }
# 
# ---------------
# Bits[31:28] : Type
# Bits[27:24] : Destination
# Bits[23:20] : Operand0
# Bits[19:16] : Operand1
# Bits[12:0]  : Immediate[15:0]
# 
# 
# --------------------------------------------------------------------------------------------------------
# 
# 
# assign jump_adddress_eu = (eu_biu_req_code ==  h08   ===>   IO Byte Read
#                           (eu_biu_req_code ==  h0A   ===>   IO Byte Write
#                           (eu_biu_req_code ==  h0C   ===>   Memory Byte Read
#                           (eu_biu_req_code ==  h0E   ===>   Memory Byte Write
#                           (eu_biu_req_code ==  h10   ===>   Memory Word Read   
#                           (eu_biu_req_code ==  h11   ===>   Memory Word Read  - From Stack Segment
#                           (eu_biu_req_code ==  h12   ===>   Memory Word Read  - From segment 0000 - for interrupt vector fetches
#                           (eu_biu_req_code ==  h13   ===>   Memory Word Write
#                           (eu_biu_req_code ==  h14   ===>   Memory Word Write - To Stack Segment
#                           (eu_biu_req_code ==  h16   ===>   Interrupt ACK Cycle
#                           (eu_biu_req_code ==  h18   ===>   HALT State
#                           (eu_biu_req_code ==  h19   ===>   Jump Instruction                        
#                           (eu_biu_req_code ==  h1A   ===>   IO Word Read   
#                           (eu_biu_req_code ==  h1C   ===>   IO Word Write                           
#                                                             RESET State
# 
# 
#                                                           
#                                                           
#
#
#
# Stop CPU
p 00 00000 00010 0001
p 01 00000 00010 0000
p 01 00000 00010 000F
# 
#
d 20
#
#
#
#
--------------------------------------------------------------------
--------------------------------------------------------------------
#
# EU Microcode
#
#
--------------------------------------------------------------------
--------------------------------------------------------------------
#
#
#
# Primary Microcode Loop at address 0x0000
# -----------------------------------------------------
#
# NOP
p 00 00000 00001 0000
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# NOP
p 00 00000 00001 0001
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# NOP
p 00 00000 00001 0002
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# NOP
p 00 00000 00001 0003
p 01 00000 00001 0000
p 01 00000 00001 0000
#
#
# Debounce the Prefix flags and BIU Command fields
#
# Clear Flag bits [15:12] - REPNZ, REPZ, LOCK, nmi_debounce, and tf_debounce
p 00 00000 00001 0004
p 01 00000 00001 488F
p 01 00000 00001 0FDF
#
# Clear BIU command fields
p 00 00000 00001 0005
p 01 00000 00001 4DDF
p 01 00000 00001 0000
#
#
# Poll for Interrupts
#
# Isolate System Signals[3] - nmi_caught
p 00 00000 00001 0006
p 01 00000 00001 4CEF
p 01 00000 00001 0008
#
# Jump to NMI Processing Routine if last ALU is non zero
p 00 00000 00001 0007
p 01 00000 00001 1001
p 01 00000 00001 053A
#
# Isolate System Signals[1] - intr_asserted
p 00 00000 00001 0008
p 01 00000 00001 4CEF
p 01 00000 00001 0002
#
# Jump to Interrupt vector fetch Processing Routine if last ALU is non zero
p 00 00000 00001 0009
p 01 00000 00001 1001
p 01 00000 00001 0562
#
# Isolate System Signals[8] - eu_tf_pending
p 00 00000 00001 000A
p 01 00000 00001 4CEF
p 01 00000 00001 0100
#
# Jump to Single Step Processing Routine if last ALU is non zero
p 00 00000 00001 000B
p 01 00000 00001 1001
p 01 00000 00001 0545
#
# NOP
p 00 00000 00001 000C
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# NOP
p 00 00000 00001 000D
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# NOP
p 00 00000 00001 000E
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# NOP
p 00 00000 00001 000F
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# NOP
p 00 00000 00001 0010
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# 
# Fetch initial opcode when available
#
# Isolate the Prefetch Queue EMPTY bit by ANDing system_signals register with immedaite into Dummy
p 00 00000 00001 0011
p 01 00000 00001 4EEF
p 01 00000 00001 0080
#
# Jump Type-1 to the Initial Opcode Jump Table - if last result is not zero
p 00 00000 00001 0012
p 01 00000 00001 1011
p 01 00000 00001 0001
#
# Unconditional Jump to Interrupts check
p 00 00000 00001 0013
p 01 00000 00001 1000
p 01 00000 00001 0006
#
--------------------------------------------------------------------
#
#
# EU Reset Routine - Runs when RESET pin is deasserted
# -----------------------------------------------------------------
#
# Debounce BIU Strobe - was 0xCFF0
p 00 00000 00001 0020
p 01 00000 00001 4DDF
p 01 00000 00001 0000
#
# Zero the Flags Register
# AND 0000 with 0000 into Flag Register
p 00 00000 00001 0021
p 01 00000 00001 48FF
p 01 00000 00001 0000
#
# Load BIU Data Out with 0x0000
p 00 00000 00001 0022
p 01 00000 00001 4FFF
p 01 00000 00001 0000
#
# Send command to BIU to write ES=0000
# Write to BIU Command register:
p 00 00000 00001 0023
p 01 00000 00001 5DFF
p 01 00000 00001 3000
#
# Send command to BIU to write SS=0000
# Write to BIU Command register:
p 00 00000 00001 0024
p 01 00000 00001 5DFF
p 01 00000 00001 3010
#
# Send command to BIU to write DS=0000
# Write to BIU Command register:
p 00 00000 00001 0025
p 01 00000 00001 5DFF
p 01 00000 00001 3030
#
# Send command to BIU to point to CS=FFFF
# Write to BIU Command register:
p 00 00000 00001 0026
p 01 00000 00001 5DFF
p 01 00000 00001 3020
#
# Load BIU Data Out with 0xFFFF
p 00 00000 00001 0027
p 01 00000 00001 5FFF
p 01 00000 00001 FFFF
#
# Debounce the BIU Command Register
p 00 00000 00001 0028
p 01 00000 00001 4DFF
p 01 00000 00001 0000
#
## Perform a BIU JUMP request to FFFF:0000
# Load r3 with 0x0000 which holds the jump address
p 00 00000 00001 0029
p 01 00000 00001 4CFF
p 01 00000 00001 0000
#
# Send command to BIU to JUMP to 0x0000
# Write to BIU Command register:
p 00 00000 00001 002A
p 01 00000 00001 5DFF
p 01 00000 00001 0B98
#
# Poll for BIU Done
# Isolate the biu_done bit by ANDing system_signals register with immedaite into Dummy
p 00 00000 00001 002B
p 01 00000 00001 4EEF
p 01 00000 00001 0040
#
# Jump to immediate address pointing to BIU debounce if last result is not zero
p 00 00000 00001 002C
p 01 00000 00001 1001
p 01 00000 00001 002E
#
# Jump unconditional back to BIU done polling
p 00 00000 00001 002D
p 01 00000 00001 1000
p 01 00000 00001 002B
#
# Debounce the BIU Command Register
p 00 00000 00001 002E
p 01 00000 00001 4DFF
p 01 00000 00001 0000
#
# Jump unconditional back to Main Microcode Loop
p 00 00000 00001 002F
p 01 00000 00001 1000
p 01 00000 00001 0000
#
#
--------------------------------------------------------------------
#
# 0x90 - Microcode for NOP
# -----------------------------------------------------
#
# Write clock count=3 to the BIU Dataout register
p 00 00000 00001 0040
p 01 00000 00001 5FFF
p 01 00000 00001 C025
#
# Strobe BIU - Set clock counter
p 00 00000 00001 0041
p 01 00000 00001 5DDF
p 01 00000 00001 2000
#
# Debounce BIU Strobe
p 00 00000 00001 0042
p 01 00000 00001 4DDF
p 01 00000 00001 CFFF
#
# Isolate System Signals clock counter zero bit
p 00 00000 00001 0043
p 01 00000 00001 4CEF
p 01 00000 00001 1000
#
# Jump to retest if last ALU is zero
p 00 00000 00001 0044
p 01 00000 00001 1002
p 01 00000 00001 0043
#
# Strobe BIU - Fetch Opcode and set QS[1:0] to First Byte of Opcode 
p 00 00000 00001 0045
p 01 00000 00001 5DDF
p 01 00000 00001 1004
#
# Debounce BIU Strobe
p 00 00000 00001 0046
p 01 00000 00001 4DDF
p 01 00000 00001 CFF3
#
# Jump unconditional to main microcode loop
p 00 00000 00001 0047
p 01 00000 00001 1000
p 01 00000 00001 0004
#
#
#
--------------------------------------------------------------------
#
# 0xF8 - CLC - Clear Carry Flag 
#
# Clear the Bit with AND
p 00 00000 00001 0050
p 01 00000 00001 488F
p 01 00000 00001 FFFE
#
# Jump unconditional to common flag setting code
p 00 00000 00001 0051
p 01 00000 00001 1000
p 01 00000 00001 005C
#
# -----------------------------------------------------
#
# 0xF5 - CMC - Complement Carry Flag 
#
# Complement the Bit with XOR
p 00 00000 00001 0052
p 01 00000 00001 688F
p 01 00000 00001 0001
#
# Jump unconditional to common flag setting code
p 00 00000 00001 0053
p 01 00000 00001 1000
p 01 00000 00001 005C
#
# -----------------------------------------------------
#
# 0xF9 - STC - Set Carry Flag 
#
# Set the Bit with OR
p 00 00000 00001 0054
p 01 00000 00001 588F
p 01 00000 00001 0001
#
# Jump unconditional to common flag setting code
p 00 00000 00001 0055
p 01 00000 00001 1000
p 01 00000 00001 005C
#
# -----------------------------------------------------
#
# 0xFC - CLD - Clear Direction Flag 
#
# Clear the Bit with AND
p 00 00000 00001 0056
p 01 00000 00001 488F
p 01 00000 00001 FBFF
#
# Jump unconditional to common flag setting code
p 00 00000 00001 0057
p 01 00000 00001 1000
p 01 00000 00001 005C
#
# -----------------------------------------------------
#
# 0xFD - STD - Set Direction Flag 
#
# Set the Bit with OR
p 00 00000 00001 0058
p 01 00000 00001 588F
p 01 00000 00001 0400
#
# Jump unconditional to common flag setting code
p 00 00000 00001 0059
p 01 00000 00001 1000
p 01 00000 00001 005C
#
# -----------------------------------------------------
#
# 0xFA - CLI - Clear Interrupt Flag 
#
# Clear the Bit with AND
p 00 00000 00001 005A
p 01 00000 00001 488F
p 01 00000 00001 FDFF
#
# Jump unconditional to common flag setting code
p 00 00000 00001 005B
p 01 00000 00001 1000
p 01 00000 00001 005C
#
# -----------------------------------------------------
#
# Common Flag setting code - Sets clocks to 2 and jumps to remaining NOP code.  
#
# Write clock count=2 to the BIU Dataout register
p 00 00000 00001 005C
p 01 00000 00001 5FFF
p 01 00000 00001 C00C
#
# Jump unconditional to NOP Microcode since it is identical
p 00 00000 00001 005D
p 01 00000 00001 1000
p 01 00000 00001 0041
#
# -----------------------------------------------------
#
# 0x91 - XCHG - Exchange Accumulator and CX  
#
# Copy r0 <= AX
p 00 00000 00001 005E
p 01 00000 00001 590F
p 01 00000 00001 0000
#
# Copy r1 <= CX
p 00 00000 00001 005F
p 01 00000 00001 5A2F
p 01 00000 00001 0000
#
# Copy AX <= r1
p 00 00000 00001 0060
p 01 00000 00001 50FA
p 01 00000 00001 0000
#
# Copy CX <= r0
p 00 00000 00001 0061
p 01 00000 00001 52F9
p 01 00000 00001 0000
#
# Write clock count=3 to the BIU Dataout register
p 00 00000 00001 0062
p 01 00000 00001 5FFF
p 01 00000 00001 C01E
#
# Jump unconditional to NOP Microcode after clock setting since it is identical
p 00 00000 00001 0063
p 01 00000 00001 1000
p 01 00000 00001 0041
#
# -----------------------------------------------------
#
# 0x92 - XCHG - Exchange Accumulator and DX 
#
# Copy r0 <= AX
p 00 00000 00001 0064
p 01 00000 00001 590F
p 01 00000 00001 0000
#
# Copy r1 <= DX
p 00 00000 00001 0065
p 01 00000 00001 5A3F
p 01 00000 00001 0000
#
# Copy AX <= r1
p 00 00000 00001 0066
p 01 00000 00001 50FA
p 01 00000 00001 0000
#
# Copy DX <= r0
p 00 00000 00001 0067
p 01 00000 00001 53F9
p 01 00000 00001 0000
#
# Write clock count=3 to the BIU Dataout register
p 00 00000 00001 0068
p 01 00000 00001 5FFF
p 01 00000 00001 C01D
#
# Jump unconditional to NOP Microcode after clock setting since it is identical
p 00 00000 00001 0069
p 01 00000 00001 1000
p 01 00000 00001 0041
#
# -----------------------------------------------------
#
# 0x93 - XCHG - Exchange Accumulator and BX 
#
# Copy r0 <= AX
p 00 00000 00001 006A
p 01 00000 00001 590F
p 01 00000 00001 0000
#
# Copy r1 <= BX
p 00 00000 00001 006B
p 01 00000 00001 5A1F
p 01 00000 00001 0000
#
# Copy AX <= r1
p 00 00000 00001 006C
p 01 00000 00001 50FA
p 01 00000 00001 0000
#
# Copy BX <= r0
p 00 00000 00001 006D
p 01 00000 00001 51F9
p 01 00000 00001 0000
#
# Write clock count=3 to the BIU Dataout register
p 00 00000 00001 006E
p 01 00000 00001 5FFF
p 01 00000 00001 C01D
#
# Jump unconditional to NOP Microcode after clock setting since it is identical
p 00 00000 00001 006F
p 01 00000 00001 1000
p 01 00000 00001 0041
#
# -----------------------------------------------------
#
# 0x94 - XCHG - Exchange Accumulator and SP 
#
# Copy r0 <= AX
p 00 00000 00001 0070
p 01 00000 00001 590F
p 01 00000 00001 0000
#
# Copy r1 <= SP
p 00 00000 00001 0071
p 01 00000 00001 5A4F
p 01 00000 00001 0000
#
# Copy AX <= r1
p 00 00000 00001 0072
p 01 00000 00001 50FA
p 01 00000 00001 0000
#
# Copy SP <= r0
p 00 00000 00001 0073
p 01 00000 00001 54F9
p 01 00000 00001 0000
#
# Write clock count=3 to the BIU Dataout register
p 00 00000 00001 0074
p 01 00000 00001 5FFF
p 01 00000 00001 C01D
#
# Jump unconditional to NOP Microcode after clock setting since it is identical
p 00 00000 00001 0075
p 01 00000 00001 1000
p 01 00000 00001 0041
#
# -----------------------------------------------------
#
# 0x95 - XCHG - Exchange Accumulator and BP 
#
# Copy r0 <= AX
p 00 00000 00001 0076
p 01 00000 00001 590F
p 01 00000 00001 0000
#
# Copy r1 <= BP
p 00 00000 00001 0077
p 01 00000 00001 5A5F
p 01 00000 00001 0000
#
# Copy AX <= r1
p 00 00000 00001 0078
p 01 00000 00001 50FA
p 01 00000 00001 0000
#
# Copy BP <= r0
p 00 00000 00001 0079
p 01 00000 00001 55F9
p 01 00000 00001 0000
#
# Write clock count=3 to the BIU Dataout register
p 00 00000 00001 007A
p 01 00000 00001 5FFF
p 01 00000 00001 C01D
#
# Jump unconditional to NOP Microcode after clock setting since it is identical
p 00 00000 00001 007B
p 01 00000 00001 1000
p 01 00000 00001 0041
#
# -----------------------------------------------------
#
# 0x96 - XCHG - Exchange Accumulator and SI 
#
# Copy r0 <= AX
p 00 00000 00001 007C
p 01 00000 00001 590F
p 01 00000 00001 0000
#
# Copy r1 <= SI
p 00 00000 00001 007D
p 01 00000 00001 5A6F
p 01 00000 00001 0000
#
# Copy AX <= r1
p 00 00000 00001 007E
p 01 00000 00001 50FA
p 01 00000 00001 0000
#
# Copy SI <= r0
p 00 00000 00001 007F
p 01 00000 00001 56F9
p 01 00000 00001 0000
#
# Write clock count=3 to the BIU Dataout register
p 00 00000 00001 0080
p 01 00000 00001 5FFF
p 01 00000 00001 C01D
#
# Jump unconditional to NOP Microcode after clock setting since it is identical
p 00 00000 00001 0081
p 01 00000 00001 1000
p 01 00000 00001 0041
#
# -----------------------------------------------------
#
# 0x97 - XCHG - Exchange Accumulator and DI 
#
# Copy r0 <= AX
p 00 00000 00001 0082
p 01 00000 00001 590F
p 01 00000 00001 0000
#
# Copy r1 <= DI
p 00 00000 00001 0083
p 01 00000 00001 5A7F
p 01 00000 00001 0000
#
# Copy AX <= r1
p 00 00000 00001 0084
p 01 00000 00001 50FA
p 01 00000 00001 0000
#
# Copy DI <= r0
p 00 00000 00001 0085
p 01 00000 00001 57F9
p 01 00000 00001 0000
#
# Write clock count=3 to the BIU Dataout register
p 00 00000 00001 0086
p 01 00000 00001 5FFF
p 01 00000 00001 C01D
#
# Jump unconditional to NOP Microcode after clock setting since it is identical 
p 00 00000 00001 0087
p 01 00000 00001 1000
p 01 00000 00001 0041
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# 0x40 - INC AX 
#
# Add +1 to the register
p 00 00000 00001 0088
p 01 00000 00001 200F
p 01 00000 00001 0001
#
# Jump unconditional to the INC16/DEC16 flag processing code
p 00 00000 00001 0089
p 01 00000 00001 1000
p 01 00000 00001 00A8
#
# -----------------------------------------------------
#
# 0x41 - INC CX 
#
# Add +1 to the register
p 00 00000 00001 008A
p 01 00000 00001 222F
p 01 00000 00001 0001
#
# Jump unconditional to the INC16/DEC16 flag processing code
p 00 00000 00001 008B
p 01 00000 00001 1000
p 01 00000 00001 00A8
#
# -----------------------------------------------------
#
# 0x42 - INC DX 
#
# Add +1 to the register
p 00 00000 00001 008C
p 01 00000 00001 233F
p 01 00000 00001 0001
#
# Jump unconditional to the INC16/DEC16 flag processing code
p 00 00000 00001 008D
p 01 00000 00001 1000
p 01 00000 00001 00A8
#
# -----------------------------------------------------
#
# 0x43 - INC BX 
#
# Add +1 to the register
p 00 00000 00001 008E
p 01 00000 00001 211F
p 01 00000 00001 0001
#
# Jump unconditional to the INC16/DEC16 flag processing code
p 00 00000 00001 008F
p 01 00000 00001 1000
p 01 00000 00001 00A8
#
# -----------------------------------------------------
#
# 0x44 - INC SP 
#
# Add +1 to the register
p 00 00000 00001 0090
p 01 00000 00001 244F
p 01 00000 00001 0001
#
# Jump unconditional to the INC16/DEC16 flag processing code
p 00 00000 00001 0091
p 01 00000 00001 1000
p 01 00000 00001 00A8
#
# -----------------------------------------------------
#
# 0x45 - INC BP 
#
# Add +1 to the register
p 00 00000 00001 0092
p 01 00000 00001 255F
p 01 00000 00001 0001
#
# Jump unconditional to the INC16/DEC16 flag processing code
p 00 00000 00001 0093
p 01 00000 00001 1000
p 01 00000 00001 00A8
#
# -----------------------------------------------------
#
# 0x46 - INC SI 
#
# Add +1 to the register
p 00 00000 00001 0094
p 01 00000 00001 266F
p 01 00000 00001 0001
#
# Jump unconditional to the INC16/DEC16 flag processing code
p 00 00000 00001 0095
p 01 00000 00001 1000
p 01 00000 00001 00A8
#
# -----------------------------------------------------
#
# 0x47 - INC DI 
#
# Add +1 to the register
p 00 00000 00001 0096
p 01 00000 00001 277F
p 01 00000 00001 0001
#
# Jump unconditional to the INC16/DEC16 flag processing code
p 00 00000 00001 0097
p 01 00000 00001 1000
p 01 00000 00001 00A8
#
# -----------------------------------------------------
#
# 0x48 - DEC AX 
#
# Add -1 to the register
p 00 00000 00001 0098
p 01 00000 00001 200F
p 01 00000 00001 FFFF
#
# Jump unconditional to the INC16/DEC16 flag processing code
p 00 00000 00001 0099
p 01 00000 00001 1000
p 01 00000 00001 0DB0
#
# -----------------------------------------------------
#
# 0x49 - DEC CX 
#
# Add -1 to the register
p 00 00000 00001 009A
p 01 00000 00001 222F
p 01 00000 00001 FFFF
#
# Jump unconditional to the INC16/DEC16 flag processing code
p 00 00000 00001 009B
p 01 00000 00001 1000
p 01 00000 00001 0DB0
#
# -----------------------------------------------------
#
# 0x4A - DEC DX 
#
# Add -1 to the register
p 00 00000 00001 009C
p 01 00000 00001 233F
p 01 00000 00001 FFFF
#
# Jump unconditional to the INC16/DEC16 flag processing code
p 00 00000 00001 009D
p 01 00000 00001 1000
p 01 00000 00001 0DB0
#
# -----------------------------------------------------
#
# 0x4B - DEC BX 
#
# Add -1 to the register
p 00 00000 00001 009E
p 01 00000 00001 211F
p 01 00000 00001 FFFF
#
# Jump unconditional to the INC16/DEC16 flag processing code
p 00 00000 00001 009F
p 01 00000 00001 1000
p 01 00000 00001 0DB0
#
# -----------------------------------------------------
#
# 0x4C - DEC SP 
#
# Add -1 to the register
p 00 00000 00001 00A0
p 01 00000 00001 244F
p 01 00000 00001 FFFF
#
# Jump unconditional to the INC16/DEC16 flag processing code
p 00 00000 00001 00A1
p 01 00000 00001 1000
p 01 00000 00001 0DB0
#
# -----------------------------------------------------
#
# 0x4D - DEC BP 
#
# Add -1 to the register
p 00 00000 00001 00A2
p 01 00000 00001 255F
p 01 00000 00001 FFFF
#
# Jump unconditional to the INC16/DEC16 flag processing code
p 00 00000 00001 00A3
p 01 00000 00001 1000
p 01 00000 00001 0DB0
#
# -----------------------------------------------------
#
# 0x4E - DEC SI 
#
# Add -1 to the register
p 00 00000 00001 00A4
p 01 00000 00001 266F
p 01 00000 00001 FFFF
#
# Jump unconditional to the INC16/DEC16 flag processing code
p 00 00000 00001 00A5
p 01 00000 00001 1000
p 01 00000 00001 0DB0
#
# -----------------------------------------------------
#
# 0x4F - DEC DI 
#
# Add -1 to the register
p 00 00000 00001 00A6
p 01 00000 00001 277F
p 01 00000 00001 FFFF
#
# Jump unconditional to the INC16/DEC16 flag processing code
p 00 00000 00001 00A7
p 01 00000 00001 1000
p 01 00000 00001 0DB0
#
# -----------------------------------------------------
#
# INC16/DEC16 Flags processing 
#
# Calculate the O, A, P flags
#
# Save ALU last result into r0
p 00 00000 00001 00A8
p 01 00000 00001 59FD
p 01 00000 00001 0000
#
# Zero out the O, A, P, Z, S bit fields in Flag register
p 00 00000 00001 00A9
p 01 00000 00001 488F
p 01 00000 00001 F72B
#
# Store r0 to r0 to make r0 the last_alu result
p 00 00000 00001 00AA
p 01 00000 00001 59F9
p 01 00000 00001 0000
#
# Isolate the O, A, and P flags from System Signals into r1 using AND
p 00 00000 00001 00AB
p 01 00000 00001 4AEF
p 01 00000 00001 0814
#
# Merge r1 into the Flags register using OR
p 00 00000 00001 00AC
p 01 00000 00001 588A
p 01 00000 00001 0000
#
#
# Calculate the Z Flag
#
# Store r0 to r0 to make r0 the last_alu result
p 00 00000 00001 00AD
p 01 00000 00001 59F9
p 01 00000 00001 0000
#
# if alu_last_result is not zero then jump to Sign bit check
p 00 00000 00001 00AE
p 01 00000 00001 1001
p 01 00000 00001 00B0
#
# Set the Zero Flag bit to a 1
p 00 00000 00001 00AF
p 01 00000 00001 588F
p 01 00000 00001 0040
#
#
# Calculate the S Flag
#
# Isolate Bit[15] from r0 into r0 using AND
p 00 00000 00001 00B0
p 01 00000 00001 499F
p 01 00000 00001 8000
#
# if alu_last_result is not zero then jump to S=1
p 00 00000 00001 00B1
p 01 00000 00001 1001
p 01 00000 00001 00B4
#
# Write clock count=2 to the BIU Dataout register
p 00 00000 00001 00B2
p 01 00000 00001 5FFF
p 01 00000 00001 C002
#
# Jump unconditional to NOP Microcode since it is identical 
p 00 00000 00001 00B3
p 01 00000 00001 1000
p 01 00000 00001 0041
#
# Set the Sign Flag bit to a 1
p 00 00000 00001 00B4
p 01 00000 00001 588F
p 01 00000 00001 0080
#
# Write clock count=2 to the BIU Dataout register 
p 00 00000 00001 00B5
p 01 00000 00001 5FFF
p 01 00000 00001 C002
#
# Jump unconditional to NOP Microcode since it is identical 
p 00 00000 00001 00B6
p 01 00000 00001 1000
p 01 00000 00001 0041
#
#
# -----------------------------------------------------
#
# 0xFB - STI - Set Interrupt Flag 
# Note: Actual INTR will not be enabled until after the start of the next instruction
#
# Set the Bit with OR
p 00 00000 00001 00BA
p 01 00000 00001 588F
p 01 00000 00001 0200
#
# Jump unconditional to common flag setting code
p 00 00000 00001 00BB
p 01 00000 00001 1000
p 01 00000 00001 005C
#
#
# -----------------------------------------------------
#
# Set the Zero Flag for Multiply and Divide opcodes
# so this chip looks like an Intel 8086.
#
# Jump to 0x00BE for 16-bit MUL/DIV with clock count
# Jump to 0x00C0 for 16-bit MUL/DIV
# Jump to 0x00C6 for 8-bit MUL/DIV
# -----------------------------------------------------
#
# Isolate System Signals clock counter zero bit into Dummy
p 00 00000 00001 00BE
p 01 00000 00001 4EEF
p 01 00000 00001 1000
#
# Jump to retest if last ALU is zero poop
p 00 00000 00001 00BF
p 01 00000 00001 1002
p 01 00000 00001 00BE
#
# Strobe BIU - Fetch Opcode and set QS[1:0] to Subsequent Byte of Opcode 
p 00 00000 00001 00C0
p 01 00000 00001 5DDF
p 01 00000 00001 100C
#
# Debounce BIU Strobe
p 00 00000 00001 00C1
p 01 00000 00001 4DDF
p 01 00000 00001 CFF3
#
# Clear the Zero Flag 
p 00 00000 00001 00C2
p 01 00000 00001 488F
p 01 00000 00001 FFBF
#
# Dummy <= DX OR 0000
p 00 00000 00001 00C3
p 01 00000 00001 5E3F
p 01 00000 00001 0000
#
# Jump if non-zero to main microcode loop
p 00 00000 00001 00C4
p 01 00000 00001 1001
p 01 00000 00001 0004
#
# Jump unconditional over next two instructions
p 00 00000 00001 00C5
p 01 00000 00001 1000
p 01 00000 00001 00C8
#
# Strobe BIU - Fetch Opcode and set QS[1:0] to Subsequent Byte of Opcode 
p 00 00000 00001 00C6
p 01 00000 00001 5DDF
p 01 00000 00001 100C
#
# Debounce BIU Strobe
p 00 00000 00001 00C7
p 01 00000 00001 4DDF
p 01 00000 00001 CFF3
#
# Clear the Zero Flag 
p 00 00000 00001 00C8
p 01 00000 00001 488F
p 01 00000 00001 FFBF
#
# Dummy <= AX OR 0000
p 00 00000 00001 00C9
p 01 00000 00001 5E0F
p 01 00000 00001 0000
#
# Jump if non-zero to main microcode loop
p 00 00000 00001 00CA
p 01 00000 00001 1001
p 01 00000 00001 0004
#
# Set the Zero Flag bit to a 1
p 00 00000 00001 00CB
p 01 00000 00001 588F
p 01 00000 00001 0040
#
# Jump unconditional to main microcode loop
p 00 00000 00001 00CC
p 01 00000 00001 1000
p 01 00000 00001 0004
#
#
# -----------------------------------------------------
#
# 0xF0 - LOCK - LOCK Prefix 
#
# -----------------------------------------------------
#
# Set the lock prefix bit[13] with OR 
p 00 00000 00001 00D0
p 01 00000 00001 588F
p 01 00000 00001 2000
#
# Jump unconditional to common prefix code
p 00 00000 00001 00D1
p 01 00000 00001 1000
p 01 00000 00001 00DE
#
#
# -----------------------------------------------------
#
# 0xF2 - REPNZ - REPNZ Prefix
#
# -----------------------------------------------------
#
# Set the REPNZ prefix bit[15] with OR 
p 00 00000 00001 00D2
p 01 00000 00001 588F
p 01 00000 00001 8000
#
# Jump unconditional to common prefix code
p 00 00000 00001 00D3
p 01 00000 00001 1000
p 01 00000 00001 00DE
#
#
# -----------------------------------------------------
#
# 0xF3 - REP - REP Prefix
#
# -----------------------------------------------------
#
# Set the REP prefix bit[14] with OR 
p 00 00000 00001 00D4
p 01 00000 00001 588F
p 01 00000 00001 4000
#
# Jump unconditional to common prefix code
p 00 00000 00001 00D5
p 01 00000 00001 1000
p 01 00000 00001 00DE
#
#
# -----------------------------------------------------
#
# 0x26 - SEG - Segment Override Prefix - ES
#
# -----------------------------------------------------
#
# Set segment override bit and 00=ES to BIU command register
p 00 00000 00001 00D6
p 01 00000 00001 5DDF
p 01 00000 00001 4000
#
# Jump unconditional to common prefix code
p 00 00000 00001 00D7
p 01 00000 00001 1000
p 01 00000 00001 00DE
#
#
# -----------------------------------------------------
#
# 0x2E - SEG - Segment Override Prefix - CS
#
# -----------------------------------------------------
#
# Set segment override bit and 10=CS to BIU command register
p 00 00000 00001 00D8
p 01 00000 00001 5DDF
p 01 00000 00001 4002
#
# Jump unconditional to common prefix code
p 00 00000 00001 00D9
p 01 00000 00001 1000
p 01 00000 00001 00DE
#
#
# -----------------------------------------------------
#
# 0x36 - SEG - Segment Override Prefix - SS
#
# -----------------------------------------------------
#
# Set segment override bit and 01=SS to BIU command register
p 00 00000 00001 00DA
p 01 00000 00001 5DDF
p 01 00000 00001 4001
#
# Jump unconditional to common prefix code
p 00 00000 00001 00DB
p 01 00000 00001 1000
p 01 00000 00001 00DE
#
#
# -----------------------------------------------------
#
# 0x3E - SEG - Segment Override Prefix - DS
#
# -----------------------------------------------------
#
# Set segment override bit and 11=DS to BIU command register
p 00 00000 00001 00DC
p 01 00000 00001 5DDF
p 01 00000 00001 4003
#
# Jump unconditional to common prefix code
p 00 00000 00001 00DD
p 01 00000 00001 1000
p 01 00000 00001 00DE
#
#
# -----------------------------------------------------
#
# Common Prefix code
#
# -----------------------------------------------------
#
# Write clock count=2 to the BIU Dataout register
p 00 00000 00001 00DE
p 01 00000 00001 5FFF
p 01 00000 00001 C01C
#
# Strobe BIU - Set clock counter
p 00 00000 00001 00DF
p 01 00000 00001 5DDF
p 01 00000 00001 2000
#
# Debounce BIU Strobe
p 00 00000 00001 00E0
p 01 00000 00001 4DDF
p 01 00000 00001 CFFF
#
# Strobe BIU - Fetch Opcode and set QS[1:0] to First Byte of Opcode 
p 00 00000 00001 00E1
p 01 00000 00001 5DDF
p 01 00000 00001 1004
#
# Debounce BIU Strobe
p 00 00000 00001 00E2
p 01 00000 00001 4DDF
p 01 00000 00001 CFF3
#
# Isolate System Signals clock counter zero bit
p 00 00000 00001 00E3
p 01 00000 00001 4CEF
p 01 00000 00001 1000
#
# Jump if last_alu non-zero to common code that waits for prefetch queue, then returns to main loop skipping all interrupt polling - ** And will not debounce prefixes**
p 00 00000 00001 00E4
p 01 00000 00001 1001
p 01 00000 00001 0748
#
# Jump unconditional to retest the clock counter
p 00 00000 00001 00E5
p 01 00000 00001 1000
p 01 00000 00001 00E3
#
#
# -----------------------------------------------------
#
# 0x9B - WAIT - Wait until TEST_n is asserted  
#
# While TEST_n not asserted, poll for interrupts while staying on this opcode.
# This is done by not incrementing the prefetch queue between polling loops.
#
# -----------------------------------------------------
#
# r1 <= r0 XOR 0xDEAD
p 00 00000 00001 00E8
p 01 00000 00001 6A9F
p 01 00000 00001 DEAD
#
# If last ALU is zero it means this microcode has run before, so jump over clock incrementing next line of code
#
p 00 00000 00001 00E9
p 01 00000 00001 1002
p 01 00000 00001 00ED
#
## Add clock count=4 to the BIU Dataout register - Initial clock count for this opcode
#
p 00 00000 00001 00EA
p 01 00000 00001 5FFF
p 01 00000 00001 C04F
#
#
# Strobe BIU - Set clock counter
p 00 00000 00001 00EB
p 01 00000 00001 5DDF
p 01 00000 00001 2000
#
# Debounce BIU Strobe
p 00 00000 00001 00EC
p 01 00000 00001 4DDF
p 01 00000 00001 CFFF
#
# Zero r3
p 00 00000 00001 00ED
p 01 00000 00001 49FF
p 01 00000 00001 0000
#
# OR 0xDEAD into r3
p 00 00000 00001 00EE
p 01 00000 00001 59FF
p 01 00000 00001 DEAD
#
# Count the appropriate amount of clocks first for this opcode.
#
# Add clock count=5 to the BIU Dataout register
p 00 00000 00001 00EF
p 01 00000 00001 5FFF
p 01 00000 00001 C040
#
# Strobe BIU - Set clock counter
p 00 00000 00001 00F0
p 01 00000 00001 5DDF
p 01 00000 00001 2000
#
# Debounce BIU Strobe
p 00 00000 00001 00F1
p 01 00000 00001 4DDF
p 01 00000 00001 CFFF
#
# Isolate System Signals clock counter zero bit into r1
p 00 00000 00001 00F2
p 01 00000 00001 4AEF
p 01 00000 00001 1000
#
# Jump over next code if last ALU is non zero
p 00 00000 00001 00F3
p 01 00000 00001 1001
p 01 00000 00001 00F5
#
# Jump unconditional to retest the clock counter
p 00 00000 00001 00F4
p 01 00000 00001 1000
p 01 00000 00001 00F2
#
# Isolate System Signals test_asserted bit into r1
p 00 00000 00001 00F5
p 01 00000 00001 4AEF
p 01 00000 00001 0020
#
# Jump back to main loop, not incrementinig the prefetch queue if test not asserted
p 00 00000 00001 00F6
p 01 00000 00001 1001
p 01 00000 00001 0004
#
# Strobe BIU - Fetch Opcode and set QS[1:0] to First Byte of Opcode 
p 00 00000 00001 00F7
p 01 00000 00001 5DDF
p 01 00000 00001 1004
#
# Debounce BIU Strobe
p 00 00000 00001 00F8
p 01 00000 00001 4DDF
p 01 00000 00001 CFF3
#
# Jump unconditional back to main loop
p 00 00000 00001 00F9
p 01 00000 00001 1000
p 01 00000 00001 0004
#
#
# -----------------------------------------------------
#
# 0xF4 - HLT - Halt until Interrupt or Reset asserted  
#
# Poll for interrupts while staying on this opcode.
# This is done by not incrementing the prefetch queue between polling loops.
#
# -----------------------------------------------------
#
# Strobe BIU - Fetch Opcode and set QS[1:0] to First Byte of Opcode 
p 00 00000 00001 0200
p 01 00000 00001 5DDF
p 01 00000 00001 1004
#
# Debounce BIU Strobe
p 00 00000 00001 0201
p 01 00000 00001 4DDF
p 01 00000 00001 CFF3
#
# Write clock count=2 to the BIU Dataout register
p 00 00000 00001 0202
p 01 00000 00001 5FFF
p 01 00000 00001 C01A
#
# Strobe BIU - Set clock counter
p 00 00000 00001 0203
p 01 00000 00001 5DDF
p 01 00000 00001 2000
#
# Debounce BIU Strobe
p 00 00000 00001 0204
p 01 00000 00001 4DDF
p 01 00000 00001 CFFF
#
# Isolate System Signals clock counter zero bit
p 00 00000 00001 0205
p 01 00000 00001 4CEF
p 01 00000 00001 1000
#
# Jump to retest clock counter if ALU is zero
p 00 00000 00001 0206
p 01 00000 00001 1002
p 01 00000 00001 0205
#
# Poll for Interrupts
#
# Isolate System Signals[1] - int_asserted
p 00 00000 00001 0207
p 01 00000 00001 4CEF
p 01 00000 00001 0002
#
# Jump to Interupt vector fetch Processing Routine if last ALU is non zero
p 00 00000 00001 0208
p 01 00000 00001 1001
p 01 00000 00001 0562
#
# Isolate System Signals[3] - nmi_caught
p 00 00000 00001 0209
p 01 00000 00001 4CEF
p 01 00000 00001 0008
#
# Jump to NMI Processing Routine if last ALU is non zero
p 00 00000 00001 020A
p 01 00000 00001 1001
p 01 00000 00001 053A
#
# Set the BIU Command fields - Halt Request
p 00 00000 00001 020B
p 01 00000 00001 5DDF
p 01 00000 00001 0380
#
# Isolate the System Signals BIU_Done bit into Dummy
p 00 00000 00001 020C
p 01 00000 00001 4EEF
p 01 00000 00001 0040
#
# If last_alu is zero, then Jump to restest the bit
p 00 00000 00001 020D
p 01 00000 00001 1002
p 01 00000 00001 020C
#
# Debounce the BIU Command fields
p 00 00000 00001 020E
p 01 00000 00001 4DDF
p 01 00000 00001 0000

# Jump unconditional to restart clock counter and poll interrupts
p 00 00000 00001 020F
p 01 00000 00001 1000
p 01 00000 00001 0202
#
#
# -----------------------------------------------------
#
# 0x9F - LAHF - Load 8080 Flags into AH Register  
#
# -----------------------------------------------------
#
# Byte swap Flags into r0
p 00 00000 00001 0210
p 01 00000 00001 398F
p 01 00000 00001 0000
#
# Zero the lower byte of r0
p 00 00000 00001 0211
p 01 00000 00001 499F
p 01 00000 00001 D500
#
# Copy AX into r1, clearing AH
p 00 00000 00001 0212
p 01 00000 00001 4A0F
p 01 00000 00001 00FF
#
# Merge r0 and r1 into AX
p 00 00000 00001 0213
p 01 00000 00001 509A
p 01 00000 00001 0000
#
# Write clock count=4 to the BIU Dataout register
p 00 00000 00001 0214
p 01 00000 00001 5FFF
p 01 00000 00001 C02E
#
# Clear AH bits 5, 3
p 00 00000 00001 0215
p 01 00000 00001 400F
p 01 00000 00001 D7FF
#
# Set AH bit 1
p 00 00000 00001 0216
p 01 00000 00001 500F
p 01 00000 00001 0200
#
# Jump unconditional to NOP Microcode since it is identical 
p 00 00000 00001 0217
p 01 00000 00001 1000
p 01 00000 00001 0041
#
#
# -----------------------------------------------------
#
# 0x9E - SAHF - Store AH Register into 8080 Flags   
#
# -----------------------------------------------------
#
# Copy AX register to r0
p 00 00000 00001 0220
p 01 00000 00001 590F
p 01 00000 00001 0000
#
# Shift r0 to the right 1 bit
p 00 00000 00001 0221
p 01 00000 00001 799F
p 01 00000 00001 0000
#
# Shift r0 to the right 1 bit
p 00 00000 00001 0222
p 01 00000 00001 799F
p 01 00000 00001 0000
#
# Shift r0 to the right 1 bit
p 00 00000 00001 0223
p 01 00000 00001 799F
p 01 00000 00001 0000
#
# Shift r0 to the right 1 bit
p 00 00000 00001 0224
p 01 00000 00001 799F
p 01 00000 00001 0000
#
# Shift r0 to the right 1 bit
p 00 00000 00001 0225
p 01 00000 00001 799F
p 01 00000 00001 0000
#
# Shift r0 to the right 1 bit
p 00 00000 00001 0226
p 01 00000 00001 799F
p 01 00000 00001 0000
#
# Shift r0 to the right 1 bit
p 00 00000 00001 0227
p 01 00000 00001 799F
p 01 00000 00001 0000
#
# Shift r0 to the right 1 bit
p 00 00000 00001 0228
p 01 00000 00001 799F
p 01 00000 00001 0000
#
# Zero out the A, P, Z, S, C bit fields in Flag register
p 00 00000 00001 0229
p 01 00000 00001 488F
p 01 00000 00001 FF00
#
# Zero out all non-flag bits in r0 so they dont over-write the 8088 flags.
p 00 00000 00001 022A
p 01 00000 00001 499F
p 01 00000 00001 00D5
#
# OR r0 into Flags register
p 00 00000 00001 022B
p 01 00000 00001 5889
p 01 00000 00001 0000
#
# Write clock count=4 to the BIU Dataout register
p 00 00000 00001 022C
p 01 00000 00001 5FFF
p 01 00000 00001 C02C
#
# Jump unconditional to NOP Microcode since it is identical 
p 00 00000 00001 022D
p 01 00000 00001 1000
p 01 00000 00001 0041
#
# -----------------------------------------------------
#
# 0x98 - CBW - Sign extend AL Register into AH Register  
#
# -----------------------------------------------------
#
# Write clock count=2 to the BIU Dataout register
p 00 00000 00001 0230
p 01 00000 00001 5FFF
p 01 00000 00001 C008
#
# Isolate bit[7] of AX register to r0
p 00 00000 00001 0231
p 01 00000 00001 490F
p 01 00000 00001 0080
#
# If last ALU is non zero, Jump to writing AX=FF
p 00 00000 00001 0232
p 01 00000 00001 1001
p 01 00000 00001 0235
#
# Set AH to 00
p 00 00000 00001 0233
p 01 00000 00001 400F
p 01 00000 00001 00FF
#
# Jump unconditional to NOP Microcode since it is identical 
p 00 00000 00001 0234
p 01 00000 00001 1000
p 01 00000 00001 0041
#
# Set AH to FF
p 00 00000 00001 0235
p 01 00000 00001 500F
p 01 00000 00001 FF00
#
# Jump unconditional to NOP Microcode since it is identical 
p 00 00000 00001 0236
p 01 00000 00001 1000
p 01 00000 00001 0041
#
# -----------------------------------------------------
#
# 0x99 - CWD - Sign extend AX Register into DX Register  
#
# -----------------------------------------------------
#
# Write clock count=2 to the BIU Dataout register
p 00 00000 00001 0237
p 01 00000 00001 5FFF
p 01 00000 00001 C00A
#
# Isolate bit[15] of AX register to r0
p 00 00000 00001 0238
p 01 00000 00001 490F
p 01 00000 00001 8000
#
# If last ALU is non zero, Jump to writing DX=FFFF
p 00 00000 00001 0239
p 01 00000 00001 1001
p 01 00000 00001 023C
#
# Set DX to 0000
p 00 00000 00001 023A
p 01 00000 00001 43FF
p 01 00000 00001 0000
#
# Jump unconditional to NOP Microcode since it is identical 
p 00 00000 00001 023B
p 01 00000 00001 1000
p 01 00000 00001 0041
#
# Set DX to FFFF
p 00 00000 00001 023C
p 01 00000 00001 53FF
p 01 00000 00001 FFFF
#
# Jump unconditional to NOP Microcode since it is identical 
p 00 00000 00001 023D
p 01 00000 00001 1000
p 01 00000 00001 0041
#
# -----------------------------------------------------
#
# 0x37 - AAA - ASCII Adjust for Addition  
#
# -----------------------------------------------------
#
# Write clock count=4 to the BIU Dataout register
p 00 00000 00001 0240
p 01 00000 00001 5FFF
p 01 00000 00001 C02C
#
# Isolate AF flag into r0
p 00 00000 00001 0241
p 01 00000 00001 498F
p 01 00000 00001 0010
#
# Jump if ALU last result is not zero
p 00 00000 00001 0242
p 01 00000 00001 1001
p 01 00000 00001 0247
#
#
# Isolate AL[3:0] into r0
p 00 00000 00001 0243
p 01 00000 00001 490F
p 01 00000 00001 000F
#
# r1 = r0 + 6
p 00 00000 00001 0244
p 01 00000 00001 2A9F
p 01 00000 00001 0006
#
# Isolate the carry into bit[4] of previous addition into r1
p 00 00000 00001 0245
p 01 00000 00001 4AAF
p 01 00000 00001 0010
#
# Jump if ALU last result is zero
p 00 00000 00001 0246
p 01 00000 00001 1002
p 01 00000 00001 024E
#
#
# Isolate AL into r0
p 00 00000 00001 0247
p 01 00000 00001 490F
p 01 00000 00001 00FF
#
# r0 = r0 + 6
p 00 00000 00001 0248
p 01 00000 00001 299F
p 01 00000 00001 0006
#
# Zero ro[15:8] in case last addition overflows
p 00 00000 00001 0249
p 01 00000 00001 499F
p 01 00000 00001 00FF
#
# Zero out original AL
p 00 00000 00001 024A
p 01 00000 00001 400F
p 01 00000 00001 FF00
#
# Merge r0 which is the new AL into AX
p 00 00000 00001 024B
p 01 00000 00001 5009
p 01 00000 00001 0000
#
# Add 1 to AH
p 00 00000 00001 024C
p 01 00000 00001 200F
p 01 00000 00001 0100
#
# Set the AF Flag to 1
p 00 00000 00001 024D
p 01 00000 00001 588F
p 01 00000 00001 0010
#
#
# Zero AL[7:4]
p 00 00000 00001 024E
p 01 00000 00001 400F
p 01 00000 00001 FF0F
#
#
# Set the CF Flag to 1
p 00 00000 00001 024F
p 01 00000 00001 588F
p 01 00000 00001 0001
#
# Isolate AF flag into r0
p 00 00000 00001 0250
p 01 00000 00001 498F
p 01 00000 00001 0010
#
# Jump if ALU last result is not zero
p 00 00000 00001 0251
p 01 00000 00001 1001
p 01 00000 00001 0041
#
# Set the CF Flag to 0
p 00 00000 00001 0252
p 01 00000 00001 488F
p 01 00000 00001 FFFE
#
# Jump unconditional to NOP Microcode since it is identical 
p 00 00000 00001 0253
p 01 00000 00001 1000
p 01 00000 00001 0041
#
#
# -----------------------------------------------------
#
# 0x3F - AAS - ASCII Adjust for Subtraction  
#
# -----------------------------------------------------
#
# Write clock count=4 to the BIU Dataout register
p 00 00000 00001 0256
p 01 00000 00001 5FFF
p 01 00000 00001 C02C
#
# Isolate AF flag into r0
p 00 00000 00001 0257
p 01 00000 00001 498F
p 01 00000 00001 0010
#
# Jump if ALU last result is not zero
p 00 00000 00001 0258
p 01 00000 00001 1001
p 01 00000 00001 025D
#
#
# Isolate AL[3:0] into r0
p 00 00000 00001 0259
p 01 00000 00001 490F
p 01 00000 00001 000F
#
# r1 = r0 + 6
p 00 00000 00001 025A
p 01 00000 00001 2A9F
p 01 00000 00001 0006
#
# Isolate the carry into bit[4] of previous addition into r1
p 00 00000 00001 025B
p 01 00000 00001 4AAF
p 01 00000 00001 0010
#
# Jump if ALU last result is zero
p 00 00000 00001 025C
p 01 00000 00001 1002
p 01 00000 00001 0264
#
#
# Isolate AL into r0
p 00 00000 00001 025D
p 01 00000 00001 490F
p 01 00000 00001 00FF
#
# r0 = r0 - 6  (( Add FFFA ))
p 00 00000 00001 025E
p 01 00000 00001 299F
p 01 00000 00001 FFFA
#
# Zero out original AL
p 00 00000 00001 025F
p 01 00000 00001 400F
p 01 00000 00001 FF00
#
# Zero out upper byte of r0
p 00 00000 00001 0260
p 01 00000 00001 499F
p 01 00000 00001 00FF
#
# Merge r0 which is the new AL into AX
p 00 00000 00001 0261
p 01 00000 00001 5009
p 01 00000 00001 0000
#
# Subtract 1 from AH  (( Add FF00 ))
p 00 00000 00001 0262
p 01 00000 00001 200F
p 01 00000 00001 FF00
#
# Set the AF Flag to 1
p 00 00000 00001 0263
p 01 00000 00001 588F
p 01 00000 00001 0010
#
#
# Zero AL[7:4]
p 00 00000 00001 0264
p 01 00000 00001 400F
p 01 00000 00001 FF0F
#
#
# Set the CF Flag to 1
p 00 00000 00001 0265
p 01 00000 00001 588F
p 01 00000 00001 0001
#
# Isolate AF flag into r0
p 00 00000 00001 0266
p 01 00000 00001 498F
p 01 00000 00001 0010
#
# Jump if ALU last result is not zero
p 00 00000 00001 0267
p 01 00000 00001 1001
p 01 00000 00001 0041
#
# Set the CF Flag to 0
p 00 00000 00001 0268
p 01 00000 00001 488F
p 01 00000 00001 FFFE
#
# Jump unconditional to NOP Microcode since it is identical 
p 00 00000 00001 0269
p 01 00000 00001 1000
p 01 00000 00001 0041
#


# -----------------------------------------------------
#
# 0x27 - DAA - Decimal Adjust for Addition  
# 0x2F - DAS - Decimal Adjust for Subtraction
#
# -----------------------------------------------------
#
#
# DAA - Set r3 = 0
p 00 00000 00001 0270
p 01 00000 00001 5CFF
p 01 00000 00001 0000
#
# Jump unconditional to START1:
p 00 00000 00001 0271
p 01 00000 00001 1000
p 01 00000 00001 0273
#
# DAS - Set r3 = 1
p 00 00000 00001 0272
p 01 00000 00001 5CFF
p 01 00000 00001 0001
#
#
# START1:
# 
# Isolate Aux and CF Flags into into r2
p 00 00000 00001 0273
p 01 00000 00001 4B8F
p 01 00000 00001 0011
#
# Clear the AUX and Carry Flags
p 00 00000 00001 0274
p 01 00000 00001 488F
p 01 00000 00001 FFEE
#
# Store original AL into r1
p 00 00000 00001 0275
p 01 00000 00001 4A0F
p 01 00000 00001 00FF
#
# Isolate AL[3:0] into r0
p 00 00000 00001 0276
p 01 00000 00001 490F
p 01 00000 00001 000F
#
# Isolate r2 AUX Flag into Dummy
p 00 00000 00001 0277
p 01 00000 00001 4EBF
p 01 00000 00001 0010
#
# Jump if ALU last result is not zero to YES1:
p 00 00000 00001 0278
p 01 00000 00001 1001
p 01 00000 00001 027C
#
# r0 = r0 + 6
p 00 00000 00001 0279
p 01 00000 00001 299F
p 01 00000 00001 0006
#
# Isolate the carry into r0[4] of previous addition into Dummy
p 00 00000 00001 027A
p 01 00000 00001 4E9F
p 01 00000 00001 0010
#
# Jump if ALU last result is zero to START2
p 00 00000 00001 027B
p 01 00000 00001 1002
p 01 00000 00001 0285
#
#
# YES1
#
# Set the AUX Flag to 1
p 00 00000 00001 027C
p 01 00000 00001 588F
p 01 00000 00001 0010
#
# OR r3 with r3 into Dummy
p 00 00000 00001 027D
p 01 00000 00001 5ECC
p 01 00000 00001 0000
#
# Jump if ALU last result is not zero to SUB6:
p 00 00000 00001 027E
p 01 00000 00001 1001
p 01 00000 00001 0281
#
# r0 = r1 + 6
p 00 00000 00001 027F
p 01 00000 00001 29AF
p 01 00000 00001 0006
#
# Jump unconditional to Update AL:
p 00 00000 00001 0280
p 01 00000 00001 1000
p 01 00000 00001 0282
#
# SUB6: r0 = r1 - 6
p 00 00000 00001 0281
p 01 00000 00001 29AF
p 01 00000 00001 FFFA
#
# Update AL with first results
# Clear AX[7:0]
p 00 00000 00001 0282
p 01 00000 00001 400F
p 01 00000 00001 FF00
#
# Clear r0[15:8]
p 00 00000 00001 0283
p 01 00000 00001 499F
p 01 00000 00001 00FF
#
# Merge AX with r0
p 00 00000 00001 0284
p 01 00000 00001 5009
p 01 00000 00001 0000
#
#
# START2:
#
# First check to see if AF=1, CF=0 while original AL is 0x9A-0x9F.
# Bug/feature in real 8088 doesnt follow normal rules in this case.
#
# Dummy <= r2 XOR 0x10 - Identify if AUX=1 and CF=0
p 00 00000 00001 0285
p 01 00000 00001 6EBF
p 01 00000 00001 0010
#
# Jump if ALU last result is non zero to NORMAL
p 00 00000 00001 0286
p 01 00000 00001 1001
p 01 00000 00001 028E
#
# Isolate original AL[7:4] held in r1 into r0
p 00 00000 00001 0287
p 01 00000 00001 49AF
p 01 00000 00001 00F0
#
# r0 <= r0 - 0x90   Check if upper nibble of AL is a 9
p 00 00000 00001 0288
p 01 00000 00001 299F
p 01 00000 00001 FF70
#
# Jump if ALU last result is not zero to NORMAL
p 00 00000 00001 0289
p 01 00000 00001 1001
p 01 00000 00001 028E
#
# Isolate original AL[3:0] held in r1 into r0
p 00 00000 00001 028A
p 01 00000 00001 49AF
p 01 00000 00001 000F
#
# r0 <= r0 + 6
p 00 00000 00001 028B
p 01 00000 00001 299F
p 01 00000 00001 0006
#
# Isolate the carry into r0[4] of previous addition into Dummy
p 00 00000 00001 028C
p 01 00000 00001 4E9F
p 01 00000 00001 0010
#
# Jump if ALU last result is not zero to END
p 00 00000 00001 028D
p 01 00000 00001 1001
p 01 00000 00001 029D
#
#
# NORMAL:  Isolate r2 Carry Flag into Dummy
p 00 00000 00001 028E
p 01 00000 00001 4EBF
p 01 00000 00001 0001
#
# Jump if ALU last result is not zero to YES2:
p 00 00000 00001 028F
p 01 00000 00001 1001
p 01 00000 00001 0293
#
# r0 = r1 + 66
p 00 00000 00001 0290
p 01 00000 00001 29AF
p 01 00000 00001 0066
#
# Isolate the carry into r0[8] of previous addition into Dummy
p 00 00000 00001 0291
p 01 00000 00001 4E9F
p 01 00000 00001 0100
#
# Jump if ALU last result is zero to END
p 00 00000 00001 0292
p 01 00000 00001 1002
p 01 00000 00001 029D
#
#
# YES2:
# Set the CF Flag to 1
p 00 00000 00001 0293
p 01 00000 00001 588F
p 01 00000 00001 0001
#
# OR r3 with r3 into Dummy
p 00 00000 00001 0294
p 01 00000 00001 5ECC
p 01 00000 00001 0000
#
# Jump if ALU last result is not zero to SUB60:
p 00 00000 00001 0295
p 01 00000 00001 1001
p 01 00000 00001 0298
#
# r0 = AX + 60
p 00 00000 00001 0296
p 01 00000 00001 290F
p 01 00000 00001 0060
#
# Jump unconditional to Update AL:
p 00 00000 00001 0297
p 01 00000 00001 1000
p 01 00000 00001 029A
#
# SUB60: Clear r1[15:8] so there is no carry-in on next subtraction
p 00 00000 00001 0298
p 01 00000 00001 4A0F
p 01 00000 00001 00FF
#
# r0 = r1 - 60
p 00 00000 00001 0299
p 01 00000 00001 29AF
p 01 00000 00001 FFA0
#
# Update AL with Second results
# Clear AX[7:0]
p 00 00000 00001 029A
p 01 00000 00001 400F
p 01 00000 00001 FF00
#
# Clear r0[15:8]
p 00 00000 00001 029B
p 01 00000 00001 499F
p 01 00000 00001 00FF
#
# Merge AX with r0
p 00 00000 00001 029C
p 01 00000 00001 5009
p 01 00000 00001 0000
#
#
# END:
#
# Write clock count=4 to the BIU Dataout register
p 00 00000 00001 029D
p 01 00000 00001 5FFF
p 01 00000 00001 C02C
#
# Jump unconditional to code thet sets flags
p 00 00000 00001 029E
p 01 00000 00001 1000
p 01 00000 00001 0F20
#








# -----------------------------------------------------
#
# PROCEDURE - Fetch next byte from prefetch queue into r3[7:0]
#
# Jump to 0x02A0 to first remove the initial opcode from the prefetch queue
# Jump to 0x02A5 to fetch a subsequent byte from the top of the prefetch queue
#
# -----------------------------------------------------
#
# Strobe BIU - Fetch Opcode and set QS[1:0] to First Byte of Opcode 
p 00 00000 00001 02A0
p 01 00000 00001 5DDF
p 01 00000 00001 1004
#
# Debounce BIU Strobe
p 00 00000 00001 02A1
p 01 00000 00001 4DDF
p 01 00000 00001 CFF3
#
# Isolate the Prefetch Queue EMPTY bit into r3
p 00 00000 00001 02A2
p 01 00000 00001 4CEF
p 01 00000 00001 0080
#
# Jump to Prefetch Queue EMPTY bit check if last result is zero
p 00 00000 00001 02A3
p 01 00000 00001 1002
p 01 00000 00001 02A2
#
# Unconditional Jump over next opcode fetch
p 00 00000 00001 02A4
p 01 00000 00001 1000
p 01 00000 00001 02A9
#
# Strobe BIU - Fetch Opcode and set QS[1:0] to Subsequent Byte of Opcode 
p 00 00000 00001 02A5
p 01 00000 00001 5DDF
p 01 00000 00001 100C
#
# Debounce BIU Strobe
p 00 00000 00001 02A6
p 01 00000 00001 4DDF
p 01 00000 00001 CFF3
#
# Isolate the Prefetch Queue EMPTY bit into r3
p 00 00000 00001 02A7
p 01 00000 00001 4CEF
p 01 00000 00001 0080
#
# Jump to Prefetch Queue EMPTY bit check if last result is zero
p 00 00000 00001 02A8
p 01 00000 00001 1002
p 01 00000 00001 02A7
#
# Zero out r3
p 00 00000 00001 02A9
p 01 00000 00001 4CCF
p 01 00000 00001 0000
#
# r3 = 0000 OR prefetch_queue_byte
p 00 00000 00001 02AA
p 01 00000 00001 5CF4
p 01 00000 00001 0000
#
# Zero out r3[15:8]
p 00 00000 00001 02AB
p 01 00000 00001 4CCF
p 01 00000 00001 00FF
#
# Unconditional Jump to return address
p 00 00000 00001 02AC
p 01 00000 00001 1030
p 01 00000 00001 0000
#
#
# -----------------------------------------------------
#
# [0xD5 0x0A] - AAD - ASCII Adjust for Division
#
# -----------------------------------------------------
#
# Zero out r2
p 00 00000 00001 02AF
p 01 00000 00001 4BBF
p 01 00000 00001 0000
#
# Call procedure to fetch next byte from prefetch queue
p 00 00000 00001 02B0
p 01 00000 00001 1100
p 01 00000 00001 02A0
#
# If next byte is zero, just AND 00FF to original AX register
#
# Jump if last result is not zero to processing, otherwise the opcode byte was 0
p 00 00000 00001 02B1
p 01 00000 00001 1001
p 01 00000 00001 02B4
#
# AND 00FF to original AX register
p 00 00000 00001 02B2
p 01 00000 00001 400F
p 01 00000 00001 00FF
#
# Unconditional Jump to Flags processing
p 00 00000 00001 02B3
p 01 00000 00001 1000
p 01 00000 00001 02C0
#
# Second opcode byte is non-zero, so we can proceed
#
# Move AH down to AL byte in r0
#
# Swap bytes of AX into r0
p 00 00000 00001 02B4
p 01 00000 00001 390F
p 01 00000 00001 0000
#
# Clear r0[15:8]
p 00 00000 00001 02B5
p 01 00000 00001 499F
p 01 00000 00001 00FF
#
# Store second opcode byte into r1 to for counting
p 00 00000 00001 02B6
p 01 00000 00001 5AF4
p 01 00000 00001 0000
#
# Jump unconditional over first iteration of the loop
p 00 00000 00001 02B7
p 01 00000 00001 0000
p 01 00000 00001 02B9
#
# Add r2= r2 + r0
p 00 00000 00001 02B8
p 01 00000 00001 2BB9
p 01 00000 00001 0000
#
# Decrement r1  (( Add FFFF ))   first iteration  
p 00 00000 00001 02B9
p 01 00000 00001 2AAF
p 01 00000 00001 FFFF
#
# Jump to repeating the loop if last result is not zero
p 00 00000 00001 02BA
p 01 00000 00001 1001
p 01 00000 00001 02B8
#
# Zero out AH 
p 00 00000 00001 02BB
p 01 00000 00001 400F
p 01 00000 00001 00FF
#
# AX = AL + r2 
p 00 00000 00001 02BC
p 01 00000 00001 200B
p 01 00000 00001 0000
#
# Zero out AH in case there is carry into AH
p 00 00000 00001 02BD
p 01 00000 00001 400F
p 01 00000 00001 00FF
#
#
# Write clock count=60 to the BIU Dataout register  (57 actually since flags processing adds 3 clocks)
p 00 00000 00001 02BE
p 01 00000 00001 5FFF
p 01 00000 00001 C492
#
# Dummy = AX OR 0x0000 to populate last_alu for flags processing
p 00 00000 00001 02BF
p 01 00000 00001 5E0F
p 01 00000 00001 0000
#
# Call All_Flags_WORD
p 00 00000 00001 02C0
p 01 00000 00001 1100
p 01 00000 00001 03D3
#
# Jump unconditional to Multibyte ending
p 00 00000 00001 02C1
p 01 00000 00001 1000
p 01 00000 00001 0350
#
#
# -----------------------------------------------------
#
# [0xD4 0x0A] - AAM - ASCII Adjust for Multiply 
#
# -----------------------------------------------------
#
# Call procedure to fetch next byte from prefetch queue
p 00 00000 00001 02C7
p 01 00000 00001 1100
p 01 00000 00001 02A0
#
# Copy next opcode byte into r0
p 00 00000 00001 02C8
p 01 00000 00001 59F4
p 01 00000 00001 0000
#
# Isolate AL into r1
p 00 00000 00001 02C9
p 01 00000 00001 4A0F
p 01 00000 00001 00FF
#
# Zero out r2
p 00 00000 00001 02CA
p 01 00000 00001 4BBF
p 01 00000 00001 0000
#
# Two's complement r0: Invert r0  (r0 = r0 XOR FFFF)
p 00 00000 00001 02CB
p 01 00000 00001 699F
p 01 00000 00001 FFFF
#
# Two's complement r0: r0 = r0 + 1
p 00 00000 00001 02CC
p 01 00000 00001 299F
p 01 00000 00001 0001
#
# Start: r1 = r1 - r0   (add 2's complemented r0 value)
p 00 00000 00001 02CD
p 01 00000 00001 2AA9
p 01 00000 00001 0000
#
# Isolate r1[15] into r3 to see if subtraction caused a wrap around
p 00 00000 00001 02CE
p 01 00000 00001 4CAF
p 01 00000 00001 8000
#
# Jump if not zero to final processing - Means r0 < r1
p 00 00000 00001 02CF
p 01 00000 00001 1001
p 01 00000 00001 02D2
#
# r2 = r2 + 1
p 00 00000 00001 02D0
p 01 00000 00001 2BBF
p 01 00000 00001 0001
#
# Jump unconditional to Start:
p 00 00000 00001 02D1
p 01 00000 00001 1001
p 01 00000 00001 02CD
#
# Undo last subtraction: r1 = r1 + next_opcode 
p 00 00000 00001 02D2
p 01 00000 00001 2AA4
p 01 00000 00001 0000
#
# Swap bytes of r2
p 00 00000 00001 02D3
p 01 00000 00001 3BBF
p 01 00000 00001 0000
#
# Clear r2[7:0]
p 00 00000 00001 02D4
p 01 00000 00001 4BBF
p 01 00000 00001 FF00
#
# AX = r2 OR r1   - Merge answer into AH and remaingder into AL
p 00 00000 00001 02D5
p 01 00000 00001 50BA
p 01 00000 00001 0000
#
#
# Write clock count=83 to the BIU Dataout register  (80 actually since flags processing adds 3 clocks)
p 00 00000 00001 02D6
p 01 00000 00001 5FFF
p 01 00000 00001 C675
#
# Dummy = AX OR 0x0000 to populate last_alu for flags processing
p 00 00000 00001 02D7
p 01 00000 00001 5E0F
p 01 00000 00001 0000
#
# Call All_Flags_WORD
p 00 00000 00001 02D8
p 01 00000 00001 1100
p 01 00000 00001 03D3
#
# Jump unconditional to Multibyte ending
p 00 00000 00001 02D9
p 01 00000 00001 1000
p 01 00000 00001 0350
#
# Jump unconditional to Multibyte ending
p 00 00000 00001 02DA
p 01 00000 00001 1000
p 01 00000 00001 0350
#
#
# -----------------------------------------------------
#
# PROCEDURE - Fetch next word from prefetch queue into r3
#
# Jump to 0x02E0 to first remove the initial opcode from the prefetch queue
# Jump to 0x02E5 to just fetch a word from the top of the prefetch queue
#
# -----------------------------------------------------
#
# Strobe BIU - Fetch Opcode and set QS[1:0] to First Byte of Opcode 
p 00 00000 00001 02E0
p 01 00000 00001 5DDF
p 01 00000 00001 1004
#
# Debounce BIU Strobe
p 00 00000 00001 02E1
p 01 00000 00001 4DDF
p 01 00000 00001 CFF3
#
# Isolate the Prefetch Queue EMPTY bit into Dummy
p 00 00000 00001 02E2
p 01 00000 00001 4EEF
p 01 00000 00001 0080
#
# Jump to Prefetch Queue EMPTY bit check if last result is zero
p 00 00000 00001 02E3
p 01 00000 00001 1002
p 01 00000 00001 02E2
#
# Unconditional Jump over next opcode fetch
p 00 00000 00001 02E4
p 01 00000 00001 1000
p 01 00000 00001 02E9
#
# Strobe BIU - Fetch Opcode and set QS[1:0] to Subsequent Byte of Opcode
p 00 00000 00001 02E5
p 01 00000 00001 5DDF
p 01 00000 00001 100C
#
# Debounce BIU Strobe
p 00 00000 00001 02E6
p 01 00000 00001 4DDF
p 01 00000 00001 CFF3
#
# Isolate the Prefetch Queue EMPTY bit into Dummy
p 00 00000 00001 02E7
p 01 00000 00001 4EEF
p 01 00000 00001 0080
#
# Jump to Prefetch Queue EMPTY bit check if last result is zero
p 00 00000 00001 02E8
p 01 00000 00001 1002
p 01 00000 00001 02E7
#
# r3 = 0 + prefetch_queue_byte
p 00 00000 00001 02E9
p 01 00000 00001 2CF4
p 01 00000 00001 0000
#
# Swap bytes of r3
p 00 00000 00001 02EA
p 01 00000 00001 3CCF
p 01 00000 00001 0000
#
# Strobe BIU - Fetch Opcode and set QS[1:0] to Subsequent Byte of Opcode 
p 00 00000 00001 02EB
p 01 00000 00001 5DDF
p 01 00000 00001 100C
#
# Debounce BIU Strobe
p 00 00000 00001 02EC
p 01 00000 00001 4DDF
p 01 00000 00001 CFF3
#
# Isolate the Prefetch Queue EMPTY bit into Dummy
p 00 00000 00001 02ED
p 01 00000 00001 4EEF
p 01 00000 00001 0080
#
# Jump to Prefetch Queue EMPTY bit check if last result is zero
p 00 00000 00001 02EE
p 01 00000 00001 1002
p 01 00000 00001 02ED
#
# r3 = r3 + prefetch_queue_byte
p 00 00000 00001 02EF
p 01 00000 00001 2CC4
p 01 00000 00001 0000
#
# Swap bytes of r3
p 00 00000 00001 02F0
p 01 00000 00001 3CCF
p 01 00000 00001 0000
#
# Unconditional Jump to return address
p 00 00000 00001 02F1
p 01 00000 00001 1030
p 01 00000 00001 0000
#
#
#
# -----------------------------------------------------
#
# [0xB0 0xdd] - MOV AL,IMM8 
#
# -----------------------------------------------------
#
# Call procedure to fetch next byte from prefetch queue
p 00 00000 00001 02F8
p 01 00000 00001 1100
p 01 00000 00001 02A0
#
# Zero out AL
p 00 00000 00001 02F9
p 01 00000 00001 400F
p 01 00000 00001 FF00
#
# AX = AX + r3
p 00 00000 00001 02FA
p 01 00000 00001 200C
p 01 00000 00001 0000
#
# Jump unconditional to adding 4 clocks
p 00 00000 00001 02FB
p 01 00000 00001 1000
p 01 00000 00001 031C
#
# -----------------------------------------------------
#
# [0xB1 0xdd] - MOV CL,IMM8 
#
# -----------------------------------------------------
#
# Call procedure to fetch next byte from prefetch queue
p 00 00000 00001 02FC
p 01 00000 00001 1100
p 01 00000 00001 02A0
#
# Zero out CL
p 00 00000 00001 02FD
p 01 00000 00001 422F
p 01 00000 00001 FF00
#
# CX = CX + r3
p 00 00000 00001 02FE
p 01 00000 00001 222C
p 01 00000 00001 0000
#
# Jump unconditional to adding 4 clocks
p 00 00000 00001 02FF
p 01 00000 00001 1000
p 01 00000 00001 031C
#
#
# -----------------------------------------------------
#
# [0xB2 0xdd] - MOV DL,IMM8 
#
# -----------------------------------------------------
#
# Call procedure to fetch next byte from prefetch queue
p 00 00000 00001 0300
p 01 00000 00001 1100
p 01 00000 00001 02A0
#
# Zero out DL
p 00 00000 00001 0301
p 01 00000 00001 433F
p 01 00000 00001 FF00
#
# DX = DX + r3
p 00 00000 00001 0302
p 01 00000 00001 233C
p 01 00000 00001 0000
#
# Jump unconditional to adding 4 clocks
p 00 00000 00001 0303
p 01 00000 00001 1000
p 01 00000 00001 031C
#
# -----------------------------------------------------
#
# [0xB3 0xdd] - MOV BL,IMM8 
#
# -----------------------------------------------------
#
# Call procedure to fetch next byte from prefetch queue
p 00 00000 00001 0304
p 01 00000 00001 1100
p 01 00000 00001 02A0
#
# Zero out BL
p 00 00000 00001 0305
p 01 00000 00001 411F
p 01 00000 00001 FF00
#
# BX = BX + r3
p 00 00000 00001 0306
p 01 00000 00001 211C
p 01 00000 00001 0000
#
# Jump unconditional to adding 4 clocks
p 00 00000 00001 0307
p 01 00000 00001 1000
p 01 00000 00001 031C
#
#
#
# -----------------------------------------------------
#
# [0xB4 0xdd] - MOV AH,IMM8 
#
# -----------------------------------------------------
#
# Call procedure to fetch next byte from prefetch queue
p 00 00000 00001 0308
p 01 00000 00001 1100
p 01 00000 00001 02A0
#
# Swap bytes of r3
p 00 00000 00001 0309
p 01 00000 00001 3CCF
p 01 00000 00001 0000
#
# Zero out AH
p 00 00000 00001 030A
p 01 00000 00001 400F
p 01 00000 00001 00FF
#
# AX = AX + r3
p 00 00000 00001 030B
p 01 00000 00001 200C
p 01 00000 00001 0000
#
# Jump unconditional to adding 4 clocks
p 00 00000 00001 030C
p 01 00000 00001 1000
p 01 00000 00001 031C
#
#
# -----------------------------------------------------
#
# [0xB5 0xdd] - MOV CH,IMM8 
#
# -----------------------------------------------------
#
# Call procedure to fetch next byte from prefetch queue
p 00 00000 00001 030D
p 01 00000 00001 1100
p 01 00000 00001 02A0
#
# Swap bytes of r3
p 00 00000 00001 030E
p 01 00000 00001 3CCF
p 01 00000 00001 0000
#
# Zero out CH
p 00 00000 00001 030F
p 01 00000 00001 422F
p 01 00000 00001 00FF
#
# CX = CX + r3
p 00 00000 00001 0310
p 01 00000 00001 222C
p 01 00000 00001 0000
#
# Jump unconditional to adding 4 clocks
p 00 00000 00001 0311
p 01 00000 00001 1000
p 01 00000 00001 031C
#
#
# -----------------------------------------------------
#
# [0xB6 0xdd] - MOV DH,IMM8 
#
# -----------------------------------------------------
#
# Call procedure to fetch next byte from prefetch queue
p 00 00000 00001 0312
p 01 00000 00001 1100
p 01 00000 00001 02A0
#
# Swap bytes of r3
p 00 00000 00001 0313
p 01 00000 00001 3CCF
p 01 00000 00001 0000
#
# Zero out DH
p 00 00000 00001 0314
p 01 00000 00001 433F
p 01 00000 00001 00FF
#
# DX = DX + r3
p 00 00000 00001 0315
p 01 00000 00001 233C
p 01 00000 00001 0000
#
# Jump unconditional to adding 4 clocks
p 00 00000 00001 0316
p 01 00000 00001 1000
p 01 00000 00001 031C
#
#
# -----------------------------------------------------
#
# [0xB7 0xdd] - MOV BH,IMM8 
#
# -----------------------------------------------------
#
# Call procedure to fetch next byte from prefetch queue
p 00 00000 00001 0317
p 01 00000 00001 1100
p 01 00000 00001 02A0
#
# Swap bytes of r3
p 00 00000 00001 0318
p 01 00000 00001 3CCF
p 01 00000 00001 0000
#
# Zero out BH
p 00 00000 00001 0319
p 01 00000 00001 411F
p 01 00000 00001 00FF
#
# BX = BX + r3
p 00 00000 00001 031A
p 01 00000 00001 211C
p 01 00000 00001 0000
#
# NOP
p 00 00000 00001 031B
p 01 00000 00001 0000
p 01 00000 00001 0000
#
#
# Common code to write clock count=4 to the BIU Dataout register  
p 00 00000 00001 031C
p 01 00000 00001 5FFF
p 01 00000 00001 C027
#
# Jump unconditional to Multibyte ending
p 00 00000 00001 031D
p 01 00000 00001 1000
p 01 00000 00001 0350
#
#
#
# -----------------------------------------------------
#
# [0xB8 0xLO xHI] - MOV AX,IMM16
#
# -----------------------------------------------------

# Call procedure to fetch next word from prefetch queue
p 00 00000 00001 031E
p 01 00000 00001 1100
p 01 00000 00001 02E0
#
# AX = 0000 OR r3
p 00 00000 00001 031F
p 01 00000 00001 50FC
p 01 00000 00001 0000
#
# Jump unconditional to adding 4 clocks
p 00 00000 00001 0320
p 01 00000 00001 1000
p 01 00000 00001 031C
#
#
# -----------------------------------------------------
#
# [0xB9 0xLO xHI] - MOV CX,IMM16
#
# -----------------------------------------------------
#
# Call procedure to fetch next word from prefetch queue
p 00 00000 00001 0321
p 01 00000 00001 1100
p 01 00000 00001 02E0
#
# CX = 0000 OR r3
p 00 00000 00001 0322
p 01 00000 00001 52FC
p 01 00000 00001 0000
#
# Jump unconditional to adding 4 clocks
p 00 00000 00001 0323
p 01 00000 00001 1000
p 01 00000 00001 031C
#
#
# -----------------------------------------------------
#
# [0xBA 0xLO xHI] - MOV DX,IMM16
#
# -----------------------------------------------------
#
# Call procedure to fetch next word from prefetch queue
p 00 00000 00001 0324
p 01 00000 00001 1100
p 01 00000 00001 02E0
#
# DX = 0000 OR r3
p 00 00000 00001 0325
p 01 00000 00001 53FC
p 01 00000 00001 0000
#
# Jump unconditional to adding 4 clocks
p 00 00000 00001 0326
p 01 00000 00001 1000
p 01 00000 00001 031C
#
#
# -----------------------------------------------------
#
# [0xBB 0xLO xHI] - MOV BX,IMM16
#
# -----------------------------------------------------
#
# Call procedure to fetch next word from prefetch queue
p 00 00000 00001 0327
p 01 00000 00001 1100
p 01 00000 00001 02E0
#
# BX = 0000 OR r3
p 00 00000 00001 0328
p 01 00000 00001 51FC
p 01 00000 00001 0000
#
# Jump unconditional to adding 4 clocks
p 00 00000 00001 0329
p 01 00000 00001 1000
p 01 00000 00001 031C
#
#
# -----------------------------------------------------
#
# [0xBC 0xLO xHI] - MOV SP,IMM16
#
# -----------------------------------------------------
#
# Call procedure to fetch next word from prefetch queue
p 00 00000 00001 032A
p 01 00000 00001 1100
p 01 00000 00001 02E0
#
# SP = 0000 OR r3
p 00 00000 00001 032B
p 01 00000 00001 54FC
p 01 00000 00001 0000
#
# Jump unconditional to adding 4 clocks
p 00 00000 00001 032C
p 01 00000 00001 1000
p 01 00000 00001 031C
#
#
# -----------------------------------------------------
#
# [0xBD 0xLO xHI] - MOV BP,IMM16
#
# -----------------------------------------------------
#
# Call procedure to fetch next word from prefetch queue
p 00 00000 00001 032D
p 01 00000 00001 1100
p 01 00000 00001 02E0
#
# BP = 0000 OR r3
p 00 00000 00001 032E
p 01 00000 00001 55FC
p 01 00000 00001 0000
#
# Jump unconditional to adding 4 clocks
p 00 00000 00001 032F
p 01 00000 00001 1000
p 01 00000 00001 031C
#
#
# -----------------------------------------------------
#
# [0xBE 0xLO xHI] - MOV SI,IMM16
#
# -----------------------------------------------------
#
# Call procedure to fetch next word from prefetch queue
p 00 00000 00001 0330
p 01 00000 00001 1100
p 01 00000 00001 02E0
#
# SI = 0000 OR r3
p 00 00000 00001 0331
p 01 00000 00001 56FC
p 01 00000 00001 0000
#
# Jump unconditional to adding 4 clocks
p 00 00000 00001 0332
p 01 00000 00001 1000
p 01 00000 00001 031C
#
#
# -----------------------------------------------------
#
# [0xBF 0xLO xHI] - MOV DI,IMM16
#
# -----------------------------------------------------
#
# Call procedure to fetch next word from prefetch queue
p 00 00000 00001 0333
p 01 00000 00001 1100
p 01 00000 00001 02E0
#
# DI = 0000 OR r3
p 00 00000 00001 0334
p 01 00000 00001 57FC
p 01 00000 00001 0000
#
# Jump unconditional to adding 4 clocks
p 00 00000 00001 0335
p 01 00000 00001 1000
p 01 00000 00001 031C
#
#
#
# -----------------------------------------------------
#
# PROCEDURE - Sign Extend r3
#
# -----------------------------------------------------
#
# r3 = r3 AND 00FF
p 00 00000 00001 033A
p 01 00000 00001 4CCF
p 01 00000 00001 00FF
#
# Isolate r3[7] into Dummy
p 00 00000 00001 033B
p 01 00000 00001 4ECF
p 01 00000 00001 0080
#
# If last_alu is zero, then Jump back to calling address
p 00 00000 00001 033C
p 01 00000 00001 1032
p 01 00000 00001 0000
#
# r3 = r3 OR FF00  
p 00 00000 00001 033D
p 01 00000 00001 5CCF
p 01 00000 00001 FF00
#
# Jump unconditional to calling address
p 00 00000 00001 033E
p 01 00000 00001 1030
p 01 00000 00001 0000
#
#
# -----------------------------------------------------
#
# JUMP_NOT_TAKEN Processing
#
# -----------------------------------------------------
#
# CALL Fetch Opcode with QS=First opcode byte
p 00 00000 00001 0340
p 01 00000 00001 1100
p 01 00000 00001 02A0
#
# Write clock count=4 to the BIU Dataout register
p 00 00000 00001 0341
p 01 00000 00001 5FFF
p 01 00000 00001 C029
#
# Jump unconditional to Multibyte Ending 
p 00 00000 00001 0342
p 01 00000 00001 1000
p 01 00000 00001 0350
#
#
# -----------------------------------------------------
#
# JUMP_TAKEN8 Processing
#
# -----------------------------------------------------
#
# Write clock count=16 to the BIU Dataout register
p 00 00000 00001 0343
p 01 00000 00001 5FFF
p 01 00000 00001 C114
#
# CALL Fetch Opcode with QS=First opcode byte
p 00 00000 00001 0344
p 01 00000 00001 1100
p 01 00000 00001 02A0
#
# Strobe BIU - Fetch Opcode and set QS[1:0] to Subsequent Byte of Opcode 
p 00 00000 00001 0345
p 01 00000 00001 5DDF
p 01 00000 00001 100C
#
# Debounce BIU Strobe
p 00 00000 00001 0346
p 01 00000 00001 4DDF
p 01 00000 00001 0000
#
# CALL Sign Extend r3
p 00 00000 00001 0347
p 01 00000 00001 1100
p 01 00000 00001 033A
#
# r3 = r3 + prefetch_queue_address -- This is the new IP
p 00 00000 00001 0348
p 01 00000 00001 2CC8
p 01 00000 00001 0000
#
# Debounce the BIU Command fields
p 00 00000 00001 0349
p 01 00000 00001 4DDF
p 01 00000 00001 0000
#
# Set the BIU Command fields - Jump Request
p 00 00000 00001 034A
p 01 00000 00001 5DDF
p 01 00000 00001 0398
#
# Isolate the System Signals BIU_Done bit into Dummy
p 00 00000 00001 034B
p 01 00000 00001 4EEF
p 01 00000 00001 0040
#
# If last_alu is zero, then Jump to restest the bit
p 00 00000 00001 034C
p 01 00000 00001 1002
p 01 00000 00001 034B
#
# Debounce the BIU Command fields
p 00 00000 00001 034D
p 01 00000 00001 4DDF
p 01 00000 00001 0000
#
# Jump unconditional to Multibyte Ending except dont assert the QS as it has already been done.
p 00 00000 00001 034E
p 01 00000 00001 1000
p 01 00000 00001 0352
#
# -----------------------------------------------------
#
# Multi-Byte Opcode Ending code
# - Asserts QS=Subsequent byte
#
# -----------------------------------------------------
#
# Strobe BIU - Fetch Opcode and set QS[1:0] to Subsequent Byte of Opcode 
p 00 00000 00001 0350
p 01 00000 00001 5DDF
p 01 00000 00001 100C
#
# Debounce BIU Strobe
p 00 00000 00001 0351
p 01 00000 00001 4DDF
p 01 00000 00001 CFF3
#
# Strobe BIU - Set clock counter
p 00 00000 00001 0352
p 01 00000 00001 5DDF
p 01 00000 00001 2000
#
# Debounce BIU Strobe
p 00 00000 00001 0353
p 01 00000 00001 4DDF
p 01 00000 00001 CFFF
#
# Isolate System Signals clock counter zero bit
p 00 00000 00001 0354
p 01 00000 00001 4CEF
p 01 00000 00001 1000
#
# Jump to retest if last ALU is zero
p 00 00000 00001 0355
p 01 00000 00001 1002
p 01 00000 00001 0354
#
# Jump unconditional to main microcode loop
p 00 00000 00001 0356
p 01 00000 00001 1000
p 01 00000 00001 0004
#
#
# -----------------------------------------------------
#
# [0x70 0xdd] - JO - Jump if Overflow
#
# -----------------------------------------------------
#
# Isolate the O Flag bit into Dummy
p 00 00000 00001 0360
p 01 00000 00001 4E8F
p 01 00000 00001 0800
#
# Jump if last_alu is non-zero to JUMP_TAKEN8
p 00 00000 00001 0361
p 01 00000 00001 1001
p 01 00000 00001 0343
#
# Jump unconditional to JUMP_NOT_TAKEN
p 00 00000 00001 0362
p 01 00000 00001 1000
p 01 00000 00001 0340
#
#
# -----------------------------------------------------
#
# [0x71 0xdd] - JNO - Jump if Not Overflow
#
# -----------------------------------------------------
#
# Isolate the O Flag bit into Dummy
p 00 00000 00001 0363
p 01 00000 00001 4E8F
p 01 00000 00001 0800
#
# Jump if last_alu is zero to JUMP_TAKEN8
p 00 00000 00001 0364
p 01 00000 00001 1002
p 01 00000 00001 0343
#
# Jump unconditional to JUMP_NOT_TAKEN
p 00 00000 00001 0365
p 01 00000 00001 1000
p 01 00000 00001 0340
#
#
# -----------------------------------------------------
#
# [0x72 0xdd] - JB - Jump on Below
#
# -----------------------------------------------------
#
# Isolate the C Flag bit into Dummy
p 00 00000 00001 0366
p 01 00000 00001 4E8F
p 01 00000 00001 0001
#
# Jump if last_alu is non-zero to JUMP_TAKEN8
p 00 00000 00001 0367
p 01 00000 00001 1001
p 01 00000 00001 0343
#
# Jump unconditional to JUMP_NOT_TAKEN
p 00 00000 00001 0368
p 01 00000 00001 1000
p 01 00000 00001 0340
#
#
# -----------------------------------------------------
#
# [0x73 0xdd] - JNB - Jump on Not Below
#
# -----------------------------------------------------
#
# Isolate the C Flag bit into Dummy
p 00 00000 00001 0369
p 01 00000 00001 4E8F
p 01 00000 00001 0001
#
# Jump if last_alu is zero to JUMP_TAKEN8
p 00 00000 00001 036A
p 01 00000 00001 1002
p 01 00000 00001 0343
#
# Jump unconditional to JUMP_NOT_TAKEN
p 00 00000 00001 036B
p 01 00000 00001 1000
p 01 00000 00001 0340
#
#
# -----------------------------------------------------
#
# [0x74 0xdd] - JZ - Jump on Zero
#
# -----------------------------------------------------
#
# Isolate the Z Flag bit into Dummy
p 00 00000 00001 036C
p 01 00000 00001 4E8F
p 01 00000 00001 0040
#
# Jump if last_alu is non-zero to JUMP_TAKEN8
p 00 00000 00001 036D
p 01 00000 00001 1001
p 01 00000 00001 0343
#
# Jump unconditional to JUMP_NOT_TAKEN
p 00 00000 00001 036E
p 01 00000 00001 1000
p 01 00000 00001 0340
#
#
# -----------------------------------------------------
#
# [0x75 0xdd] - JNZ - Jump on Not Zero
#
# -----------------------------------------------------
#
# Isolate the Z Flag bit into Dummy
p 00 00000 00001 036F
p 01 00000 00001 4E8F
p 01 00000 00001 0040
#
# Jump if last_alu is zero to JUMP_TAKEN8
p 00 00000 00001 0370
p 01 00000 00001 1002
p 01 00000 00001 0343
#
# Jump unconditional to JUMP_NOT_TAKEN
p 00 00000 00001 0371
p 01 00000 00001 1000
p 01 00000 00001 0340
#
#
# -----------------------------------------------------
#
# [0x76 0xdd] - JNA - Jump on Not Above
#
# -----------------------------------------------------
#
# Isolate the Z and C Flag bits into Dummy
p 00 00000 00001 0372
p 01 00000 00001 4E8F
p 01 00000 00001 0041
#
# Jump if last_alu is non-zero to JUMP_TAKEN8
p 00 00000 00001 0373
p 01 00000 00001 1001
p 01 00000 00001 0343
#
# Jump unconditional to JUMP_NOT_TAKEN
p 00 00000 00001 0374
p 01 00000 00001 1000
p 01 00000 00001 0340
#
#
# -----------------------------------------------------
#
# [0x77 0xdd] - JA - Jump on Above
#
# -----------------------------------------------------
#
# Isolate the Z and C Flag bits into Dummy
p 00 00000 00001 0375
p 01 00000 00001 4E8F
p 01 00000 00001 0041
#
# Jump if last_alu is zero to JUMP_TAKEN8
p 00 00000 00001 0376
p 01 00000 00001 1002
p 01 00000 00001 0343
#
# Jump unconditional to JUMP_NOT_TAKEN
p 00 00000 00001 0377
p 01 00000 00001 1000
p 01 00000 00001 0340
#
#
# -----------------------------------------------------
#
# [0x78 0xdd] - JS - Jump on Sign
#
# -----------------------------------------------------
#
# Isolate the S Flag bit into Dummy
p 00 00000 00001 0378
p 01 00000 00001 4E8F
p 01 00000 00001 0080
#
# Jump if last_alu is non-zero to JUMP_TAKEN8
p 00 00000 00001 0379
p 01 00000 00001 1001
p 01 00000 00001 0343
#
# Jump unconditional to JUMP_NOT_TAKEN
p 00 00000 00001 037A
p 01 00000 00001 1000
p 01 00000 00001 0340
#
#
# -----------------------------------------------------
#
# [0x79 0xdd] - JNS - Jump on Not Sign
#
# -----------------------------------------------------
#
# Isolate the S Flag bit into Dummy
p 00 00000 00001 037B
p 01 00000 00001 4E8F
p 01 00000 00001 0080
#
# Jump if last_alu is zero to JUMP_TAKEN8
p 00 00000 00001 037C
p 01 00000 00001 1002
p 01 00000 00001 0343
#
# Jump unconditional to JUMP_NOT_TAKEN
p 00 00000 00001 037D
p 01 00000 00001 1000
p 01 00000 00001 0340
#
#
# -----------------------------------------------------
#
# [0x7A 0xdd] - JP - Jump on Parity
#
# -----------------------------------------------------
#
# Isolate the P Flag bit into Dummy
p 00 00000 00001 037E
p 01 00000 00001 4E8F
p 01 00000 00001 0004
#
# Jump if last_alu is non-zero to JUMP_TAKEN8
p 00 00000 00001 037F
p 01 00000 00001 1001
p 01 00000 00001 0343
#
# Jump unconditional to JUMP_NOT_TAKEN
p 00 00000 00001 0380
p 01 00000 00001 1000
p 01 00000 00001 0340
#
#
# -----------------------------------------------------
#
# [0x7B 0xdd] - JNP - Jump on Not Parity
#
# -----------------------------------------------------
#
# Isolate the P Flag bit into Dummy
p 00 00000 00001 0381
p 01 00000 00001 4E8F
p 01 00000 00001 0004
#
# Jump if last_alu is zero to JUMP_TAKEN8
p 00 00000 00001 0382
p 01 00000 00001 1002
p 01 00000 00001 0343
#
# Jump unconditional to JUMP_NOT_TAKEN
p 00 00000 00001 0383
p 01 00000 00001 1000
p 01 00000 00001 0340
#
#
# -----------------------------------------------------
#
# [0x7C 0xdd] - JL - Jump on Less
#
# -----------------------------------------------------
#
# Isolate the S Flag bit into r0
p 00 00000 00001 0384
p 01 00000 00001 498F
p 01 00000 00001 0080
#
# Isolate the O Flag bit into r1
p 00 00000 00001 0385
p 01 00000 00001 4A8F
p 01 00000 00001 0800
#
# Shift r1 to the right one bit
p 00 00000 00001 0386
p 01 00000 00001 7AAF
p 01 00000 00001 0000
#
# Shift r1 to the right one bit
p 00 00000 00001 0387
p 01 00000 00001 7AAF
p 01 00000 00001 0000
#
# Shift r1 to the right one bit
p 00 00000 00001 0388
p 01 00000 00001 7AAF
p 01 00000 00001 0000
#
# Shift r1 to the right one bit
p 00 00000 00001 0389
p 01 00000 00001 7AAF
p 01 00000 00001 0000
#
# dummy = r0 XOR r1
p 00 00000 00001 038A
p 01 00000 00001 6E9A
p 01 00000 00001 0000
#
# Jump if last_alu is non-zero to JUMP_TAKEN8
p 00 00000 00001 038B
p 01 00000 00001 1001
p 01 00000 00001 0343
#
# Jump unconditional to JUMP_NOT_TAKEN
p 00 00000 00001 038C
p 01 00000 00001 1000
p 01 00000 00001 0340
#
#
# -----------------------------------------------------
#
# [0x7D 0xdd] - JNL - Jump on Not Less
#
# -----------------------------------------------------
#
# Isolate the S Flag bit into r0
p 00 00000 00001 038D
p 01 00000 00001 498F
p 01 00000 00001 0080
#
# Isolate the O Flag bit into r1
p 00 00000 00001 038E
p 01 00000 00001 4A8F
p 01 00000 00001 0800
#
# Shift r1 to the right one bit
p 00 00000 00001 038F
p 01 00000 00001 7AAF
p 01 00000 00001 0000
#
# Shift r1 to the right one bit
p 00 00000 00001 0390
p 01 00000 00001 7AAF
p 01 00000 00001 0000
#
# Shift r1 to the right one bit
p 00 00000 00001 0391
p 01 00000 00001 7AAF
p 01 00000 00001 0000
#
# Shift r1 to the right one bit
p 00 00000 00001 0392
p 01 00000 00001 7AAF
p 01 00000 00001 0000
#
# dummy = r0 XOR r1
p 00 00000 00001 0393
p 01 00000 00001 6E9A
p 01 00000 00001 0000
#
# Jump if last_alu is zero to JUMP_TAKEN8
p 00 00000 00001 0394
p 01 00000 00001 1002
p 01 00000 00001 0343
#
# Jump unconditional to JUMP_NOT_TAKEN
p 00 00000 00001 0395
p 01 00000 00001 1000
p 01 00000 00001 0340
#
#
# -----------------------------------------------------
#
# [0x7E 0xdd] - JLE - Jump on Less or Equal
#
# -----------------------------------------------------
#
# Isolate the Z Flag bit into Dummy
p 00 00000 00001 0396
p 01 00000 00001 4E8F
p 01 00000 00001 0040
#
# Jump if last_alu is non-zero to JUMP_TAKEN8
p 00 00000 00001 0397
p 01 00000 00001 1001
p 01 00000 00001 0343
#
# Jump unconditional to test JL
p 00 00000 00001 0398
p 01 00000 00001 1000
p 01 00000 00001 0384
#
#
# -----------------------------------------------------
#
# [0x7F 0xdd] - JNLE - Jump on Not Less or Equal
#
# -----------------------------------------------------
#
# Isolate the Z Flag bit into Dummy
p 00 00000 00001 0399
p 01 00000 00001 4E8F
p 01 00000 00001 0040
#
# Jump if last_alu is non-zero to JUMP_NOT_TAKEN
p 00 00000 00001 039A
p 01 00000 00001 1001
p 01 00000 00001 0340
#
# Jump unconditional to test JNL
p 00 00000 00001 039B
p 01 00000 00001 1000
p 01 00000 00001 038D
#
#
# -----------------------------------------------------
#
# [0xE3 0xdd] - JCXZ - Jump if CX Register Zero
#
# -----------------------------------------------------
#
# Add 2 clocks to clock counter for this Jump type
# Write clock count=2 to the BIU Dataout register
p 00 00000 00001 039D
p 01 00000 00001 5FFF
p 01 00000 00001 C01D
#
# CALL WAIT_CLOCKS
p 00 00000 00001 039E
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Dummy = CX OR 0000
p 00 00000 00001 039F
p 01 00000 00001 5E2F
p 01 00000 00001 0000
#
# Jump if last_alu is zero to JUMP_TAKEN8
p 00 00000 00001 03A0
p 01 00000 00001 1002
p 01 00000 00001 0343
#
# Jump unconditional to JUMP_NOT_TAKEN
p 00 00000 00001 03A1
p 01 00000 00001 1000
p 01 00000 00001 0340
#
#
# -----------------------------------------------------
#
# [0xE2 0xdd] - LOOP
#
# -----------------------------------------------------
#
# Add 1 clock to clock counter for this Jump type
# Write clock count=1 to the BIU Dataout register
p 00 00000 00001 03A2
p 01 00000 00001 5FFF
p 01 00000 00001 C007
#
# CALL WAIT_CLOCKS
p 00 00000 00001 03A3
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# CX = CX - 1  ((Add FFFF))
p 00 00000 00001 03A4
p 01 00000 00001 222F
p 01 00000 00001 FFFF
#
# Jump if last_alu is non-zero to JUMP_TAKEN8
p 00 00000 00001 03A5
p 01 00000 00001 1001
p 01 00000 00001 0343
#
# Jump unconditional to JUMP_NOT_TAKEN
p 00 00000 00001 03A6
p 01 00000 00001 1000
p 01 00000 00001 0340
#
#
# -----------------------------------------------------
#
# [0xE1 0xdd] - LOOPZ - Loop While Zero
#
# -----------------------------------------------------
#
# Add 2 clock to clocks counter for this Jump type
# Write clock count=2 to the BIU Dataout register
p 00 00000 00001 03A8
p 01 00000 00001 5FFF
p 01 00000 00001 C01D
#
# CALL WAIT_CLOCKS
p 00 00000 00001 03A9
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# CX = CX - 1  ((Add FFFF))
p 00 00000 00001 03AA
p 01 00000 00001 222F
p 01 00000 00001 FFFF
#
# Jump if last_alu is zero to JUMP_NOT_TAKEN
p 00 00000 00001 03AB
p 01 00000 00001 1002
p 01 00000 00001 0340
#
# Isolate the Z Flag bit into Dummy
p 00 00000 00001 03AC
p 01 00000 00001 4E8F
p 01 00000 00001 0040
#
# Jump if last_alu is non-zero to JUMP_TAKEN8
p 00 00000 00001 03AD
p 01 00000 00001 1001
p 01 00000 00001 0343
#
# Jump unconditional to JUMP_NOT_TAKEN
p 00 00000 00001 03AE
p 01 00000 00001 1000
p 01 00000 00001 0340
#
#
# -----------------------------------------------------
#
# [0xEB 0xdd] - JMP - Disp8 
#
# -----------------------------------------------------
#
# Write clock count=15 to the BIU Dataout register
p 00 00000 00001 03B3
p 01 00000 00001 5FFF
p 01 00000 00001 C0F8
#
#
# Jump unconditional to JUMP_TAKEN8
p 00 00000 00001 03B4
p 01 00000 00001 1000
p 01 00000 00001 0344
#
# -----------------------------------------------------
#
# JUMP_TAKEN16 Processing
#
# Also: [0xE9 0xLO 0xHI] - JMP - Disp16
#
# -----------------------------------------------------
#
# CALL Fetch Opcode WORD with QS=First opcode byte
p 00 00000 00001 03B6
p 01 00000 00001 1100
p 01 00000 00001 02E0
#
# NOP
p 00 00000 00001 03B7
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# NOP
p 00 00000 00001 03B8
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# r3 = r3 + prefetch_queue_address -- This is address of 0xHI byte. Need to increment by 1 to point to next instruction
p 00 00000 00001 03B9
p 01 00000 00001 2CC8
p 01 00000 00001 0000
#
# r3 = r3 + 1 -- This is the new IP
p 00 00000 00001 03BA
p 01 00000 00001 2CCF
p 01 00000 00001 0001
#
# Set the BIU Command fields - Jump Request
p 00 00000 00001 03BB
p 01 00000 00001 5DDF
p 01 00000 00001 0398
#
# Isolate the System Signals BIU_Done bit into Dummy
p 00 00000 00001 03BC
p 01 00000 00001 4EEF
p 01 00000 00001 0040
#
# If last_alu is zero, then Jump to restest the bit
p 00 00000 00001 03BD
p 01 00000 00001 1002
p 01 00000 00001 03BC
#
# Debounce the BIU Command fields
p 00 00000 00001 03BE
p 01 00000 00001 4DDF
p 01 00000 00001 0000
#
# Write clock count=15 to the BIU Dataout register
p 00 00000 00001 03BF
p 01 00000 00001 5FFF
p 01 00000 00001 C0FF
#
# Jump unconditional to Multibyte Ending except dont assert the QS as it has already been done.
p 00 00000 00001 03C0
p 01 00000 00001 1000
p 01 00000 00001 0352
#
# -----------------------------------------------------
#
# [0xEA 0xLO 0xHI 0xCSLO 0xCSHI] - JMP - Intersegment
#
# -----------------------------------------------------
#
# CALL Fetch Opcode word with QS=First opcode byte
p 00 00000 00001 03C1
p 01 00000 00001 1100
p 01 00000 00001 02E0
#
# copy r3 to r2 - Store the next IP
p 00 00000 00001 03C2
p 01 00000 00001 5BFC
p 01 00000 00001 0000
#
# CALL Fetch Opcode word with QS=Subsequent opcode byte
p 00 00000 00001 03C3
p 01 00000 00001 1100
p 01 00000 00001 02E5 
#
# copy r3 to biu_dataout
p 00 00000 00001 03C4
p 01 00000 00001 5FFC
p 01 00000 00001 0000
#
# Strobe BIU - Set new CS Segment 
p 00 00000 00001 03C5
p 01 00000 00001 5DDF
p 01 00000 00001 3020
#
# Debounce BIU Strobe
p 00 00000 00001 03C6
p 01 00000 00001 4DDF
p 01 00000 00001 0000
#
# NOP
p 00 00000 00001 03C7
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# NOP
p 00 00000 00001 03C8
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# NOP
p 00 00000 00001 03C9
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# copy r2 to r3 - Store the next IP into r3, the BIU address register
p 00 00000 00001 03CA
p 01 00000 00001 5CBF
p 01 00000 00001 0000
#
# Set the BIU Command fields - Jump Request
p 00 00000 00001 03CB
p 01 00000 00001 5DFF
p 01 00000 00001 0398
#
# Isolate the System Signals BIU_Done bit into Dummy
p 00 00000 00001 03CC
p 01 00000 00001 4EEF
p 01 00000 00001 0040
#
# If last_alu is zero, then Jump to restest the bit
p 00 00000 00001 03CD
p 01 00000 00001 1002
p 01 00000 00001 03CC
#
# Debounce the BIU Command fields
p 00 00000 00001 03CE
p 01 00000 00001 4DDF
p 01 00000 00001 0000
#
# Write clock count=15 to the BIU Dataout register
p 00 00000 00001 03CF
p 01 00000 00001 5FFF
p 01 00000 00001 C0FA
#
# Jump unconditional to Multibyte Ending except dont assert the QS as it has already been done.
p 00 00000 00001 03D0
p 01 00000 00001 1000
p 01 00000 00001 0352
#
#
# -----------------------------------------------------
#
# PROCEDURE - Calculate All Flags for WORDS
#
# Input is assumed to be in the alu_last_result
# Destroys r2 and r3
#
# -----------------------------------------------------
#
#
# Calculate the S Flag
#
# r2 <= last_alu result
p 00 00000 00001 03D3
p 01 00000 00001 5BFD
p 01 00000 00001 0000
#
# Zero out the O, A, P, Z, S, C bit fields in Flag register
p 00 00000 00001 03D4
p 01 00000 00001 488F
p 01 00000 00001 F72A
#
# Isolate Bit[15] from r2 into Dummy
p 00 00000 00001 03D5
p 01 00000 00001 4EBF
p 01 00000 00001 8000
#
# if alu_last_result is zero then jump over next instruction
p 00 00000 00001 03D6
p 01 00000 00001 1002
p 01 00000 00001 03D8
#
# Set the Sign Flag bit to a 1
p 00 00000 00001 03D7
p 01 00000 00001 588F
p 01 00000 00001 0080
#
#
# Calculate the O, A, P, C flags
#
# Store r2 to r2 to make r2 the last_alu result
p 00 00000 00001 03D8
p 01 00000 00001 5BFB
p 01 00000 00001 0000
#
# Isolate the O, A, P and C flags from System Signals into r3 using AND
p 00 00000 00001 03D9
p 01 00000 00001 4CEF
p 01 00000 00001 0815
#
# Merge r3 into the Flags register using OR
p 00 00000 00001 03DA
p 01 00000 00001 588C
p 01 00000 00001 0000
#
#
# Calculate the Z Flag
#
# r2 <= r2
p 00 00000 00001 03DB
p 01 00000 00001 5BFB
p 01 00000 00001 0000
#
# if alu_last_result is not zero then jump to end
p 00 00000 00001 03DC
p 01 00000 00001 1001
p 01 00000 00001 03DE
#
# Set the Zero Flag bit to a 1
p 00 00000 00001 03DD
p 01 00000 00001 588F
p 01 00000 00001 0040
#
# Return to calling address
p 00 00000 00001 03DE
p 01 00000 00001 1030
p 01 00000 00001 0000
#
# -----------------------------------------------------
#
# [0xE0 0xdd] - LOOPNZ - Loop While Not Zero 
#
# -----------------------------------------------------
#
# Add 1 clock to clock counter for this Jump type
# Write clock count=1 to the BIU Dataout register
p 00 00000 00001 03E5
p 01 00000 00001 5FFF
p 01 00000 00001 C00A
#
# CALL WAIT_CLOCKS
p 00 00000 00001 03E6
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# CX = CX - 1  ((Add FFFF))
p 00 00000 00001 03E7
p 01 00000 00001 222F
p 01 00000 00001 FFFF
#
# Jump if last_alu is zero to JUMP_NOT_TAKEN
p 00 00000 00001 03E8
p 01 00000 00001 1002
p 01 00000 00001 0340
#
# Isolate the Z Flag bit into Dummy
p 00 00000 00001 03E9
p 01 00000 00001 4E8F
p 01 00000 00001 0040
#
# Jump if last_alu is non-zero to JUMP_NOT_TAKEN
p 00 00000 00001 03EA
p 01 00000 00001 1001
p 01 00000 00001 0340
#
# Add 2 clocks to clock counter for this Jump type
p 00 00000 00001 03EB
p 01 00000 00001 5FFF
p 01 00000 00001 C01D
#
# CALL WAIT_CLOCKS
p 00 00000 00001 03EC
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Jump unconditional to JUMP_TAKEN8
p 00 00000 00001 03ED
p 01 00000 00001 1000
p 01 00000 00001 0343
#
#
# -----------------------------------------------------
#
# PROCEDURE - Wait for BIU clocks
#
# Populate the BIU_Dataout register first with the clock count
#
# -----------------------------------------------------
#
# Strobe BIU - Set clock counter
p 00 00000 00001 03F2
p 01 00000 00001 5DDF
p 01 00000 00001 2000
#
# Debounce BIU Strobe
p 00 00000 00001 03F3
p 01 00000 00001 4DDF
p 01 00000 00001 CFFF
#
# Isolate System Signals clock counter zero bit into Dummy
p 00 00000 00001 03F4
p 01 00000 00001 4EEF
p 01 00000 00001 1000
#
# Jump to retest if last ALU is zero
p 00 00000 00001 03F5
p 01 00000 00001 1002
p 01 00000 00001 03F4
#
# Jump unconditional to calling address
p 00 00000 00001 03F6
p 01 00000 00001 1030
p 01 00000 00001 0000
#
#
# -----------------------------------------------------
#
# PROCEDURE - PUSH 
#
#  push biu_dataout register onto the stack
#
# -----------------------------------------------------
#
# SP = SP - 2  (( Add FFFE ))
p 00 00000 00001 0400
p 01 00000 00001 244F
p 01 00000 00001 FFFE
#
# Set r3 = SP.  r3 is the BIU target address
p 00 00000 00001 0401
p 01 00000 00001 5C4F
p 01 00000 00001 0000
#
# Make BIU request to write word to memory at Stack Segment
p 00 00000 00001 0402
p 01 00000 00001 5DDF
p 01 00000 00001 0340
#
# Isolate the System Signals BIU_Done bit into Dummy
p 00 00000 00001 0403
p 01 00000 00001 4EEF
p 01 00000 00001 0040
#
# If last_alu is zero, then Jump to restest the bit
p 00 00000 00001 0404
p 01 00000 00001 1002
p 01 00000 00001 0403
#
# Debounce the BIU Command fields
p 00 00000 00001 0405
p 01 00000 00001 4DDF
p 01 00000 00001 4003
#
# Jump unconditional to calling address
p 00 00000 00001 0406
p 01 00000 00001 1030
p 01 00000 00001 0000
#
#
# -----------------------------------------------------
#
# 0x06 - PUSH ES
#
# -----------------------------------------------------
#
# Write 14 clocks to clock counter
p 00 00000 00001 040A
p 01 00000 00001 5FFF
p 01 00000 00001 C053
#
# CALL WAIT_CLOCKS
p 00 00000 00001 040B
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Set biu_dataout register to ES
p 00 00000 00001 040C
p 01 00000 00001 5FF0
p 01 00000 00001 0000
#
# CALL PUSH Procedure
p 00 00000 00001 040D
p 01 00000 00001 1100
p 01 00000 00001 0400
#
# Jump unconditional to NOP ending
p 00 00000 00001 040E
p 01 00000 00001 1000
p 01 00000 00001 0045
#
#
# -----------------------------------------------------
#
# 0x0E - PUSH CS
#
# -----------------------------------------------------
#
# Write 14 clocks to clock counter
p 00 00000 00001 040F
p 01 00000 00001 5FFF
p 01 00000 00001 C053
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0410
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Set biu_dataout register to CS
p 00 00000 00001 0411
p 01 00000 00001 5FF2
p 01 00000 00001 0000
#
# CALL PUSH Procedure
p 00 00000 00001 0412
p 01 00000 00001 1100
p 01 00000 00001 0400
#
# Jump unconditional to NOP ending
p 00 00000 00001 0413
p 01 00000 00001 1000
p 01 00000 00001 0045
#
#
# -----------------------------------------------------
#
# 0x16 - PUSH SS
#
# -----------------------------------------------------
#
# Write 14 clocks to clock counter
p 00 00000 00001 0414
p 01 00000 00001 5FFF
p 01 00000 00001 C053
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0415
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Set biu_dataout register to SS
p 00 00000 00001 0416
p 01 00000 00001 5FF1
p 01 00000 00001 0000
#
# CALL PUSH Procedure
p 00 00000 00001 0417
p 01 00000 00001 1100
p 01 00000 00001 0400
#
# Jump unconditional to NOP ending
p 00 00000 00001 0418
p 01 00000 00001 1000
p 01 00000 00001 0045
#
#
# -----------------------------------------------------
#
# 0x1E - PUSH DS
#
# -----------------------------------------------------
#
# Write 14 clocks to clock counter
p 00 00000 00001 0419
p 01 00000 00001 5FFF
p 01 00000 00001 C053
#
# CALL WAIT_CLOCKS
p 00 00000 00001 041A
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Set biu_dataout register to DS
p 00 00000 00001 041B
p 01 00000 00001 5FF3
p 01 00000 00001 0000
#
# CALL PUSH Procedure
p 00 00000 00001 041C
p 01 00000 00001 1100
p 01 00000 00001 0400
#
# Jump unconditional to NOP ending
p 00 00000 00001 041D
p 01 00000 00001 1000
p 01 00000 00001 0045
#
#
# -----------------------------------------------------
#
# 0x9C - PUSHF - Push Flags
#
# -----------------------------------------------------
#
# Write 14 clocks to clock counter
p 00 00000 00001 041E
p 01 00000 00001 5FFF
p 01 00000 00001 C053
#
# CALL WAIT_CLOCKS
p 00 00000 00001 041F
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Set biu_dataout register to Flags and set bits [15:12] to F like 8088 does.
p 00 00000 00001 0420
p 01 00000 00001 5F8F
p 01 00000 00001 F000
#
# CALL PUSH Procedure
p 00 00000 00001 0421
p 01 00000 00001 1100
p 01 00000 00001 0400
#
# Jump unconditional to NOP ending
p 00 00000 00001 0422
p 01 00000 00001 1000
p 01 00000 00001 0045
#
#
# -----------------------------------------------------
#
# 0x50 - PUSH AX
#
# -----------------------------------------------------
#
# Write 15 clocks to clock counter
p 00 00000 00001 0423
p 01 00000 00001 5FFF
p 01 00000 00001 C07B
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0424
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Set biu_dataout register to AX
p 00 00000 00001 0425
p 01 00000 00001 5F0F
p 01 00000 00001 0000
#
# CALL PUSH Procedure
p 00 00000 00001 0426
p 01 00000 00001 1100
p 01 00000 00001 0400
#
# Jump unconditional to NOP ending
p 00 00000 00001 0427
p 01 00000 00001 1000
p 01 00000 00001 0045
#
#
# -----------------------------------------------------
#
# 0x51 - PUSH CX
#
# -----------------------------------------------------
#
# Write 15 clocks to clock counter
p 00 00000 00001 0428
p 01 00000 00001 5FFF
p 01 00000 00001 C07B
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0429
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Set biu_dataout register to CX
p 00 00000 00001 042A
p 01 00000 00001 5F2F
p 01 00000 00001 0000
#
# CALL PUSH Procedure
p 00 00000 00001 042B
p 01 00000 00001 1100
p 01 00000 00001 0400
#
# Jump unconditional to NOP ending
p 00 00000 00001 042C
p 01 00000 00001 1000
p 01 00000 00001 0045
#
#
# -----------------------------------------------------
#
# 0x52 - PUSH DX
#
# -----------------------------------------------------
#
# Write 15 clocks to clock counter
p 00 00000 00001 042D
p 01 00000 00001 5FFF
p 01 00000 00001 C07B
#
# CALL WAIT_CLOCKS
p 00 00000 00001 042E
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Set biu_dataout register to DX
p 00 00000 00001 042F
p 01 00000 00001 5F3F
p 01 00000 00001 0000
#
# CALL PUSH Procedure
p 00 00000 00001 0430
p 01 00000 00001 1100
p 01 00000 00001 0400
#
# Jump unconditional to NOP ending
p 00 00000 00001 0431
p 01 00000 00001 1000
p 01 00000 00001 0045
#
#
# -----------------------------------------------------
#
# 0x53 - PUSH BX
#
# -----------------------------------------------------
#
# Write 15 clocks to clock counter
p 00 00000 00001 0432
p 01 00000 00001 5FFF
p 01 00000 00001 C07B
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0433
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Set biu_dataout register to BX
p 00 00000 00001 0434
p 01 00000 00001 5F1F
p 01 00000 00001 0000
#
# CALL PUSH Procedure
p 00 00000 00001 0435
p 01 00000 00001 1100
p 01 00000 00001 0400
#
# Jump unconditional to NOP ending
p 00 00000 00001 0436
p 01 00000 00001 1000
p 01 00000 00001 0045
#
#
# -----------------------------------------------------
#
# 0x57 - PUSH DI
#
# -----------------------------------------------------
#
# Write 15 clocks to clock counter
p 00 00000 00001 0437
p 01 00000 00001 5FFF
p 01 00000 00001 C07B
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0438
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Set biu_dataout register to DI
p 00 00000 00001 0439
p 01 00000 00001 5F7F
p 01 00000 00001 0000
#
# CALL PUSH Procedure
p 00 00000 00001 043A
p 01 00000 00001 1100
p 01 00000 00001 0400
#
# Jump unconditional to NOP ending
p 00 00000 00001 043B
p 01 00000 00001 1000
p 01 00000 00001 0045
#
#
# -----------------------------------------------------
#
# 0x55 - PUSH BP
#
# -----------------------------------------------------
#
# Write 15 clocks to clock counter
p 00 00000 00001 043C
p 01 00000 00001 5FFF
p 01 00000 00001 C07B
#
# CALL WAIT_CLOCKS
p 00 00000 00001 043D
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Set biu_dataout register to BP
p 00 00000 00001 043E
p 01 00000 00001 5F5F
p 01 00000 00001 0000
#
# CALL PUSH Procedure
p 00 00000 00001 043F
p 01 00000 00001 1100
p 01 00000 00001 0400
#
# Jump unconditional to NOP ending
p 00 00000 00001 0440
p 01 00000 00001 1000
p 01 00000 00001 0045
#
#
# -----------------------------------------------------
#
# 0x56 - PUSH SI
#
# -----------------------------------------------------
#
# Write 15 clocks to clock counter
p 00 00000 00001 0441
p 01 00000 00001 5FFF
p 01 00000 00001 C07B
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0442
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Set biu_dataout register to SI
p 00 00000 00001 0443
p 01 00000 00001 5F6F
p 01 00000 00001 0000
#
# CALL PUSH Procedure
p 00 00000 00001 0444
p 01 00000 00001 1100
p 01 00000 00001 0400
#
# Jump unconditional to NOP ending
p 00 00000 00001 0445
p 01 00000 00001 1000
p 01 00000 00001 0045
#

# -----------------------------------------------------
#
# 0x54 - PUSH SP
#
# -----------------------------------------------------
#
# Write 15 clocks to clock counter
p 00 00000 00001 0446
p 01 00000 00001 5FFF
p 01 00000 00001 C07B
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0447
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Set biu_dataout register to SP-2 ((Add FFFE))
p 00 00000 00001 0448
p 01 00000 00001 2F4F
p 01 00000 00001 FFFE
#
# CALL PUSH Procedure
p 00 00000 00001 0449
p 01 00000 00001 1100
p 01 00000 00001 0400
#
# Jump unconditional to NOP ending
p 00 00000 00001 044A
p 01 00000 00001 1000
p 01 00000 00001 0045
#
#
# -----------------------------------------------------
#
# PROCEDURE - POP
#
#  pop stack onto BIU Return Data register
#
# -----------------------------------------------------
#
# Set r3 = SP.  r3 is the BIU target address
p 00 00000 00001 0450
p 01 00000 00001 5C4F
p 01 00000 00001 0000
#
# Make BIU request to read word from memory at Stack Segment
p 00 00000 00001 0451
p 01 00000 00001 5DDF
p 01 00000 00001 0310
#
# Isolate the System Signals BIU_Done bit into Dummy
p 00 00000 00001 0452
p 01 00000 00001 4EEF
p 01 00000 00001 0040
#
# If last_alu is zero, then Jump to restest the bit
p 00 00000 00001 0453
p 01 00000 00001 1002
p 01 00000 00001 0452
#
# Debounce the BIU Command fields
p 00 00000 00001 0454
p 01 00000 00001 4DDF
p 01 00000 00001 4003
#
# SP = SP + 2
p 00 00000 00001 0455
p 01 00000 00001 244F
p 01 00000 00001 0002
#
# Jump unconditional to calling address
p 00 00000 00001 0456
p 01 00000 00001 1030
p 01 00000 00001 0000
#
#
# -----------------------------------------------------
#
# 0x07 - POP ES
#
# -----------------------------------------------------
#
# CALL POP Procedure
p 00 00000 00001 0457
p 01 00000 00001 1100
p 01 00000 00001 0450
#
# Copy BIU Return Data to the BIU Data Out register to update the segment register in the BIU
p 00 00000 00001 0458
p 01 00000 00001 5FF7
p 01 00000 00001 0000
#
# Strobe BIU - Set new ES Segment Register
p 00 00000 00001 0459
p 01 00000 00001 5DDF
p 01 00000 00001 3000
#
# Debounce BIU Strobe
p 00 00000 00001 045A
p 01 00000 00001 4DDF
p 01 00000 00001 CFF3
#
# Jump unconditional to POP_SEGREG ending
p 00 00000 00001 045B
p 01 00000 00001 1000
p 01 00000 00001 0470
#
#
# -----------------------------------------------------
#
# 0x0F - POP CS
#
# -----------------------------------------------------
#
# CALL POP Procedure
p 00 00000 00001 045C
p 01 00000 00001 1100
p 01 00000 00001 0450
#
# Copy BIU Return Data to the BIU Data Out register to update the segment register in the BIU
p 00 00000 00001 045D
p 01 00000 00001 5FF7
p 01 00000 00001 0000
#
# Strobe BIU - Set new CS Segment Register
p 00 00000 00001 045E
p 01 00000 00001 5DDF
p 01 00000 00001 3020
#
# Debounce BIU Strobe
p 00 00000 00001 045F
p 01 00000 00001 4DDF
p 01 00000 00001 CFD3
#
# Jump unconditional to POP_SEGREG ending
p 00 00000 00001 0460
p 01 00000 00001 1000
p 01 00000 00001 0470
#
#
# -----------------------------------------------------
#
# 0x17 - POP SS
#
# -----------------------------------------------------
#
# CALL POP Procedure
p 00 00000 00001 0461
p 01 00000 00001 1100
p 01 00000 00001 0450
#
# Copy BIU Return Data to the BIU Data Out register to update the segment register in the BIU
p 00 00000 00001 0462
p 01 00000 00001 5FF7
p 01 00000 00001 0000
#
# Strobe BIU - Set new SS Segment Register
p 00 00000 00001 0463
p 01 00000 00001 5DDF
p 01 00000 00001 3010
#
# Debounce BIU Strobe
p 00 00000 00001 0464
p 01 00000 00001 4DDF
p 01 00000 00001 CFE3
#
# Jump unconditional to POP_SEGREG ending
p 00 00000 00001 0465
p 01 00000 00001 1000
p 01 00000 00001 0470
#
#
# -----------------------------------------------------
#
# 0x1F - POP DS
#
# -----------------------------------------------------
#
# CALL POP Procedure
p 00 00000 00001 0466
p 01 00000 00001 1100
p 01 00000 00001 0450
#
# Copy BIU Return Data to the BIU Data Out register to update the segment register in the BIU
p 00 00000 00001 0467
p 01 00000 00001 5FF7
p 01 00000 00001 0000
#
# Strobe BIU - Set new DS Segment Register
p 00 00000 00001 0468
p 01 00000 00001 5DDF
p 01 00000 00001 3030
#
# Debounce BIU Strobe
p 00 00000 00001 0469
p 01 00000 00001 4DDF
p 01 00000 00001 CFC3
#
# Jump unconditional to POP_SEGREG ending
p 00 00000 00001 046A
p 01 00000 00001 1000
p 01 00000 00001 0470
#
# -----------------------------------------------------
#
# Common POP_SEGREG code 
#
# -----------------------------------------------------
#
# Write 12 clocks to clock counter
p 00 00000 00001 0470
p 01 00000 00001 5FFF
p 01 00000 00001 C02B
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0471
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Strobe BIU - Fetch Opcode and set QS[1:0] to First Byte of Opcode 
p 00 00000 00001 0472
p 01 00000 00001 5DDF
p 01 00000 00001 1004
#
# Debounce BIU Strobe
p 00 00000 00001 0473
p 01 00000 00001 4DDF
p 01 00000 00001 0000
#
# Need to wait until next instruction available in the prefetch queue before
# returning to the EU main loop and jumping over the interrupt checking.
#
# Isolate the Prefetch Queue EMPTY bit into Dummy
p 00 00000 00001 0474
p 01 00000 00001 4EEF
p 01 00000 00001 0080
#
# Jump to Prefetch Queue EMPTY bit check if last result is zero
p 00 00000 00001 0475
p 01 00000 00001 1002
p 01 00000 00001 0474
#
# Debounce the Prefix  flags which are stale because of EA calculation
# and all strobes to be safe.
p 00 00000 00001 0476
p 01 00000 00001 488F
p 01 00000 00001 0FD5
#
# Debounce all BIU Fields
p 00 00000 00001 0477
p 01 00000 00001 4DDF
p 01 00000 00001 0000
#
# Jump unconditional to main loop skipping all interrupts
p 00 00000 00001 0478
p 01 00000 00001 1000
p 01 00000 00001 0011
#
# -----------------------------------------------------
#
# 0x58 - POP AX
#
# -----------------------------------------------------
#
# CALL POP Procedure
p 00 00000 00001 0480
p 01 00000 00001 1100
p 01 00000 00001 0450
#
# Copy BIU Return Data to AX
p 00 00000 00001 0481
p 01 00000 00001 50F7
p 01 00000 00001 0000
#
# Jump unconditional to NOP ending
p 00 00000 00001 0482
p 01 00000 00001 1000
p 01 00000 00001 0040
#
#
# -----------------------------------------------------
#
# 0x59 - POP CX
#
# -----------------------------------------------------
#
# CALL POP Procedure
p 00 00000 00001 0483
p 01 00000 00001 1100
p 01 00000 00001 0450
#
# Copy BIU Return Data to CX
p 00 00000 00001 0484
p 01 00000 00001 52F7
p 01 00000 00001 0000
#
# Jump unconditional to NOP ending
p 00 00000 00001 0485
p 01 00000 00001 1000
p 01 00000 00001 0040
#
#
# -----------------------------------------------------
#
# 0x5A - POP DX
#
# -----------------------------------------------------
#
# CALL POP Procedure
p 00 00000 00001 0486
p 01 00000 00001 1100
p 01 00000 00001 0450
#
# Copy BIU Return Data to DX
p 00 00000 00001 0487
p 01 00000 00001 53F7
p 01 00000 00001 0000
#
# Jump unconditional to NOP ending
p 00 00000 00001 0488
p 01 00000 00001 1000
p 01 00000 00001 0040
#
#
# -----------------------------------------------------
#
# 0x5B - POP BX
#
# -----------------------------------------------------
#
# CALL POP Procedure
p 00 00000 00001 0489
p 01 00000 00001 1100
p 01 00000 00001 0450
#
# Copy BIU Return Data to BX
p 00 00000 00001 048A
p 01 00000 00001 51F7
p 01 00000 00001 0000
#
# Jump unconditional to NOP ending
p 00 00000 00001 048B
p 01 00000 00001 1000
p 01 00000 00001 0040
#
#
# -----------------------------------------------------
#
# 0x5C - POP SP
#
# -----------------------------------------------------
#
# CALL POP Procedure
p 00 00000 00001 048C
p 01 00000 00001 1100
p 01 00000 00001 0450
#
# Copy BIU Return Data to SP
p 00 00000 00001 048D
p 01 00000 00001 54F7
p 01 00000 00001 0000
#
# Jump unconditional to NOP ending
p 00 00000 00001 048E
p 01 00000 00001 1000
p 01 00000 00001 0040
#
#
# -----------------------------------------------------
#
# 0x5D - POP BP
#
# -----------------------------------------------------
#
# CALL POP Procedure
p 00 00000 00001 048F
p 01 00000 00001 1100
p 01 00000 00001 0450
#
# Copy BIU Return Data to BP
p 00 00000 00001 0490
p 01 00000 00001 55F7
p 01 00000 00001 0000
#
# Jump unconditional to NOP ending
p 00 00000 00001 0491
p 01 00000 00001 1000
p 01 00000 00001 0040
#
#
# -----------------------------------------------------
#
# 0x5E - POP SI
#
# -----------------------------------------------------
#
# CALL POP Procedure
p 00 00000 00001 0492
p 01 00000 00001 1100
p 01 00000 00001 0450
#
# Copy BIU Return Data to SI
p 00 00000 00001 0493
p 01 00000 00001 56F7
p 01 00000 00001 0000
#
# Jump unconditional to NOP ending
p 00 00000 00001 0494
p 01 00000 00001 1000
p 01 00000 00001 0040
#
#
# -----------------------------------------------------
#
# 0x5F - POP DI
#
# -----------------------------------------------------
#
# CALL POP Procedure
p 00 00000 00001 0495
p 01 00000 00001 1100
p 01 00000 00001 0450
#
# Copy BIU Return Data to DI
p 00 00000 00001 0496
p 01 00000 00001 57F7
p 01 00000 00001 0000
#
# Jump unconditional to NOP ending
p 00 00000 00001 0497
p 01 00000 00001 1000
p 01 00000 00001 0040
#
#
# -----------------------------------------------------
#
# 0x9D - POPF - POP Flags
#
# -----------------------------------------------------
#
# CALL POP Procedure
p 00 00000 00001 0498
p 01 00000 00001 1100
p 01 00000 00001 0450
#
# Copy BIU Return Data to the Flags register
p 00 00000 00001 0499
p 01 00000 00001 58F7
p 01 00000 00001 0000
#
# Clear all prefixes and pending flags
p 00 00000 00001 049A
p 01 00000 00001 488F
p 01 00000 00001 0FD5
#
# Jump unconditional to NOP ending
p 00 00000 00001 049B
p 01 00000 00001 1000
p 01 00000 00001 0045
#
#
# -----------------------------------------------------
#
# [0xE8 0xLO 0xHI] - CALL Intra-segment
#
# -----------------------------------------------------
#
# Load r0 with 0x3
p 00 00000 00001 04A0
p 01 00000 00001 59FF
p 01 00000 00001 0003
#
# Add r0 to the current IP into biu_dataout for the address to push to the stack
p 00 00000 00001 04A1
p 01 00000 00001 2F98
p 01 00000 00001 0000
#
# CALL PUSH Procedure
p 00 00000 00001 04A2
p 01 00000 00001 1100
p 01 00000 00001 0400
#
# Jump unconditional to JUMP_TAKEN16 
p 00 00000 00001 04A3
p 01 00000 00001 1000
p 01 00000 00001 03B6
#
#
# -----------------------------------------------------
#
# [0x9A 0xLO 0xHI 0xCSLO 0xCSHI] - CALL Inter-segment
#
# -----------------------------------------------------
#
# Copy the current CS into biu_dataout for the address to push to the stack
p 00 00000 00001 04A6
p 01 00000 00001 5FF2
p 01 00000 00001 0000
#
# CALL PUSH Procedure
p 00 00000 00001 04A7
p 01 00000 00001 1100
p 01 00000 00001 0400
#
# Load r0 with 0x5
p 00 00000 00001 04A8
p 01 00000 00001 59FF
p 01 00000 00001 0005
#
# Add r0 to the current IP into biu_dataout for the address to push to the stack
p 00 00000 00001 04A9
p 01 00000 00001 2F98
p 01 00000 00001 0000
#
# CALL PUSH Procedure
p 00 00000 00001 04AA
p 01 00000 00001 1100
p 01 00000 00001 0400
#
# Jump unconditional to JMP - Intersegment
p 00 00000 00001 04AB
p 01 00000 00001 1000
p 01 00000 00001 03C1
#
#
# -----------------------------------------------------
#
# 0xC3 - Return - Intra-Segment  
#
# -----------------------------------------------------
#
# Write 20 clocks to clock counter
p 00 00000 00001 04BC
p 01 00000 00001 5FFF
p 01 00000 00001 C053
#
# CALL WAIT_CLOCKS
p 00 00000 00001 04BD
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# CALL POP Procedure
p 00 00000 00001 04BE
p 01 00000 00001 1100
p 01 00000 00001 0450
#
# Copy BIU Return Data to r3; the biu address register
p 00 00000 00001 04BF
p 01 00000 00001 5CF7
p 01 00000 00001 0000
#
# NOP
p 00 00000 00001 04C0
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# Debounce the BIU Command fields and all prefixes
p 00 00000 00001 04C1
p 01 00000 00001 4DDF
p 01 00000 00001 0000
#
# Set the BIU Command fields - Jump Request
p 00 00000 00001 04C2
p 01 00000 00001 5DDF
p 01 00000 00001 0390
#
# Isolate the System Signals BIU_Done bit into Dummy
p 00 00000 00001 04C3
p 01 00000 00001 4EEF
p 01 00000 00001 0040
#
# If last_alu is zero, then Jump to restest the bit
p 00 00000 00001 04C4
p 01 00000 00001 1002
p 01 00000 00001 04C3
#
# Debounce the BIU Command fields and all prefixes
p 00 00000 00001 04C5
p 01 00000 00001 4DDF
p 01 00000 00001 0000
#
# Jump unconditional to main microcode loop
p 00 00000 00001 04C6
p 01 00000 00001 1000
p 01 00000 00001 0004
#
#
# -----------------------------------------------------
#
# 0xCB - Return - Inter-Segment
#
# -----------------------------------------------------
#
# Write 34 clocks to clock counter
p 00 00000 00001 04C7
p 01 00000 00001 5FFF
p 01 00000 00001 C063
#
# CALL WAIT_CLOCKS
p 00 00000 00001 04C8
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# CALL POP Procedure - pop the IP
p 00 00000 00001 04C9
p 01 00000 00001 1100
p 01 00000 00001 0450
#
# Copy BIU Return Data to r2 to store the biu address register
p 00 00000 00001 04CA
p 01 00000 00001 5BF7
p 01 00000 00001 0000
#
# CALL POP Procedure - Pop the CS
p 00 00000 00001 04CB
p 01 00000 00001 1100
p 01 00000 00001 0450
#
# Copy BIU Return Data to biu_dataout register
p 00 00000 00001 04CC
p 01 00000 00001 5FF7
p 01 00000 00001 0000
#
# Strobe BIU - Set new CS Segment 
p 00 00000 00001 04CD
p 01 00000 00001 5DDF
p 01 00000 00001 3020
#
# Debounce BIU Strobe
p 00 00000 00001 04CE
p 01 00000 00001 4DDF
p 01 00000 00001 CFD3
#
# Debounce the BIU Command fields
p 00 00000 00001 04CF
p 01 00000 00001 4DDF
p 01 00000 00001 0000
#
# Copy r2 to r3 to set the biu address
p 00 00000 00001 04D0
p 01 00000 00001 5CFB
p 01 00000 00001 0000
#
# Jump unconditional to RET 0xC3 Jump Request code
p 00 00000 00001 04D1
p 01 00000 00001 1000
p 01 00000 00001 04C2
#
#
# -----------------------------------------------------
#
# 0xC2 - Return - Intra-Segment and Add Immediate to Stack Pointer
#
# -----------------------------------------------------
#
# Write 24 clocks to clock counter
p 00 00000 00001 04D5
p 01 00000 00001 5FFF
p 01 00000 00001 C03F
#
# CALL WAIT_CLOCKS
p 00 00000 00001 04D6
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# CALL POP Procedure
p 00 00000 00001 04D7
p 01 00000 00001 1100
p 01 00000 00001 0450
#
# Copy BIU Return Data to r0 temporarily
p 00 00000 00001 04D8
p 01 00000 00001 59F7
p 01 00000 00001 0000
#
# Call procedure to fetch next word from prefetch queue into r3 QS = Initial Opcode Fetch
p 00 00000 00001 04D9
p 01 00000 00001 1100
p 01 00000 00001 02E0
#
# Add r3 to the SP
p 00 00000 00001 04DA
p 01 00000 00001 244C
p 01 00000 00001 0000
#
# NOP
p 00 00000 00001 04DB
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# NOP
p 00 00000 00001 04DC
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# Copy r0 to r3; the biu address register
p 00 00000 00001 04DD
p 01 00000 00001 5CF9
p 01 00000 00001 0000
#
# Set the BIU Command fields - Jump Request
p 00 00000 00001 04DE
p 01 00000 00001 5DDF
p 01 00000 00001 0398
#
# Isolate the System Signals BIU_Done bit into Dummy
p 00 00000 00001 04DF
p 01 00000 00001 4EEF
p 01 00000 00001 0040
#
# If last_alu is zero, then Jump to restest the bit
p 00 00000 00001 04E0
p 01 00000 00001 1002
p 01 00000 00001 04DF
#
# Debounce the BIU Command fields and all prefixes
p 00 00000 00001 04E1
p 01 00000 00001 4DDF
p 01 00000 00001 0000
#
# Jump unconditional to main microcode loop
p 00 00000 00001 04E2
p 01 00000 00001 1000
p 01 00000 00001 0004
#
#
# -----------------------------------------------------
#
# 0xCA - Return - Inter-Segment and Add Immediate to Stack Pointer 
#
# -----------------------------------------------------
#
# Write 33 clocks to clock counter
p 00 00000 00001 04E6
p 01 00000 00001 5FFF
p 01 00000 00001 C063
#
# CALL WAIT_CLOCKS
p 00 00000 00001 04E7
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# CALL POP Procedure - pop the IP
p 00 00000 00001 04E8
p 01 00000 00001 1100
p 01 00000 00001 0450
#
# Copy BIU Return Data to r0 to store the biu address register temporarily
p 00 00000 00001 04E9
p 01 00000 00001 59F7
p 01 00000 00001 0000
#
# CALL POP Procedure - Pop the CS
p 00 00000 00001 04EA
p 01 00000 00001 1100
p 01 00000 00001 0450
#
# Copy BIU Return Data to biu_dataout register
p 00 00000 00001 04EB
p 01 00000 00001 5FF7
p 01 00000 00001 0000
#
# Call procedure to fetch next word from prefetch queue into r3 QS = Initial Opcode Fetch
p 00 00000 00001 04EC
p 01 00000 00001 1100
p 01 00000 00001 02E0
#
# Add r3 to the SP
p 00 00000 00001 04ED
p 01 00000 00001 244C
p 01 00000 00001 0000
#
# Strobe BIU - Set new CS Segment 
p 00 00000 00001 04EE
p 01 00000 00001 5DDF
p 01 00000 00001 3020
#
# Debounce BIU Strobe
p 00 00000 00001 04EF
p 01 00000 00001 4DDF
p 01 00000 00001 CFD3
#
# Debounce the BIU Command fields and all prefixes
p 00 00000 00001 04F0
p 01 00000 00001 4DDF
p 01 00000 00001 0000
#
# Jump unconditional to RET 0xC2 Jump Request code
p 00 00000 00001 04F1
p 01 00000 00001 1000
p 01 00000 00001 04DD
#
# -----------------------------------------------------
#
# INTERRUPT Processing
#
# Interrupt type is assumed to be in r0
#
# If the prefixes REP, REPZ, LOCK, or SEG_OVERRIDE are asserted, 
# then push the IP-1 rather than the IP.
#
# -----------------------------------------------------
#
# Write 71 clocks to clock counter
p 00 00000 00001 04F4
p 01 00000 00001 5FFF
p 01 00000 00001 C1E2
#
# CALL WAIT_CLOCKS
p 00 00000 00001 04F5
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Set biu_dataout register to Flags and set bits [15:12] to F like 8088 does.
p 00 00000 00001 04F6
p 01 00000 00001 5F8F
p 01 00000 00001 F000
#
# CALL PUSH Procedure
p 00 00000 00001 04F7
p 01 00000 00001 1100
p 01 00000 00001 0400
#
# Clear the IF and TF Flags
p 00 00000 00001 04F8
p 01 00000 00001 488F
p 01 00000 00001 FCFF
#
# Set biu_dataout register to CS
p 00 00000 00001 04F9
p 01 00000 00001 5FF2
p 01 00000 00001 0000
#
# CALL PUSH Procedure
p 00 00000 00001 04FA
p 01 00000 00001 1100
p 01 00000 00001 0400
#
# Shift r0 the the left 1 bit - r0=r0+r0
p 00 00000 00001 04FB
p 01 00000 00001 2999
p 01 00000 00001 0000
#
# Shift r0 the the left 1 bit - r0=r0+r0  This multiplies r0 * 4
p 00 00000 00001 04FC
p 01 00000 00001 2999
p 01 00000 00001 0000
#
# copy r3 <= r0+2 - Store the new CS into r3, the BIU address register
p 00 00000 00001 04FD
p 01 00000 00001 2C9F
p 01 00000 00001 0002
#
# Make BIU request to read interrupt vector word from memory
p 00 00000 00001 04FE
p 01 00000 00001 5DFF
p 01 00000 00001 0320
#
# Isolate the System Signals BIU_Done bit into Dummy
p 00 00000 00001 04FF
p 01 00000 00001 4EEF
p 01 00000 00001 0040
#
# If last_alu is zero, then Jump to restest the bit
p 00 00000 00001 0500
p 01 00000 00001 1002
p 01 00000 00001 04FF
#
# Debounce the BIU Command fields
p 00 00000 00001 0501
p 01 00000 00001 4DDF
p 01 00000 00001 4003
#
# Copy BIU Return Data to the BIU Data Out register to update the CS segment register in the BIU
p 00 00000 00001 0502
p 01 00000 00001 5FF7
p 01 00000 00001 0000
#
# Strobe BIU - Set new CS Segment Register
p 00 00000 00001 0503
p 01 00000 00001 5DDF
p 01 00000 00001 3020
#
# Debounce BIU Strobe
p 00 00000 00001 0504
p 01 00000 00001 4DDF
p 01 00000 00001 CFD3
#
# Copy IP to r1
p 00 00000 00001 0505
p 01 00000 00001 5AF8
p 01 00000 00001 0000
#
# Isolate the Flags[15:14]  REP, REPZ and LOCK bits into Dummy
p 00 00000 00001 0506
p 01 00000 00001 4E8F
p 01 00000 00001 E000
#
# If last_alu is non zero, then Jump to decrementing the IP by 1
p 00 00000 00001 0507
p 01 00000 00001 1001
p 01 00000 00001 050A
#
# Isolate the BIU Segment Override bit into Dummy
p 00 00000 00001 0508
p 01 00000 00001 4EDF
p 01 00000 00001 4000
#
# If last_alu is zero, then Jump over next instruction
p 00 00000 00001 0509
p 01 00000 00001 1002
p 01 00000 00001 050B
#
# r1 <= r1 - 1   (Copy IP-1 to r1)  ((Add FFFF))
p 00 00000 00001 050A
p 01 00000 00001 2AAF
p 01 00000 00001 FFFF
#
# Set biu_dataout register to r1
p 00 00000 00001 050B
p 01 00000 00001 5FFA
p 01 00000 00001 0000
#
# CALL PUSH Procedure - Push the current IP
p 00 00000 00001 050C
p 01 00000 00001 1100
p 01 00000 00001 0400
#
# copy r0 to r3 - Store the next IP into r3, the BIU address register
p 00 00000 00001 050D
p 01 00000 00001 5C9F
p 01 00000 00001 0000
#
# Make BIU request to read interrupt vector word from memory
p 00 00000 00001 050E
p 01 00000 00001 5DFF
p 01 00000 00001 0320
#
# Isolate the System Signals BIU_Done bit into Dummy
p 00 00000 00001 050F
p 01 00000 00001 4EEF
p 01 00000 00001 0040
#
# If last_alu is zero, then Jump to restest the bit
p 00 00000 00001 0510
p 01 00000 00001 1002
p 01 00000 00001 050F
#
# Debounce the BIU Command fields
p 00 00000 00001 0511
p 01 00000 00001 4DDF
p 01 00000 00001 4003
#
# Copy BIU Return Data to r3; the biu address register
p 00 00000 00001 0512
p 01 00000 00001 5CF7
p 01 00000 00001 0000
#
# Set the BIU Command fields - Jump Request
p 00 00000 00001 0513
p 01 00000 00001 5DDF
p 01 00000 00001 0398
#
# Isolate the System Signals BIU_Done bit into Dummy
p 00 00000 00001 0514
p 01 00000 00001 4EEF
p 01 00000 00001 0040
#
# If last_alu is zero, then Jump to restest the bit
p 00 00000 00001 0515
p 01 00000 00001 1002
p 01 00000 00001 0514
#
# Debounce the BIU Command fields
p 00 00000 00001 0516
p 01 00000 00001 4DDF
p 01 00000 00001 4003
#
# Jump unconditional to main microcode loop where prefixes will be debounced.
p 00 00000 00001 0517
p 01 00000 00001 1000
p 01 00000 00001 0004
#
#
# -----------------------------------------------------
#
# 0xCC - INT - Interrupt Type 3
#   
# -----------------------------------------------------
#
# Write 1 clock to clock counter
p 00 00000 00001 051B
p 01 00000 00001 5FFF
p 01 00000 00001 C064
#
# CALL WAIT_CLOCKS
p 00 00000 00001 051C
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Strobe BIU - Fetch Opcode and set QS[1:0] to First Byte of Opcode 
p 00 00000 00001 051D
p 01 00000 00001 5DDF
p 01 00000 00001 1004
#
# Debounce BIU Strobe
p 00 00000 00001 051E
p 01 00000 00001 4DDF
p 01 00000 00001 CFF3
#
# Set r0 to 0x3 - Interrupt Type 3 
p 00 00000 00001 051F
p 01 00000 00001 59FF
p 01 00000 00001 0003
#
# NOP
p 00 00000 00001 0520
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# Jump to INTERRUPT Processing
p 00 00000 00001 0521
p 01 00000 00001 1100
p 01 00000 00001 04F4
#
# -----------------------------------------------------
#
# 0xCF - IRET - Return from Interrupt
#
# -----------------------------------------------------
#
# Write 44 clocks to clock counter
p 00 00000 00001 0525
p 01 00000 00001 5FFF
p 01 00000 00001 C12B
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0526
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# CALL POP Procedure - pop the IP
p 00 00000 00001 0527
p 01 00000 00001 1100
p 01 00000 00001 0450
#
# Copy BIU Return Data to r2 to store the biu address register
p 00 00000 00001 0528
p 01 00000 00001 5BF7
p 01 00000 00001 0000
#
# CALL POP Procedure - Pop the CS
p 00 00000 00001 0529
p 01 00000 00001 1100
p 01 00000 00001 0450
#
# Copy BIU Return Data to biu_dataout register
p 00 00000 00001 052A
p 01 00000 00001 5FF7
p 01 00000 00001 0000
#
# Clear all BIU commands and strobes to be safe
p 00 00000 00001 052B
p 01 00000 00001 4DDF
p 01 00000 00001 0000
#
# Strobe BIU - Set new CS Segment 
p 00 00000 00001 052C
p 01 00000 00001 5DDF
p 01 00000 00001 3020
#
# Clear all BIU commands and strobes 
p 00 00000 00001 052D
p 01 00000 00001 4DDF
p 01 00000 00001 0000
#
# CALL POP Procedure - Pop the Flags
p 00 00000 00001 052E
p 01 00000 00001 1100
p 01 00000 00001 0450
#
# Copy BIU Return Data to r0
p 00 00000 00001 052F
p 01 00000 00001 59F7
p 01 00000 00001 0000
#
# Zero out any prefixes or debounce bits from r0
p 00 00000 00001 0530
p 01 00000 00001 499F
p 01 00000 00001 0FD5
#
# Zero out the Flag register
p 00 00000 00001 0531
p 01 00000 00001 488F
p 01 00000 00001 0000
#
# OR r0 into Flags register
p 00 00000 00001 0532
p 01 00000 00001 5889
p 01 00000 00001 0000
#
# Clear all prefixes and pending flags
p 00 00000 00001 0533
p 01 00000 00001 488F
p 01 00000 00001 0FD5
#
# Copy r2 to r3 to set the biu address for the IP to jump to
p 00 00000 00001 0534
p 01 00000 00001 5CFB
p 01 00000 00001 0000
#
# Set the BIU Command fields - Jump Request
p 00 00000 00001 0535
p 01 00000 00001 5DDF
p 01 00000 00001 0390
#
# Isolate the System Signals BIU_Done bit into Dummy
p 00 00000 00001 0536
p 01 00000 00001 4EEF
p 01 00000 00001 0040
#
# If last_alu is zero, then Jump to restest the bit
p 00 00000 00001 0537
p 01 00000 00001 1002
p 01 00000 00001 0536
#
# Debounce the BIU Command fields and all prefixes
p 00 00000 00001 0538
p 01 00000 00001 4DDF
p 01 00000 00001 0000
#
# Jump unconditional to common code that waits for prefetch queue, then returns to main loop skipping all interrupts.
p 00 00000 00001 0539
p 01 00000 00001 1000
p 01 00000 00001 0474
#
# -----------------------------------------------------
#
# NMI - Interrupt Type 2
#   
# -----------------------------------------------------
#
# Write 1 clock to clock counter
p 00 00000 00001 053A
p 01 00000 00001 5FFF
p 01 00000 00001 C014
#
# CALL WAIT_CLOCKS
p 00 00000 00001 053B
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Set r0 to 0x3 - Interrupt Type 2
p 00 00000 00001 053C
p 01 00000 00001 59FF
p 01 00000 00001 0002
#
# Set the Flags bits -  nmi_debounce=1
p 00 00000 00001 053D
p 01 00000 00001 588F
p 01 00000 00001 1000
#
# Set the Flags bits - nmi_debounce=0 - This tells the BIU to clear the NMI that was latched.
p 00 00000 00001 053E
p 01 00000 00001 488F
p 01 00000 00001 EFFF
#
# Jump to INTERRUPT Processing
p 00 00000 00001 053F
p 01 00000 00001 1100
p 01 00000 00001 04F4
#
#
# -----------------------------------------------------
#
# DIV0 - Interrupt Type 0
#   
# -----------------------------------------------------
#
# Write 1 clock to clock counter
p 00 00000 00001 0540
p 01 00000 00001 5FFF
p 01 00000 00001 C014
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0541
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Set r0 to 0x3 - Interrupt Type 0
p 00 00000 00001 0542
p 01 00000 00001 59FF
p 01 00000 00001 0000
#
# NOP
p 00 00000 00001 0543
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# Jump to INTERRUPT Processing
p 00 00000 00001 0544
p 01 00000 00001 1100
p 01 00000 00001 04F4
#
#
# -----------------------------------------------------
#
# TRAP (Single Step) - Interrupt Type 1 
#   
# -----------------------------------------------------
#
# Write 1 clock to clock counter
p 00 00000 00001 0545
p 01 00000 00001 5FFF
p 01 00000 00001 C014
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0546
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Set r0 to 0x3 - Interrupt Type 1
p 00 00000 00001 0547
p 01 00000 00001 59FF
p 01 00000 00001 0001
#
# Set the Flags bits -  tf_debounce=1
p 00 00000 00001 0548
p 01 00000 00001 588F
p 01 00000 00001 0020
#
# Set the Flags bits - tf_debounce=0 - This clears single step from occuring until TF flag is set again.
p 00 00000 00001 0549
p 01 00000 00001 488F
p 01 00000 00001 FFDF
#
# Jump to INTERRUPT Processing
p 00 00000 00001 054A
p 01 00000 00001 1100
p 01 00000 00001 04F4
#
# -----------------------------------------------------
#
# 0xCE - INTO (Interrupt on Overflow) - Interrupt Type 4
#   
# -----------------------------------------------------
#
# Isolate O flag into Dummy
p 00 00000 00001 054C
p 01 00000 00001 4E8F
p 01 00000 00001 0800
#
# Jump if non-zero to interrupt taken
p 00 00000 00001 054D
p 01 00000 00001 1001
p 01 00000 00001 0551
#
# Write clock count=4 to the BIU Dataout register
p 00 00000 00001 054E
p 01 00000 00001 5FFF
p 01 00000 00001 C040
#
# CALL WAIT_CLOCKS
p 00 00000 00001 054F
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Jump unconditional to NOP ending code
p 00 00000 00001 0550
p 01 00000 00001 1000
p 01 00000 00001 0045
#
# Interrupt Taken
# Write clock count=2 to the BIU Dataout register
p 00 00000 00001 0551
p 01 00000 00001 5FFF
p 01 00000 00001 C08C
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0552
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Set r0 to 0x3 - Interrupt Type 4
p 00 00000 00001 0553
p 01 00000 00001 59FF
p 01 00000 00001 0004
#
# NOP
p 00 00000 00001 0554
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# Strobe BIU - Fetch Opcode and set QS[1:0] to First Byte of Opcode 
p 00 00000 00001 0555
p 01 00000 00001 5DDF
p 01 00000 00001 1004
#
# Debounce BIU Strobe
p 00 00000 00001 0556
p 01 00000 00001 4DDF
p 01 00000 00001 CFF3
#
# Jump to INTERRUPT Processing
p 00 00000 00001 0557
p 01 00000 00001 1100
p 01 00000 00001 04F4
#
#
# -----------------------------------------------------
#
# [ 0xCD 0xnn ] - INT - Interrupt Type specified in second byte
#   
# -----------------------------------------------------
#
# Call procedure to fetch next byte from prefetch queue
p 00 00000 00001 055A
p 01 00000 00001 1100
p 01 00000 00001 02A0
#
# Copy r3 to r0 for the Interrupt Type 
p 00 00000 00001 055B
p 01 00000 00001 59CF
p 01 00000 00001 0000
#
# NOP
p 00 00000 00001 055C
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# Strobe BIU - Fetch Opcode and set QS[1:0] to Subsequent Byte of Opcode 
p 00 00000 00001 055D
p 01 00000 00001 5DDF
p 01 00000 00001 100C
#
# Debounce BIU Strobe
p 00 00000 00001 055E
p 01 00000 00001 4DDF
p 01 00000 00001 CFF3
#
# Jump to INTERRUPT Processing
p 00 00000 00001 055F
p 01 00000 00001 1100
p 01 00000 00001 04F4
#
#
# -----------------------------------------------------
#
# INTR - External Interrupt - Type fetched from i8259
#   
# -----------------------------------------------------
#
# Write 1 clock to clock counter
p 00 00000 00001 0562
p 01 00000 00001 5FFF
p 01 00000 00001 C014
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0563
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Make BIU request for INTA Cycle
p 00 00000 00001 0564
p 01 00000 00001 5DFF
p 01 00000 00001 0B60
#
# Isolate the System Signals BIU_Done bit into Dummy
p 00 00000 00001 0565
p 01 00000 00001 4EEF
p 01 00000 00001 0040
#
# If last_alu is zero, then Jump to restest the bit
p 00 00000 00001 0566
p 01 00000 00001 1002
p 01 00000 00001 0565
#
# Debounce the BIU Command fields
p 00 00000 00001 0567
p 01 00000 00001 4DDF
p 01 00000 00001 4003
#
# Copy BIU Return Data to r0 which holds the Interrupt Type byte
p 00 00000 00001 0568
p 01 00000 00001 59F7
p 01 00000 00001 0000
#
# NOP
p 00 00000 00001 0569
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# Jump to INTERRUPT Processing
p 00 00000 00001 056A
p 01 00000 00001 1100
p 01 00000 00001 04F4
#
# -----------------------------------------------------
#
# 0xD7 - XLAT - Translate
#   
# -----------------------------------------------------
#
# Write 11 clocks to clock counter
p 00 00000 00001 0570
p 01 00000 00001 5FFF
p 01 00000 00001 C0DC
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0571
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# r0 = AX AND 0x00FF
p 00 00000 00001 0572
p 01 00000 00001 490F
p 01 00000 00001 00FF
#
# r3 = BX + r0 - Address for BIU to fetch data from
p 00 00000 00001 0573
p 01 00000 00001 2C19
p 01 00000 00001 0000
#
# Set the segment to DS
p 00 00000 00001 0574
p 01 00000 00001 5DDF
p 01 00000 00001 0C00
#
# CALL MEM_BYTE_READ
p 00 00000 00001 0575
p 01 00000 00001 1100
p 01 00000 00001 0580
#
# r3 = bui_return_data
p 00 00000 00001 0576
p 01 00000 00001 5CF7
p 01 00000 00001 0000
#
# r3 = r3 AND 00FF - isolate lower byte just to be safe
p 00 00000 00001 0577
p 01 00000 00001 4CCF
p 01 00000 00001 00FF
#
# AL = AX AND FF00 - zero out AL
p 00 00000 00001 0578
p 01 00000 00001 400F
p 01 00000 00001 FF00
#
# AX = AX + r3
p 00 00000 00001 0579
p 01 00000 00001 200C
p 01 00000 00001 0000
#
# Jump unconditional to NOP ending
p 00 00000 00001 057A
p 01 00000 00001 1000
p 01 00000 00001 0040
#
# -----------------------------------------------------
#
# PROCEDURE - MEM_READ_BYTE
#
# r3 = Address for BIU to access
# User must set the segment before calling this procedure.
#
# -----------------------------------------------------
#
# BIU request a Byte Read Cycle
p 00 00000 00001 0580
p 01 00000 00001 5DDF
p 01 00000 00001 02C0
#
# Isolate the System Signals BIU_Done bit into Dummy
p 00 00000 00001 0581
p 01 00000 00001 4EEF
p 01 00000 00001 0040
#
# If last_alu is zero, then Jump to restest the bit
p 00 00000 00001 0582
p 01 00000 00001 1002
p 01 00000 00001 0581
#
# Debounce the BIU Command fields - segment is debounced here
p 00 00000 00001 0583
p 01 00000 00001 4DDF
p 01 00000 00001 4003
#
# Jump unconditional to calling address
p 00 00000 00001 0584
p 01 00000 00001 1030
p 01 00000 00001 0000
#
# -----------------------------------------------------
#
# PROCEDURE - MEM_READ_WORD
#
# r3 = Address for BIU to access
# User must set the segment before calling this procedure.
#
# -----------------------------------------------------
#
# BIU request a Word Read Cycle
p 00 00000 00001 0585
p 01 00000 00001 5DDF
p 01 00000 00001 0300
#
# Jump unconditional to common code
p 00 00000 00001 0586
p 01 00000 00001 1000
p 01 00000 00001 0581
#
# -----------------------------------------------------
#
# PROCEDURE - MEM_WRITE_BYTE
#
# r3 = Address for BIU to access
# biu_dataout = Data for BIU to write
# User must set the segment before calling this procedure.
#
# -----------------------------------------------------
#
# BIU request a Byte Write Cycle
p 00 00000 00001 0587
p 01 00000 00001 5DDF
p 01 00000 00001 02E0
#
# Jump unconditional to common code
p 00 00000 00001 0588
p 01 00000 00001 1000
p 01 00000 00001 0581
#
# -----------------------------------------------------
#
# PROCEDURE - MEM_WRITE_WORD
#
# r3 = Address for BIU to access
# biu_dataout = Data for BIU to write
# User must set the segment before calling this procedure.
#
# -----------------------------------------------------
#
# BIU request a Word Write Cycle
p 00 00000 00001 0589
p 01 00000 00001 5DDF
p 01 00000 00001 0330
#
# Jump unconditional to common code
p 00 00000 00001 058A
p 01 00000 00001 1000
p 01 00000 00001 0581
#
#
# -----------------------------------------------------
#
# 0xEC - IN - ac,DX - Variable Port - Byte
#   
# -----------------------------------------------------
#
# Write 8 clocks to clock counter
p 00 00000 00001 0590
p 01 00000 00001 5FFF
p 01 00000 00001 C08C
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0591
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# r3 = DX
p 00 00000 00001 0592
p 01 00000 00001 5C3F
p 01 00000 00001 0000
#
# Make BIU request for IO Read Byte Cycle 
p 00 00000 00001 0593
p 01 00000 00001 5DFF
p 01 00000 00001 0A80
#
# Isolate the System Signals BIU_Done bit into Dummy
p 00 00000 00001 0594
p 01 00000 00001 4EEF
p 01 00000 00001 0040
#
# If last_alu is zero, then Jump to restest the bit
p 00 00000 00001 0595
p 01 00000 00001 1002
p 01 00000 00001 0594
#
# Debounce the BIU Command fields
p 00 00000 00001 0596
p 01 00000 00001 4DDF
p 01 00000 00001 4003
#
# r3 = bui_return_data
p 00 00000 00001 0597
p 01 00000 00001 5CF7
p 01 00000 00001 0000
#
# r3 = r3 AND 00FF - isolate lower byte
p 00 00000 00001 0598
p 01 00000 00001 4CCF
p 01 00000 00001 00FF
#
# AL = AX AND FF00 - zero out AL
p 00 00000 00001 0599
p 01 00000 00001 400F
p 01 00000 00001 FF00
#
# AX = AX + r3
p 00 00000 00001 059A
p 01 00000 00001 200C
p 01 00000 00001 0000
#
# Jump unconditional to NOP ending
p 00 00000 00001 059B
p 01 00000 00001 1000
p 01 00000 00001 0040
#
#
# -----------------------------------------------------
#
# 0xED - IN - ac,DX - Variable Port - Word
#   
# -----------------------------------------------------
#
# Write 12 clocks to clock counter
p 00 00000 00001 05A0
p 01 00000 00001 5FFF
p 01 00000 00001 C08C
#
# CALL WAIT_CLOCKS
p 00 00000 00001 05A1
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# r3 = DX
p 00 00000 00001 05A2
p 01 00000 00001 5C3F
p 01 00000 00001 0000
#
# Make BIU request for IO Read Word Cycle 
p 00 00000 00001 05A3
p 01 00000 00001 5DFF
p 01 00000 00001 0BA0
#
# Isolate the System Signals BIU_Done bit into Dummy
p 00 00000 00001 05A4
p 01 00000 00001 4EEF
p 01 00000 00001 0040
#
# If last_alu is zero, then Jump to restest the bit
p 00 00000 00001 05A5
p 01 00000 00001 1002
p 01 00000 00001 05A4
#
# Debounce the BIU Command fields
p 00 00000 00001 05A6
p 01 00000 00001 4DDF
p 01 00000 00001 4003
#
# AX = bui_return_data
p 00 00000 00001 05A7
p 01 00000 00001 50F7
p 01 00000 00001 0000
#
# Jump unconditional to NOP ending
p 00 00000 00001 05A8
p 01 00000 00001 1000
p 01 00000 00001 0040
#
# -----------------------------------------------------
#
# [ 0xE4 0xpp ] - IN - ac,Opcode Port - Byte
#   
# -----------------------------------------------------
#
# Write 10 clocks to clock counter
p 00 00000 00001 05AC
p 01 00000 00001 5FFF
p 01 00000 00001 C0C8
#
# CALL WAIT_CLOCKS
p 00 00000 00001 05AD
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Call procedure to fetch next byte from prefetch queue into r3
p 00 00000 00001 05AE
p 01 00000 00001 1100
p 01 00000 00001 02A0
#
# Make BIU request for IO Read Byte Cycle 
p 00 00000 00001 05AF
p 01 00000 00001 5DFF
p 01 00000 00001 0A80
#
# Isolate the System Signals BIU_Done bit into Dummy
p 00 00000 00001 05B0
p 01 00000 00001 4EEF
p 01 00000 00001 0040
#
# If last_alu is zero, then Jump to restest the bit
p 00 00000 00001 05B1
p 01 00000 00001 1002
p 01 00000 00001 05B0
#
# Debounce the BIU Command fields
p 00 00000 00001 05B2
p 01 00000 00001 4DDF
p 01 00000 00001 4003
#
# r3 = bui_return_data
p 00 00000 00001 05B3
p 01 00000 00001 5CF7
p 01 00000 00001 0000
#
# r3 = r3 AND 00FF - isolate lower byte
p 00 00000 00001 05B4
p 01 00000 00001 4CCF
p 01 00000 00001 00FF
#
# AL = AX AND FF00 - zero out AL
p 00 00000 00001 05B5
p 01 00000 00001 400F
p 01 00000 00001 FF00
#
# AX = AX + r3
p 00 00000 00001 05B6
p 01 00000 00001 200C
p 01 00000 00001 0000
#
# Strobe BIU - Fetch Opcode and set QS[1:0] to Subsequent Byte of Opcode 
p 00 00000 00001 05B7
p 01 00000 00001 5DDF
p 01 00000 00001 100C
#
# Debounce BIU Strobe
p 00 00000 00001 05B8
p 01 00000 00001 4DDF
p 01 00000 00001 CFF3
#
# Jump unconditional to main microcode loop
p 00 00000 00001 05B9
p 01 00000 00001 1000
p 01 00000 00001 0004
#
#
# -----------------------------------------------------
#
# [ 0xE5 0xpp ] - IN - ac,Opcode Port - Word
#   
# -----------------------------------------------------
#
# Write 14 clocks to clock counter
p 00 00000 00001 05BB
p 01 00000 00001 5FFF
p 01 00000 00001 C0A0
#
# CALL WAIT_CLOCKS
p 00 00000 00001 05BC
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Call procedure to fetch next byte from prefetch queue into r3
p 00 00000 00001 05BD
p 01 00000 00001 1100
p 01 00000 00001 02A0
#
# Make BIU request for IO Read Word Cycle 
p 00 00000 00001 05BE
p 01 00000 00001 5DFF
p 01 00000 00001 0BA0
#
# Isolate the System Signals BIU_Done bit into Dummy
p 00 00000 00001 05BF
p 01 00000 00001 4EEF
p 01 00000 00001 0040
#
# If last_alu is zero, then Jump to restest the bit
p 00 00000 00001 05C0
p 01 00000 00001 1002
p 01 00000 00001 05BF
#
# Debounce the BIU Command fields
p 00 00000 00001 05C1
p 01 00000 00001 4DDF
p 01 00000 00001 4003
#
# AX = bui_return_data
p 00 00000 00001 05C2
p 01 00000 00001 50F7
p 01 00000 00001 0000
#
# Strobe BIU - Fetch Opcode and set QS[1:0] to Subsequent Byte of Opcode 
p 00 00000 00001 05C3
p 01 00000 00001 5DDF
p 01 00000 00001 100C
#
# Debounce BIU Strobe
p 00 00000 00001 05C4
p 01 00000 00001 4DDF
p 01 00000 00001 CFF3
#
# Jump unconditional to main microcode loop
p 00 00000 00001 05C5
p 01 00000 00001 1000
p 01 00000 00001 0004
#
#
# -----------------------------------------------------
#
# 0xEE - OUT - DX - Variable Port - Byte
#   
# -----------------------------------------------------
#
# Write 8 clocks to clock counter
p 00 00000 00001 05C7
p 01 00000 00001 5FFF
p 01 00000 00001 C0A0
#
# CALL WAIT_CLOCKS
p 00 00000 00001 05C8
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# r3 = DX
p 00 00000 00001 05C9
p 01 00000 00001 5C3F
p 01 00000 00001 0000
#
# biu_dataout = AX
p 00 00000 00001 05CA
p 01 00000 00001 5F0F
p 01 00000 00001 0000
#
# Make BIU request for IO Write Byte Cycle 
p 00 00000 00001 05CB
p 01 00000 00001 5DFF
p 01 00000 00001 0AA0
#
# Isolate the System Signals BIU_Done bit into Dummy
p 00 00000 00001 05CC
p 01 00000 00001 4EEF
p 01 00000 00001 0040
#
# If last_alu is zero, then Jump to restest the bit
p 00 00000 00001 05CD
p 01 00000 00001 1002
p 01 00000 00001 05CC
#
# Debounce the BIU Command fields
p 00 00000 00001 05CE
p 01 00000 00001 4DDF
p 01 00000 00001 4003
#
# Jump unconditional to NOP ending
p 00 00000 00001 05CF
p 01 00000 00001 1000
p 01 00000 00001 0040
#
#
# -----------------------------------------------------
#
# 0xEF - OUT - DX - Variable Port - Word
#   
# -----------------------------------------------------
#
# Write 12 clocks to clock counter
p 00 00000 00001 05D4
p 01 00000 00001 5FFF
p 01 00000 00001 C0F0
#
# CALL WAIT_CLOCKS
p 00 00000 00001 05D5
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# biu_dataout = AX
p 00 00000 00001 05D6
p 01 00000 00001 5F0F
p 01 00000 00001 0000
#
# r3 = DX
p 00 00000 00001 05D7
p 01 00000 00001 5C3F
p 01 00000 00001 0000
#
# Make BIU request for IO Write Word Cycle 
p 00 00000 00001 05D8
p 01 00000 00001 5DFF
p 01 00000 00001 0BC0
#
# Jump unconditional to common code above
p 00 00000 00001 05D9
p 01 00000 00001 1000
p 01 00000 00001 05CC
#
#
# -----------------------------------------------------
#
# [ 0xE6 0xpp ] - OUT - Opcode Port - Byte
#   
# -----------------------------------------------------
#
# Write 10 clocks to clock counter
p 00 00000 00001 05DD
p 01 00000 00001 5FFF
p 01 00000 00001 C0B6
#
# CALL WAIT_CLOCKS
p 00 00000 00001 05DE
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# biu_dataout = AX
p 00 00000 00001 05DF
p 01 00000 00001 5F0F
p 01 00000 00001 0000
#
# Call procedure to fetch next byte from prefetch queue into r3
p 00 00000 00001 05E0
p 01 00000 00001 1100
p 01 00000 00001 02A0
#
# Make BIU request for IO Write Byte Cycle 
p 00 00000 00001 05E1
p 01 00000 00001 5DFF
p 01 00000 00001 0AA0
#
# Isolate the System Signals BIU_Done bit into Dummy
p 00 00000 00001 05E2
p 01 00000 00001 4EEF
p 01 00000 00001 0040
#
# If last_alu is zero, then Jump to restest the bit
p 00 00000 00001 05E3
p 01 00000 00001 1002
p 01 00000 00001 05E2
#
# Debounce the BIU Command fields
p 00 00000 00001 05E4
p 01 00000 00001 4DDF
p 01 00000 00001 4003
#
# Strobe BIU - Fetch Opcode and set QS[1:0] to Subsequent Byte of Opcode 
p 00 00000 00001 05E5
p 01 00000 00001 5DDF
p 01 00000 00001 100C
#
# Debounce BIU Strobe
p 00 00000 00001 05E6
p 01 00000 00001 4DDF
p 01 00000 00001 CFF3
#
# Jump unconditional to main microcode loop
p 00 00000 00001 05E7
p 01 00000 00001 1000
p 01 00000 00001 0004
#
#
# -----------------------------------------------------
#
# [ 0xE7 0xpp ] - OUT - Opcode Port - Word
#   
# -----------------------------------------------------
#
# Write 14 clocks to clock counter
p 00 00000 00001 05E9
p 01 00000 00001 5FFF
p 01 00000 00001 C108
#
# CALL WAIT_CLOCKS
p 00 00000 00001 05EA
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# biu_dataout = AX
p 00 00000 00001 05EB
p 01 00000 00001 5F0F
p 01 00000 00001 0000
#
# Call procedure to fetch next byte from prefetch queue into r3
p 00 00000 00001 05EC
p 01 00000 00001 1100
p 01 00000 00001 02A0
#
# Make BIU request for IO Write Word Cycle 
p 00 00000 00001 05ED
p 01 00000 00001 5DFF
p 01 00000 00001 0BC0
#
# Jump unconditional to common code above
p 00 00000 00001 05EE
p 01 00000 00001 1000
p 01 00000 00001 05E2
#
#
# -----------------------------------------------------
#
# 0xA4 - MOVSB - Move String - Byte
#   
# -----------------------------------------------------
#
# Isolate the REP bits into Dummy
p 00 00000 00001 05F0
p 01 00000 00001 4E8F
p 01 00000 00001 C000
#
# If last_alu is zero, then REPZ not asserted, so jump over the following code to START:
p 00 00000 00001 05F1
p 01 00000 00001 1002
p 01 00000 00001 05F9
#
# Dummy = CX
p 00 00000 00001 05F2
p 01 00000 00001 5E2F
p 01 00000 00001 0000
#
# If last_alu is zero, then CX=0, jump to CX_IS_ZERO:
p 00 00000 00001 05F3
p 01 00000 00001 1002
p 01 00000 00001 05F6
#
# CX = CX - 1 (( Add 0xFFFF ))
p 00 00000 00001 05F4
p 01 00000 00001 222F
p 01 00000 00001 FFFF
#
# Jump unconditional to START: 
p 00 00000 00001 05F5
p 01 00000 00001 1000
p 01 00000 00001 05F9
#
# CX_IS_ZERO
# ----------
# Write 9 clocks to clock counter
p 00 00000 00001 05F6
p 01 00000 00001 5FFF
p 01 00000 00001 C0B4
#
# CALL WAIT_CLOCKS
p 00 00000 00001 05F7
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Jump unconditional to NOP ending
p 00 00000 00001 05F8
p 01 00000 00001 1000
p 01 00000 00001 0040
#
# START
# ----------
# Write 17 clocks to clock counter
p 00 00000 00001 05F9
p 01 00000 00001 5FFF
p 01 00000 00001 C080
#
# CALL WAIT_CLOCKS
p 00 00000 00001 05FA
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Set the segment to DS  (Can be overridden)
p 00 00000 00001 05FB
p 01 00000 00001 5DDF
p 01 00000 00001 0C00
#
# r3 = SI
p 00 00000 00001 05FC
p 01 00000 00001 5C6F
p 01 00000 00001 0000
#
# CALL MEM_READ_BYTE
p 00 00000 00001 05FD
p 01 00000 00001 1100
p 01 00000 00001 0580
#
# CALL STORE_SEG_PREFIX to store and zero the Segment override flag so the next BIU access to the ES cannot be overridden
p 00 00000 00001 05FE
p 01 00000 00001 1100
p 01 00000 00001 0750
#
# Debounce the BIU Command fields - Set the segment to ES=00  (Can *NOT* be overridden)
p 00 00000 00001 05FF
p 01 00000 00001 4DDF
p 01 00000 00001 0003
#
# r3 = DI
p 00 00000 00001 0600
p 01 00000 00001 5C7F
p 01 00000 00001 0000
#
# biu_dataout = biu_return_data
p 00 00000 00001 0601
p 01 00000 00001 5FF7
p 01 00000 00001 0000
#
# CALL MEM_WRITE_BYTE
p 00 00000 00001 0602
p 01 00000 00001 1100
p 01 00000 00001 0587
#
# CALL RESTORE_SEG_PREFIX to put the Segment override flag back to its original value
p 00 00000 00001 0603
p 01 00000 00001 1100
p 01 00000 00001 075A
#
# Isolate the direction flag bit into Dummy
p 00 00000 00001 0604
p 01 00000 00001 4E8F
p 01 00000 00001 0400
#
# If last_alu is non-zero, jump to DECREMENT_POINTERS:
p 00 00000 00001 0605
p 01 00000 00001 1001
p 01 00000 00001 0609
#
# SI = SI + 1
p 00 00000 00001 0606
p 01 00000 00001 266F
p 01 00000 00001 0001
#
# DI = DI + 1
p 00 00000 00001 0607
p 01 00000 00001 277F
p 01 00000 00001 0001
#
# Jump unconditional to REP_END:
p 00 00000 00001 0608
p 01 00000 00001 1000
p 01 00000 00001 060B
#
# DECREMENT_POINTERS:
# SI = SI - 1
p 00 00000 00001 0609
p 01 00000 00001 266F
p 01 00000 00001 FFFF
#
# DI = DI - 1
p 00 00000 00001 060A
p 01 00000 00001 277F
p 01 00000 00001 FFFF
#
# REP_END:
# Isolate the REP bits into Dummy
p 00 00000 00001 060B
p 01 00000 00001 4E8F
p 01 00000 00001 C000
#
# If last_alu is non-zero, then REP is asserted, so jump to main microcode loop to re-run this instruction, but poll for interrupts first
p 00 00000 00001 060C
p 01 00000 00001 1001
p 01 00000 00001 0006
#
# Write 1 clocks to clock counter to equal 18 clocks for this instruction
p 00 00000 00001 060D
p 01 00000 00001 5FFF
p 01 00000 00001 C014
#
# CALL WAIT_CLOCKS
p 00 00000 00001 060E
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Jump unconditional to NOP ending
p 00 00000 00001 060F
p 01 00000 00001 1000
p 01 00000 00001 0040
#
#
# -----------------------------------------------------
#
# 0xA5 - MOVSW - Move String - Word
#   
# -----------------------------------------------------
#
# Isolate the REP bits into Dummy
p 00 00000 00001 0614
p 01 00000 00001 4E8F
p 01 00000 00001 C000
#
# If last_alu is zero, then REP not asserted, so jump over the following code to START:
p 00 00000 00001 0615
p 01 00000 00001 1002
p 01 00000 00001 061D
#
# Dummy = CX
p 00 00000 00001 0616
p 01 00000 00001 5E2F
p 01 00000 00001 0000
#
# If last_alu is zero, then CX=0, jump to CX_IS_ZERO:
p 00 00000 00001 0617
p 01 00000 00001 1002
p 01 00000 00001 061A
#
# CX = CX - 1 (( Add 0xFFFF ))
p 00 00000 00001 0618
p 01 00000 00001 222F
p 01 00000 00001 FFFF
#
# Jump unconditional to START: 
p 00 00000 00001 0619
p 01 00000 00001 1000
p 01 00000 00001 061D
#
# CX_IS_ZERO
# ----------
# Write 9 clocks to clock counter
p 00 00000 00001 061A
p 01 00000 00001 5FFF
p 01 00000 00001 C0B4
#
# CALL WAIT_CLOCKS
p 00 00000 00001 061B
p 01 00000 00001 1100
p 01 00000 00001 03DC
#
# Jump unconditional to NOP ending
p 00 00000 00001 061C
p 01 00000 00001 1000
p 01 00000 00001 0040
#
# START
# ----------
# Write 25 clocks to clock counter
p 00 00000 00001 061D
p 01 00000 00001 5FFF
p 01 00000 00001 C070
#
# CALL WAIT_CLOCKS
p 00 00000 00001 061E
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Set the segment to DS  (Can be overridden)
p 00 00000 00001 061F
p 01 00000 00001 5DDF
p 01 00000 00001 0C00
#
# r3 = SI
p 00 00000 00001 0620
p 01 00000 00001 5C6F
p 01 00000 00001 0000
#
# CALL MEM_READ_WORD
p 00 00000 00001 0621
p 01 00000 00001 1100
p 01 00000 00001 0585
#
# CALL STORE_SEG_PREFIX to store and zero the Segment override flag so the next BIU access to the ES cannot be overridden
p 00 00000 00001 0622
p 01 00000 00001 1100
p 01 00000 00001 0750
#
# Debounce the BIU Command fields - Set the segment to ES=00  (Can *NOT* be overridden)
p 00 00000 00001 0623
p 01 00000 00001 4DDF
p 01 00000 00001 0003
#
# r3 = DI
p 00 00000 00001 0624
p 01 00000 00001 5C7F
p 01 00000 00001 0000
#
# biu_dataout = biu_return_data
p 00 00000 00001 0625
p 01 00000 00001 5FF7
p 01 00000 00001 0000
#
# CALL MEM_WRITE_WORD
p 00 00000 00001 0626
p 01 00000 00001 1100
p 01 00000 00001 0589
#
# CALL RESTORE_SEG_PREFIX to put the Segment override flag back to its original value
p 00 00000 00001 0627
p 01 00000 00001 1100
p 01 00000 00001 075A
#
# Isolate the direction flag bit into Dummy
p 00 00000 00001 0628
p 01 00000 00001 4E8F
p 01 00000 00001 0400
#
# If last_alu is non-zero, jump to DECREMENT_POINTERS:
p 00 00000 00001 0629
p 01 00000 00001 1001
p 01 00000 00001 062D
#
# SI = SI + 2
p 00 00000 00001 062A
p 01 00000 00001 266F
p 01 00000 00001 0002
#
# DI = DI + 2
p 00 00000 00001 062B
p 01 00000 00001 277F
p 01 00000 00001 0002
#
# Jump unconditional to REP_END:
p 00 00000 00001 062C
p 01 00000 00001 1000
p 01 00000 00001 062F
#
# DECREMENT_POINTERS:
# SI = SI - 2
p 00 00000 00001 062D
p 01 00000 00001 266F
p 01 00000 00001 FFFE
#
# DI = DI - 2
p 00 00000 00001 062E
p 01 00000 00001 277F
p 01 00000 00001 FFFE
#
# REP_END:
# Isolate the REP bits into Dummy
p 00 00000 00001 062F
p 01 00000 00001 4E8F
p 01 00000 00001 C000
#
# If last_alu is non-zero, then REP is asserted, so jump to main microcode loop to re-run this instruction, but poll for interrupts first
p 00 00000 00001 0630
p 01 00000 00001 1001
p 01 00000 00001 0006
#
# Write 1 clocks to clock counter to equal 18 clocks for this instruction
p 00 00000 00001 0631
p 01 00000 00001 5FFF
p 01 00000 00001 C014
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0632
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Jump unconditional to NOP ending
p 00 00000 00001 0633
p 01 00000 00001 1000
p 01 00000 00001 0040
#
#
# -----------------------------------------------------
#
# 0xA6 - CMPSB - Compare String - Byte
#   
# -----------------------------------------------------
#
# Isolate the REPZ and REPNZ bits into Dummy
p 00 00000 00001 0637
p 01 00000 00001 4E8F
p 01 00000 00001 C000
#
# If last_alu is zero, then REPEAT Flags not asserted, so jump over the following code to START:
p 00 00000 00001 0638  
p 01 00000 00001 1002
p 01 00000 00001 0640
#
# Dummy = CX
p 00 00000 00001 0639
p 01 00000 00001 5E2F
p 01 00000 00001 0000
#
# If last_alu is zero, then CX=0, jump to CX_IS_ZERO:
p 00 00000 00001 063A
p 01 00000 00001 1002
p 01 00000 00001 063D
#
# CX = CX - 1 (( Add 0xFFFF ))
p 00 00000 00001 063B
p 01 00000 00001 222F
p 01 00000 00001 FFFF
#
# Jump unconditional to START: 
p 00 00000 00001 063C
p 01 00000 00001 1000
p 01 00000 00001 0640
#
# CX_IS_ZERO
# ----------
# Write 9 clocks to clock counter
p 00 00000 00001 063D
p 01 00000 00001 5FFF
p 01 00000 00001 C0B4
#
# CALL WAIT_CLOCKS
p 00 00000 00001 063E
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Jump unconditional to NOP ending
p 00 00000 00001 063F
p 01 00000 00001 1000
p 01 00000 00001 0040
#
# START
# ----------
# Write 21 clocks to clock counter
p 00 00000 00001 0640
p 01 00000 00001 5FFF
p 01 00000 00001 C0B8
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0641
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Set the segment to DS  (Can be overridden)
p 00 00000 00001 0642
p 01 00000 00001 5DDF
p 01 00000 00001 0C00
#
# r3 = SI
p 00 00000 00001 0643
p 01 00000 00001 5C6F
p 01 00000 00001 0000
#
# CALL MEM_READ_BYTE
p 00 00000 00001 0644
p 01 00000 00001 1100
p 01 00000 00001 0580
#
# r0 = biu_return_data
p 00 00000 00001 0645
p 01 00000 00001 59F7
p 01 00000 00001 0000
#
# CALL STORE_SEG_PREFIX to store and zero the Segment override flag so the next BIU access to the ES cannot be overridden
p 00 00000 00001 0646
p 01 00000 00001 1100
p 01 00000 00001 0750
#
# Debounce the BIU Command fields - Set the segment to ES=00  (Can *NOT* be overridden)
p 00 00000 00001 0647
p 01 00000 00001 4DDF
p 01 00000 00001 0003
#
# r3 = DI
p 00 00000 00001 0648
p 01 00000 00001 5C7F
p 01 00000 00001 0000
#
# CALL MEM_READ_BYTE
p 00 00000 00001 0649
p 01 00000 00001 1100
p 01 00000 00001 0580
#
# CALL RESTORE_SEG_PREFIX to put the Segment override flag back to its original value
p 00 00000 00001 064A
p 01 00000 00001 1100
p 01 00000 00001 075A
#
# r1 = biu_return_data
p 00 00000 00001 064B
p 01 00000 00001 5AF7
p 01 00000 00001 0000
#
# CALL SUB_BYTE which calculates flags
p 00 00000 00001 064C
p 01 00000 00001 1100
p 01 00000 00001 0A46
#
# NOP
p 00 00000 00001 064D
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# NOP
p 00 00000 00001 064E
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# NOP
p 00 00000 00001 064F
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# NOP
p 00 00000 00001 0650
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# Isolate the direction flag bit into Dummy
p 00 00000 00001 0651
p 01 00000 00001 4E8F
p 01 00000 00001 0400
#
# If last_alu is non-zero, jump to DECREMENT_POINTERS:
p 00 00000 00001 0652
p 01 00000 00001 1001
p 01 00000 00001 0656
#
# SI = SI + 1
p 00 00000 00001 0653
p 01 00000 00001 266F
p 01 00000 00001 0001
#
# DI = DI + 1
p 00 00000 00001 0654
p 01 00000 00001 277F
p 01 00000 00001 0001
#
# Jump unconditional to REP_END:
p 00 00000 00001 0655
p 01 00000 00001 1000
p 01 00000 00001 0658
#
# DECREMENT_POINTERS:
# SI = SI - 1
p 00 00000 00001 0656
p 01 00000 00001 266F
p 01 00000 00001 FFFF
#
# DI = DI - 1
p 00 00000 00001 0657
p 01 00000 00001 277F
p 01 00000 00001 FFFF
#
# REP_END:
# Isolate the REPZ and REPNZ bits into Dummy
p 00 00000 00001 0658
p 01 00000 00001 4E8F
p 01 00000 00001 C000
#
# If last_alu is non-zero, then a REPEAT Flag is asserted, so jump to common REPEAT processing code.
p 00 00000 00001 0659
p 01 00000 00001 1001
p 01 00000 00001 0740
#
# Jump unconditional to NOP ending
p 00 00000 00001 065A
p 01 00000 00001 1000
p 01 00000 00001 0040
#
#
# -----------------------------------------------------
#
# 0xA7 - CMPSW - Compare String - Word
#   
# -----------------------------------------------------
#
# Isolate the REPZ and REPNZ bits into Dummy
p 00 00000 00001 0660
p 01 00000 00001 4E8F
p 01 00000 00001 C000
#
# If last_alu is zero, then REPEAT Flags not asserted, so jump over the following code to START:
p 00 00000 00001 0661
p 01 00000 00001 1002
p 01 00000 00001 0669
#
# Dummy = CX
p 00 00000 00001 0662
p 01 00000 00001 5E2F
p 01 00000 00001 0000
#
# If last_alu is zero, then CX=0, jump to CX_IS_ZERO:
p 00 00000 00001 0663
p 01 00000 00001 1002
p 01 00000 00001 0666
#
# CX = CX - 1 (( Add 0xFFFF ))
p 00 00000 00001 0664
p 01 00000 00001 222F
p 01 00000 00001 FFFF
#
# Jump unconditional to START: 
p 00 00000 00001 0665
p 01 00000 00001 1000
p 01 00000 00001 0669
#
# CX_IS_ZERO
# ----------
# Write 9 clocks to clock counter
p 00 00000 00001 0666
p 01 00000 00001 5FFF
p 01 00000 00001 C0B4
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0667
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Jump unconditional to NOP ending
p 00 00000 00001 0668
p 01 00000 00001 1000
p 01 00000 00001 0040
#
# START
# ----------
# Write 22 clocks to clock counter
p 00 00000 00001 0669
p 01 00000 00001 5FFF
p 01 00000 00001 C0B8
#
# CALL WAIT_CLOCKS
p 00 00000 00001 066A
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Set the segment to DS  (Can be overridden)
p 00 00000 00001 066B
p 01 00000 00001 5DDF
p 01 00000 00001 0C00
#
# r3 = SI
p 00 00000 00001 066C
p 01 00000 00001 5C6F
p 01 00000 00001 0000
#
# CALL MEM_READ_WORD
p 00 00000 00001 066D
p 01 00000 00001 1100
p 01 00000 00001 0585
#
# r0 = biu_return_data
p 00 00000 00001 066E
p 01 00000 00001 59F7
p 01 00000 00001 0000
#
# CALL STORE_SEG_PREFIX to store and zero the Segment override flag so the next BIU access to the ES cannot be overridden
p 00 00000 00001 066F
p 01 00000 00001 1100
p 01 00000 00001 0750
#
# Debounce the BIU Command fields - Set the segment to ES=00  (Can *NOT* be overridden)
p 00 00000 00001 0670
p 01 00000 00001 4DDF
p 01 00000 00001 0003
#
# r3 = DI
p 00 00000 00001 0671
p 01 00000 00001 5C7F
p 01 00000 00001 0000
#
# CALL MEM_READ_WORD
p 00 00000 00001 0672
p 01 00000 00001 1100
p 01 00000 00001 0585
#
# CALL RESTORE_SEG_PREFIX to put the Segment override flag back to its original value
p 00 00000 00001 0673
p 01 00000 00001 1100
p 01 00000 00001 075A
#
# r1 = biu_return_data
p 00 00000 00001 0674
p 01 00000 00001 5AF7
p 01 00000 00001 0000
#
# CALL SUB_WORD which calculates flags
p 00 00000 00001 0675
p 01 00000 00001 1100
p 01 00000 00001 0A52
#
# NOP
p 00 00000 00001 0676
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# NOP
p 00 00000 00001 0677
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# NOP
p 00 00000 00001 0678
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# NOP
p 00 00000 00001 0679
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# Isolate the direction flag bit into Dummy
p 00 00000 00001 067A
p 01 00000 00001 4E8F
p 01 00000 00001 0400
#
# If last_alu is non-zero, jump to DECREMENT_POINTERS:
p 00 00000 00001 067B
p 01 00000 00001 1001
p 01 00000 00001 067F
#
# SI = SI + 2
p 00 00000 00001 067C
p 01 00000 00001 266F
p 01 00000 00001 0002
#
# DI = DI + 2
p 00 00000 00001 067D
p 01 00000 00001 277F
p 01 00000 00001 0002
#
# Jump unconditional to REP_END:
p 00 00000 00001 067E
p 01 00000 00001 1000
p 01 00000 00001 0681
#
# DECREMENT_POINTERS:
# SI = SI - 2
p 00 00000 00001 067F
p 01 00000 00001 266F
p 01 00000 00001 FFFE
#
# DI = DI - 2
p 00 00000 00001 0680
p 01 00000 00001 277F
p 01 00000 00001 FFFE
#
# REP_END:
# Isolate the REPZ and REPNZ bits into Dummy
p 00 00000 00001 0681
p 01 00000 00001 4E8F
p 01 00000 00001 C000
#
# If last_alu is non-zero, then a REPEAT Flag is asserted, so jump to common REPEAT processing code.
p 00 00000 00001 0682
p 01 00000 00001 1001
p 01 00000 00001 0740
#
# Jump unconditional to NOP ending
p 00 00000 00001 0683
p 01 00000 00001 1000
p 01 00000 00001 0040
#
#
# -----------------------------------------------------
#
# 0xAE - SCASB - Scan String - Byte
#   
# -----------------------------------------------------
#
# Isolate the REPZ and REPNZ bits into Dummy
p 00 00000 00001 0686
p 01 00000 00001 4E8F
p 01 00000 00001 C000
#
# If last_alu is zero, then REPEAT Flags not asserted, so jump over the following code to START:
p 00 00000 00001 0687
p 01 00000 00001 1002
p 01 00000 00001 068F
#
# Dummy = CX
p 00 00000 00001 0688
p 01 00000 00001 5E2F
p 01 00000 00001 0000
#
# If last_alu is zero, then CX=0, jump to CX_IS_ZERO:
p 00 00000 00001 0689
p 01 00000 00001 1002
p 01 00000 00001 068C
#
# CX = CX - 1 (( Add 0xFFFF ))
p 00 00000 00001 068A
p 01 00000 00001 222F
p 01 00000 00001 FFFF
#
# Jump unconditional to START: 
p 00 00000 00001 068B
p 01 00000 00001 1000
p 01 00000 00001 068F
#
# CX_IS_ZERO
# ----------
# Write 9 clocks to clock counter
p 00 00000 00001 068C
p 01 00000 00001 5FFF
p 01 00000 00001 C0B4
#
# CALL WAIT_CLOCKS
p 00 00000 00001 068D
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Jump unconditional to NOP ending
p 00 00000 00001 068E
p 01 00000 00001 1000
p 01 00000 00001 0040
#
# START
# ----------
# Write 15 clocks to clock counter
p 00 00000 00001 068F
p 01 00000 00001 5FFF
p 01 00000 00001 C091
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0690
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Debounce the BIU Command fields - Set the segment to ES=00  (Can *NOT* be overridden)
p 00 00000 00001 0691
p 01 00000 00001 4DDF
p 01 00000 00001 0003
#
# r3 = DI
p 00 00000 00001 0692
p 01 00000 00001 5C7F
p 01 00000 00001 0000
#
# CALL MEM_READ_BYTE
p 00 00000 00001 0693
p 01 00000 00001 1100
p 01 00000 00001 0580
#
# r1 = biu_return_data
p 00 00000 00001 0694
p 01 00000 00001 5AF7
p 01 00000 00001 0000
#
# r0 = AX AND 00FF - Isolate AL
p 00 00000 00001 0695
p 01 00000 00001 490F
p 01 00000 00001 00FF
#
# CALL SUB_BYTE which calculates flags
p 00 00000 00001 0696
p 01 00000 00001 1100
p 01 00000 00001 0A46
#
# NOP
p 00 00000 00001 0697
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# NOP
p 00 00000 00001 0698
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# NOP
p 00 00000 00001 0699
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# NOP
p 00 00000 00001 069A
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# Isolate the direction flag bit into Dummy
p 00 00000 00001 069B
p 01 00000 00001 4E8F
p 01 00000 00001 0400
#
# If last_alu is non-zero, jump to DECREMENT_POINTERS:
p 00 00000 00001 069C
p 01 00000 00001 1001
p 01 00000 00001 069F
#
# DI = DI + 1
p 00 00000 00001 069D
p 01 00000 00001 277F
p 01 00000 00001 0001
#
# Jump unconditional to REP_END:
p 00 00000 00001 069E
p 01 00000 00001 1000
p 01 00000 00001 06A0
#
# DECREMENT_POINTERS:
# DI = DI - 1
p 00 00000 00001 069F
p 01 00000 00001 277F
p 01 00000 00001 FFFF
#
# REP_END:
# Isolate the REPZ and REPNZ bits into Dummy
p 00 00000 00001 06A0
p 01 00000 00001 4E8F
p 01 00000 00001 C000
#
# If last_alu is non-zero, then a REPEAT Flag is asserted, so jump to common REPEAT processing code.
p 00 00000 00001 06A1
p 01 00000 00001 1001
p 01 00000 00001 0740
#
# Jump unconditional to NOP ending
p 00 00000 00001 06A2
p 01 00000 00001 1000
p 01 00000 00001 0040
#
#
# -----------------------------------------------------
#
# 0xAF - SCASW - Scan String - Word
#   
# -----------------------------------------------------
#
# Isolate the REPZ and REPNZ bits into Dummy
p 00 00000 00001 06A8
p 01 00000 00001 4E8F
p 01 00000 00001 C000
#
# If last_alu is zero, then REPEAT Flags not asserted, so jump over the following code to START:
p 00 00000 00001 06A9
p 01 00000 00001 1002
p 01 00000 00001 06B1
#
# Dummy = CX
p 00 00000 00001 06AA
p 01 00000 00001 5E2F
p 01 00000 00001 0000
#
# If last_alu is zero, then CX=0, jump to CX_IS_ZERO:
p 00 00000 00001 06AB
p 01 00000 00001 1002
p 01 00000 00001 06AE
#
# CX = CX - 1 (( Add 0xFFFF ))
p 00 00000 00001 06AC
p 01 00000 00001 222F
p 01 00000 00001 FFFF
#
# Jump unconditional to START: 
p 00 00000 00001 06AD
p 01 00000 00001 1000
p 01 00000 00001 06B1
#
# CX_IS_ZERO
# ----------
# Write 9 clocks to clock counter
p 00 00000 00001 06AE
p 01 00000 00001 5FFF
p 01 00000 00001 C0B4
#
# CALL WAIT_CLOCKS
p 00 00000 00001 06AF
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Jump unconditional to NOP ending
p 00 00000 00001 06B0
p 01 00000 00001 1000
p 01 00000 00001 0040
#
# START
# ----------
# Write 19 clocks to clock counter
p 00 00000 00001 06B1
p 01 00000 00001 5FFF
p 01 00000 00001 C091
#
# CALL WAIT_CLOCKS
p 00 00000 00001 06B2
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Debounce the BIU Command fields - Set the segment to ES=00  (Can *NOT* be overridden)
p 00 00000 00001 06B3
p 01 00000 00001 4DDF
p 01 00000 00001 0003
#
# r3 = DI
p 00 00000 00001 06B4
p 01 00000 00001 5C7F
p 01 00000 00001 0000
#
# CALL MEM_READ_WORD
p 00 00000 00001 06B5
p 01 00000 00001 1100
p 01 00000 00001 0585
#
# r1 = biu_return_data
p 00 00000 00001 06B6
p 01 00000 00001 5AF7
p 01 00000 00001 0000
#
# r0 = AX 
p 00 00000 00001 06B7
p 01 00000 00001 590F
p 01 00000 00001 0000
#
# CALL SUB_WORD which calculates flags
p 00 00000 00001 06B8
p 01 00000 00001 1100
p 01 00000 00001 0A52
#
# NOP
p 00 00000 00001 06B9
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# NOP
p 00 00000 00001 06BA
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# NOP
p 00 00000 00001 06BB
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# Isolate the direction flag bit into Dummy
p 00 00000 00001 06BC
p 01 00000 00001 4E8F
p 01 00000 00001 0400
#
# If last_alu is non-zero, jump to DECREMENT_POINTERS:
p 00 00000 00001 06BD
p 01 00000 00001 1001
p 01 00000 00001 06C0
#
# DI = DI + 2
p 00 00000 00001 06BE
p 01 00000 00001 277F
p 01 00000 00001 0002
#
# Jump unconditional to REP_END:
p 00 00000 00001 06BF
p 01 00000 00001 1000
p 01 00000 00001 06C1
#
# DECREMENT_POINTERS:
# DI = DI - 2
p 00 00000 00001 06C0
p 01 00000 00001 277F
p 01 00000 00001 FFFE
#
# REP_END:
# Isolate the REPZ and REPNZ bits into Dummy
p 00 00000 00001 06C1
p 01 00000 00001 4E8F
p 01 00000 00001 C000
#
# If last_alu is non-zero, then a REPEAT Flag is asserted, so jump to common REPEAT processing code.
p 00 00000 00001 06C2
p 01 00000 00001 1001
p 01 00000 00001 0740
#
# Jump unconditional to NOP ending
p 00 00000 00001 06C3
p 01 00000 00001 1000
p 01 00000 00001 0040
#
#
# -----------------------------------------------------
#
# 0xAC - LODSB - Load String into AL - Byte
#   
# -----------------------------------------------------
#
# Isolate the REP bits into Dummy
p 00 00000 00001 06C6
p 01 00000 00001 4E8F
p 01 00000 00001 C000
#
# If last_alu is zero, then REP not asserted, so jump over the following code to START:
p 00 00000 00001 06C7
p 01 00000 00001 1002
p 01 00000 00001 06CF
#
# Dummy = CX
p 00 00000 00001 06C8
p 01 00000 00001 5E2F
p 01 00000 00001 0000
#
# If last_alu is zero, then CX=0, jump to CX_IS_ZERO:
p 00 00000 00001 06C9
p 01 00000 00001 1002
p 01 00000 00001 06CC
#
# CX = CX - 1 (( Add 0xFFFF ))
p 00 00000 00001 06CA
p 01 00000 00001 222F
p 01 00000 00001 FFFF
#
# Jump unconditional to START: 
p 00 00000 00001 06CB
p 01 00000 00001 1000
p 01 00000 00001 06CF
#
# CX_IS_ZERO
# ----------
# Write 9 clocks to clock counter
p 00 00000 00001 06CC
p 01 00000 00001 5FFF
p 01 00000 00001 C0B4
#
# CALL WAIT_CLOCKS
p 00 00000 00001 06CD
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Jump unconditional to NOP ending
p 00 00000 00001 06CE
p 01 00000 00001 1000
p 01 00000 00001 0040
#
# START
# ----------
# Write 12 clocks to clock counter
p 00 00000 00001 06CF
p 01 00000 00001 5FFF
p 01 00000 00001 C091
#
# CALL WAIT_CLOCKS
p 00 00000 00001 06D0
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Set the segment to DS  (Can be overridden)
p 00 00000 00001 06D1
p 01 00000 00001 5DDF
p 01 00000 00001 0C00
#
# r3 = SI
p 00 00000 00001 06D2
p 01 00000 00001 5C6F
p 01 00000 00001 0000
#
# CALL MEM_READ_BYTE
p 00 00000 00001 06D3
p 01 00000 00001 1100
p 01 00000 00001 0580
#
# zero out AL
p 00 00000 00001 06D4
p 01 00000 00001 400F
p 01 00000 00001 FF00
#
# AX = AH OR biu_return_data
p 00 00000 00001 06D5
p 01 00000 00001 5007
p 01 00000 00001 0000
#
# Isolate the direction flag bit into Dummy
p 00 00000 00001 06D6
p 01 00000 00001 4E8F
p 01 00000 00001 0400
#
# If last_alu is non-zero, jump to DECREMENT_POINTERS:
p 00 00000 00001 06D7
p 01 00000 00001 1001
p 01 00000 00001 06DA
#
# SI = SI + 1
p 00 00000 00001 06D8
p 01 00000 00001 266F
p 01 00000 00001 0001
#
# Jump unconditional to REP_END:
p 00 00000 00001 06D9
p 01 00000 00001 1000
p 01 00000 00001 06DB
#
# DECREMENT_POINTERS:
# SI = SI - 1
p 00 00000 00001 06DA
p 01 00000 00001 266F
p 01 00000 00001 FFFF
#
# REP_END:
# Isolate the REP bits into Dummy
p 00 00000 00001 06DB
p 01 00000 00001 4E8F
p 01 00000 00001 C000
#
# If last_alu is non-zero, then REP is asserted, so jump to main microcode loop to re-run this instruction, but poll for interrupts first
p 00 00000 00001 06DC
p 01 00000 00001 1001
p 01 00000 00001 0006
#
# Write 1 clocks to clock counter to equal 13 clocks for this instruction
p 00 00000 00001 06DD
p 01 00000 00001 5FFF
p 01 00000 00001 C014
#
# CALL WAIT_CLOCKS
p 00 00000 00001 06DE
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Jump unconditional to NOP ending
p 00 00000 00001 06DF
p 01 00000 00001 1000
p 01 00000 00001 0040
#
#
# -----------------------------------------------------
#
# 0xAD - LODSW - Load String into AX - Word
#   
# -----------------------------------------------------
#
# Isolate the REP bits into Dummy
p 00 00000 00001 06E4
p 01 00000 00001 4E8F
p 01 00000 00001 C000
#
# If last_alu is zero, then REP not asserted, so jump over the following code to START:
p 00 00000 00001 06E5
p 01 00000 00001 1002
p 01 00000 00001 06ED
#
# Dummy = CX
p 00 00000 00001 06E6
p 01 00000 00001 5E2F
p 01 00000 00001 0000
#
# If last_alu is zero, then CX=0, jump to CX_IS_ZERO:
p 00 00000 00001 06E7
p 01 00000 00001 1002
p 01 00000 00001 06EA
#
# CX = CX - 1 (( Add 0xFFFF ))
p 00 00000 00001 06E8
p 01 00000 00001 222F
p 01 00000 00001 FFFF
#
# Jump unconditional to START: 
p 00 00000 00001 06E9
p 01 00000 00001 1000
p 01 00000 00001 06ED
#
# CX_IS_ZERO
# ----------
# Write 9 clocks to clock counter
p 00 00000 00001 06EA
p 01 00000 00001 5FFF
p 01 00000 00001 C0B4
#
# CALL WAIT_CLOCKS
p 00 00000 00001 06EB
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Jump unconditional to NOP ending
p 00 00000 00001 06EC
p 01 00000 00001 1000
p 01 00000 00001 0040
#
# START
# ----------
# Write 16 clocks to clock counter
p 00 00000 00001 06ED
p 01 00000 00001 5FFF
p 01 00000 00001 C091
#
# CALL WAIT_CLOCKS
p 00 00000 00001 06EE
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Set the segment to DS  (Can be overridden)
p 00 00000 00001 06EF
p 01 00000 00001 5DDF
p 01 00000 00001 0C00
#
# r3 = SI
p 00 00000 00001 06F0
p 01 00000 00001 5C6F
p 01 00000 00001 0000
#
# CALL MEM_READ_WORD
p 00 00000 00001 06F1
p 01 00000 00001 1100
p 01 00000 00001 0585
#
# AX = biu_return_data
p 00 00000 00001 06F2
p 01 00000 00001 50F7
p 01 00000 00001 0000
#
# Isolate the direction flag bit into Dummy
p 00 00000 00001 06F3
p 01 00000 00001 4E8F
p 01 00000 00001 0400
#
# If last_alu is non-zero, jump to DECREMENT_POINTERS:
p 00 00000 00001 06F4
p 01 00000 00001 1001
p 01 00000 00001 06F7
#
# SI = SI + 2
p 00 00000 00001 06F5
p 01 00000 00001 266F
p 01 00000 00001 0002
#
# Jump unconditional to REP_END:
p 00 00000 00001 06F6
p 01 00000 00001 1000
p 01 00000 00001 06F8
#
# DECREMENT_POINTERS:
# SI = SI - 2
p 00 00000 00001 06F7
p 01 00000 00001 266F
p 01 00000 00001 FFFE
#
# REP_END:
# Isolate the REP bits into Dummy
p 00 00000 00001 06F8
p 01 00000 00001 4E8F
p 01 00000 00001 C000
#
# If last_alu is non-zero, then REP is asserted, so jump to main microcode loop to re-run this instruction, but poll for interrupts first
p 00 00000 00001 06F9
p 01 00000 00001 1001
p 01 00000 00001 0006
#
# Write 1 clocks to clock counter to equal 13 clocks for this instruction
p 00 00000 00001 06FA
p 01 00000 00001 5FFF
p 01 00000 00001 C014
#
# CALL WAIT_CLOCKS
p 00 00000 00001 06FB
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Jump unconditional to NOP ending
p 00 00000 00001 06FC
p 01 00000 00001 1000
p 01 00000 00001 0040
#
#
# -----------------------------------------------------
#
# 0xAA - STOSB - Store AL to String - Byte
#   
# -----------------------------------------------------
#
# Isolate the REP bits into Dummy
p 00 00000 00001 0700
p 01 00000 00001 4E8F
p 01 00000 00001 C000
#
# If last_alu is zero, then REP not asserted, so jump over the following code to START:
p 00 00000 00001 0701
p 01 00000 00001 1002
p 01 00000 00001 0709
#
# Dummy = CX
p 00 00000 00001 0702
p 01 00000 00001 5E2F
p 01 00000 00001 0000
#
# If last_alu is zero, then CX=0, jump to CX_IS_ZERO:
p 00 00000 00001 0703
p 01 00000 00001 1002
p 01 00000 00001 0706
#
# CX = CX - 1 (( Add 0xFFFF ))
p 00 00000 00001 0704
p 01 00000 00001 222F
p 01 00000 00001 FFFF
#
# Jump unconditional to START: 
p 00 00000 00001 0705
p 01 00000 00001 1000
p 01 00000 00001 0709
#
# CX_IS_ZERO
# ----------
# Write 9 clocks to clock counter
p 00 00000 00001 0706
p 01 00000 00001 5FFF
p 01 00000 00001 C0B4
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0707
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Jump unconditional to NOP ending
p 00 00000 00001 0708
p 01 00000 00001 1000
p 01 00000 00001 0040
#
# START
# ----------
# Write 10 clocks to clock counter
p 00 00000 00001 0709
p 01 00000 00001 5FFF
p 01 00000 00001 C044
#
# CALL WAIT_CLOCKS
p 00 00000 00001 070A
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# NOP
p 00 00000 00001 070B
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# Debounce the BIU Command fields - Set the segment to ES=00  (Can *NOT* be overridden)
p 00 00000 00001 070C
p 01 00000 00001 4DDF
p 01 00000 00001 0003
#
# r3 = DI
p 00 00000 00001 070D
p 01 00000 00001 5C7F
p 01 00000 00001 0000
#
# biu_dataout = AX
p 00 00000 00001 070E
p 01 00000 00001 5F0F
p 01 00000 00001 0000
#
# CALL MEM_WRITE_BYTE
p 00 00000 00001 070F
p 01 00000 00001 1100
p 01 00000 00001 0587
#
# NOP
p 00 00000 00001 0710
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# Isolate the direction flag bit into Dummy
p 00 00000 00001 0711
p 01 00000 00001 4E8F
p 01 00000 00001 0400
#
# If last_alu is non-zero, jump to DECREMENT_POINTERS:
p 00 00000 00001 0712
p 01 00000 00001 1001
p 01 00000 00001 0715
#
# DI = DI + 1
p 00 00000 00001 0713
p 01 00000 00001 277F
p 01 00000 00001 0001
#
# Jump unconditional to REP_END:
p 00 00000 00001 0714
p 01 00000 00001 1000
p 01 00000 00001 0716
#
# DECREMENT_POINTERS:
# DI = DI - 1
p 00 00000 00001 0715
p 01 00000 00001 277F
p 01 00000 00001 FFFF
#
# REP_END:
# Isolate the REP bits into Dummy
p 00 00000 00001 0716
p 01 00000 00001 4E8F
p 01 00000 00001 C000
#
# If last_alu is non-zero, then REP is asserted, so jump to main microcode loop to re-run this instruction, but poll for interrupts first
p 00 00000 00001 0717
p 01 00000 00001 1001
p 01 00000 00001 0006
#
# Write 1 clocks to clock counter to equal 11 clocks for this instruction
p 00 00000 00001 0718
p 01 00000 00001 5FFF
p 01 00000 00001 C014
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0719
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Jump unconditional to NOP ending
p 00 00000 00001 071A
p 01 00000 00001 1000
p 01 00000 00001 0040
#
#
# -----------------------------------------------------
#
# 0xAB - STOSW - Store AX to String - Word
#   
# -----------------------------------------------------
#
# Isolate the REP bits into Dummy
p 00 00000 00001 0720
p 01 00000 00001 4E8F
p 01 00000 00001 C000
#
# If last_alu is zero, then REP not asserted, so jump over the following code to START:
p 00 00000 00001 0721
p 01 00000 00001 1002
p 01 00000 00001 0729
#
# Dummy = CX
p 00 00000 00001 0722
p 01 00000 00001 5E2F
p 01 00000 00001 0000
#
# If last_alu is zero, then CX=0, jump to CX_IS_ZERO:
p 00 00000 00001 0723
p 01 00000 00001 1002
p 01 00000 00001 0726
#
# CX = CX - 1 (( Add 0xFFFF ))
p 00 00000 00001 0724
p 01 00000 00001 222F
p 01 00000 00001 FFFF
#
# Jump unconditional to START: 
p 00 00000 00001 0725
p 01 00000 00001 1000
p 01 00000 00001 0729
#
# CX_IS_ZERO
# ----------
# Write 9 clocks to clock counter
p 00 00000 00001 0726
p 01 00000 00001 5FFF
p 01 00000 00001 C0B4
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0727
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Jump unconditional to NOP ending
p 00 00000 00001 0728
p 01 00000 00001 1000
p 01 00000 00001 0040
#
# START
# ----------
# Write 14 clocks to clock counter
p 00 00000 00001 0729
p 01 00000 00001 5FFF
p 01 00000 00001 C044
#
# CALL WAIT_CLOCKS
p 00 00000 00001 072A
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# NOP
p 00 00000 00001 072B
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# Debounce the BIU Command fields - Set the segment to ES=00  (Can *NOT* be overridden)
p 00 00000 00001 072C
p 01 00000 00001 4DDF
p 01 00000 00001 0003
#
# r3 = DI
p 00 00000 00001 072D
p 01 00000 00001 5C7F
p 01 00000 00001 0000
#
# biu_dataout = AX
p 00 00000 00001 072E
p 01 00000 00001 5F0F
p 01 00000 00001 0000
#
# CALL MEM_WRITE_WORD
p 00 00000 00001 072F
p 01 00000 00001 1100
p 01 00000 00001 0589
#
# NOP
p 00 00000 00001 0730
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# Isolate the direction flag bit into Dummy
p 00 00000 00001 0731
p 01 00000 00001 4E8F
p 01 00000 00001 0400
#
# If last_alu is non-zero, jump to DECREMENT_POINTERS:
p 00 00000 00001 0732
p 01 00000 00001 1001
p 01 00000 00001 0735
#
# DI = DI + 2
p 00 00000 00001 0733
p 01 00000 00001 277F
p 01 00000 00001 0002
#
# Jump unconditional to REP_END:
p 00 00000 00001 0734
p 01 00000 00001 1000
p 01 00000 00001 0736
#
# DECREMENT_POINTERS:
# DI = DI - 2
p 00 00000 00001 0735
p 01 00000 00001 277F
p 01 00000 00001 FFFE
#
# REP_END:
# Isolate the REP bits into Dummy
p 00 00000 00001 0736
p 01 00000 00001 4E8F
p 01 00000 00001 C000
#
# If last_alu is non-zero, then REP is asserted, so jump to main microcode loop to re-run this instruction, but poll for interrupts first
p 00 00000 00001 0737
p 01 00000 00001 1001
p 01 00000 00001 0006
#
# Write 1 clocks to clock counter to equal 11 clocks for this instruction
p 00 00000 00001 0738
p 01 00000 00001 5FFF
p 01 00000 00001 C014
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0739
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Jump unconditional to NOP ending
p 00 00000 00001 073A
p 01 00000 00001 1000
p 01 00000 00001 0040
#
#
# -----------------------------------------------------
#
# REPEAT processing code
#
# -----------------------------------------------------
# 
# Isolate the REPZ bit into Dummy
p 00 00000 00001 0740
p 01 00000 00001 4E8F
p 01 00000 00001 4000
#
# If last_alu is zero, then jump to check REPNZ
p 00 00000 00001 0741
p 01 00000 00001 1002
p 01 00000 00001 0745
#
# REPZ handler
# Isolate the ZF bit into Dummy
p 00 00000 00001 0742
p 01 00000 00001 4E8F
p 01 00000 00001 0040
#
# If last_alu is zero, then Zero flag=0 which terminates this REP condition, so jump to NOP ending which fetches next instruction
p 00 00000 00001 0743
p 01 00000 00001 1002
p 01 00000 00001 0040
#
# Zero flag=1, so we should repeat this instruction, so Jump unconditional to main microcode loop to re-run this instruction, but poll for interrupts first
p 00 00000 00001 0744
p 01 00000 00001 1000
p 01 00000 00001 0006
#
#
# REPNZ handler
# Isolate the ZF bit into Dummy
p 00 00000 00001 0745
p 01 00000 00001 4E8F
p 01 00000 00001 0040
#
# If last_alu is non-zero, then Zero flag=1 which terminates this REP condition, so jump to NOP ending which fetches next instruction
p 00 00000 00001 0746
p 01 00000 00001 1001
p 01 00000 00001 0040
#
# Zero flag=0, so we should repeat this instruction, so Jump unconditional to main microcode loop to re-run this instruction, but poll for interrupts first
p 00 00000 00001 0747
p 01 00000 00001 1000
p 01 00000 00001 0006
#
# --------------------------------------------------------------------
# 
# Wait for prefetch queue to not be empty, then jump to main loop, past interrupt polling, and no debouncing of the prefixes.
#
# Isolate the Prefetch Queue EMPTY bit into Dummy
p 00 00000 00001 0748
p 01 00000 00001 4EEF
p 01 00000 00001 0080
#
# Jump to Prefetch Queue EMPTY bit check if last result is zero
p 00 00000 00001 0749
p 01 00000 00001 1002
p 01 00000 00001 0748
#
# Jump unconditional to main loop skipping all interupt polling - And will not debounce prefixes
p 00 00000 00001 074A
p 01 00000 00001 1000
p 01 00000 00001 0011
#
#
# --------------------------------------------------------------------
#
# PROCEDURE - STORE_SEG_PREFIX
#
# Store the Segment Override Prefix bit in the AF Flag temporarily
#
# --------------------------------------------------------------------
#
# Isolate segment_override into Dummy
p 00 00000 00001 0750
p 01 00000 00001 4EDF
p 01 00000 00001 C000
#
# Jump if last ALU=0 to B:
p 00 00000 00001 0751
p 01 00000 00001 1002
p 01 00000 00001 0755
#
# Set eu_alu_a flag to 1
p 00 00000 00001 0752
p 01 00000 00001 588F
p 01 00000 00001 0010
#
# Set segment_override prefix bit to 0
p 00 00000 00001 0753
p 01 00000 00001 4DDF
p 01 00000 00001 BFFF
#
# Return to calling code
p 00 00000 00001 0754
p 01 00000 00001 1030
p 01 00000 00001 4000
#
# B: Set eu_alu_a flag to 0
p 00 00000 00001 0755
p 01 00000 00001 488F
p 01 00000 00001 FFEF
#
# Set segment_override prefix bit to 0
p 00 00000 00001 0756
p 01 00000 00001 4DDF
p 01 00000 00001 BFFF
#
# Return to calling code
p 00 00000 00001 0757
p 01 00000 00001 1030
p 01 00000 00001 4000
#
# --------------------------------------------------------------------
#
# PROCEDURE - RESTORE_SEG_PREFIX
#
# Retore the Segment Override Prefix bit from the AF Flag
# The override prefix is assumed to be 0 before entering this procedure.
#
# --------------------------------------------------------------------
#
# Isolate eu_alu_a flag into Dummy
p 00 00000 00001 075A
p 01 00000 00001 4E8F
p 01 00000 00001 0010
#
# Return to calling code if last ALU=0
p 00 00000 00001 075B
p 01 00000 00001 1032
p 01 00000 00001 0000
#
# Set segment_override prefix bit to 1
p 00 00000 00001 075C
p 01 00000 00001 5DDF
p 01 00000 00001 4000
#
# Return to calling code
p 00 00000 00001 075D
p 01 00000 00001 1030
p 01 00000 00001 4000

#
# --------------------------------------------------------------------
#
# PROCEDURE - CALC_EA
#
# Calculates and decodes both MOD/RM and REG of the addressing byte.
#
# Stores EA/REG in biu_register_rm
# Stores REG register number in biu_register_reg
# r1 retains the addressing byte
#
# Sets REPZ bit depending on if EA/REG below is register or memory. 
#   REPZ=0 - biu_register_rm is memory address
#   REPZ=1 - biu_register_rm is a register number
#
# Sets REPNZ bit depending on the segment that should be used for the memory address
#   REPNZ=0 - DS
#   REPNZ=1 - SS
#
# CALL Address 0x0760 - Byte opcodes 
# CALL Address 0x0762 - Word opcodes 
#
# --------------------------------------------------------------------
#
# Set r0 to 0x0000 for byte instructions
p 00 00000 00001 0760
p 01 00000 00001 59FF
p 01 00000 00001 0000
#
# Jump unconditional over next instruction
p 00 00000 00001 0761
p 01 00000 00001 1000
p 01 00000 00001 0763
#
# Set r0 to 0x0008 for word instructions
p 00 00000 00001 0762
p 01 00000 00001 59FF
p 01 00000 00001 0008
#
# Initialize REPZ and REPNZ flags to zero
p 00 00000 00001 0763
p 01 00000 00001 488F
p 01 00000 00001 3FFF
#
#
# Fetch the addressing byte from the prefetch queue.
# Call procedure to fetch next byte from prefetch queue into r3
p 00 00000 00001 0764
p 01 00000 00001 1100
p 01 00000 00001 02A0
#
# Save a copy of the addressing byte in r1 = r3  since r3 is reused frequently.
p 00 00000 00001 0765
p 01 00000 00001 5AFC
p 01 00000 00001 0000
#
#
# EA_REG Decode Processing
# Sets biu_ea_reg to a concatenation of { W , RM } - Four bits that hold the register number
#
# Shift r1 into r3 one bit to the right.
p 00 00000 00001 0766
p 01 00000 00001 7CA0
p 01 00000 00001 0000
#
# Shift r3 to the right one bit.
p 00 00000 00001 0767
p 01 00000 00001 7CC0
p 01 00000 00001 0000
#
# Shift r3 to the right one bit.
p 00 00000 00001 0768
p 01 00000 00001 7CC0
p 01 00000 00001 0000
#
# Zero out r3[15:3]
p 00 00000 00001 0769
p 01 00000 00001 4CCF
p 01 00000 00001 0007
#
# biu_dataout = r3 OR r0  - Prepend the byte/word bit to r3 - This is now the register number.
p 00 00000 00001 076A
p 01 00000 00001 5F9C
p 01 00000 00001 0000
#
# Strobe the biu to update the biu_register_reg value
p 00 00000 00001 076B
p 01 00000 00001 5DDF
p 01 00000 00001 3050
#
# Debounce BIU Strobe 
p 00 00000 00001 076C
p 01 00000 00001 4DDF
p 01 00000 00001 CC0F
#
#
# Check MOD Bits:
# If MOD=11, then perform MOD11 processing (addressing byte points to a register value)
# Else perform MODxx processing.
#
# Isolate MOD bits from r1[7:6] into r3
p 00 00000 00001 076D
p 01 00000 00001 4CAF
p 01 00000 00001 00C0
#
# Subtract 0x00C0 from r3 into Dummy   (( Add FF40 ))
p 00 00000 00001 076E
p 01 00000 00001 2ECF
p 01 00000 00001 FF40
#
# if nonzero Jump to MODxx processing  Jump-Type2 = { imm , MOD , RM , 000 } address at base 0x0800
# MODxx ending code will return back to calling code.
p 00 00000 00001 076F
p 01 00000 00001 1021
p 01 00000 00001 0008
#
#
# MOD11 Processing - EA is a register
# Sets biu_ea_rm to a concatenation of { W , RM } - Four bits that hold the register number
# REPZ is set to 1 to designate that EA_REG is a register and not a calculated EA address.
#
# Set REPZ Flag to 1
p 00 00000 00001 0770
p 01 00000 00001 588F
p 01 00000 00001 4000
#
# Isolate RM bits held in r1 into r3
p 00 00000 00001 0771
p 01 00000 00001 4CAF
p 01 00000 00001 0007
#
# biu_dataout = r3 OR r0  - Prepend the byte/word bit to r3 - This is now the register number.
p 00 00000 00001 0772
p 01 00000 00001 5F9C
p 01 00000 00001 0000
#
# Strobe the biu to update the biu_register_rm value
p 00 00000 00001 0773
p 01 00000 00001 5DDF
p 01 00000 00001 3040
#
# Debounce BIU Strobe
p 00 00000 00001 0774
p 01 00000 00001 4DDF
p 01 00000 00001 CC0F
#
# Return to calling code
p 00 00000 00001 0775
p 01 00000 00001 1030
p 01 00000 00001 4000
#
#
#
# MODxx Ending code
# Strobes the BIU to update the biu_register_rm value with the memory address.
# Also calls the clock wait procedure.
#
# biu_dataout = r0
p 00 00000 00001 0780
p 01 00000 00001 5FF9
p 01 00000 00001 0000
#
# Strobe the biu to update the biu_register_rm value
p 00 00000 00001 0781
p 01 00000 00001 5DDF
p 01 00000 00001 3040
#
# Debounce BIU Strobe
p 00 00000 00001 0782
p 01 00000 00001 4DDF
p 01 00000 00001 C003
#
# biu_dataout = r2
p 00 00000 00001 0783
p 01 00000 00001 5FFB
p 01 00000 00001 0000
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0784
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Return to calling code
p 00 00000 00001 0785
p 01 00000 00001 1030
p 01 00000 00001 4000
#
#
# --------------------------------------------------------------------
#
# PROCEDURE - FETCH_EA
#
# Fetches the data from either memory or a register into r0.
# Destroys r2.
#
# If a byte, then the upper byte or r0 will be zeroed out.
#
# Uses REPZ bit to choose if EA/REG below is register or memory. 
#   REPZ=0 - biu_register_rm is memory address
#   REPZ=1 - biu_register_rm is a register number
#
# Uses REPNZ bit to choose the segment to use for the memory address
#   REPNZ=0 - DS
#   REPNZ=1 - SS
#
# CALL Address 0x0790 - Fetch Byte
# CALL Address 0x0792 - Fetch Word
#
# --------------------------------------------------------------------
#
# Set r2 to 0x00FF for Byte Operations  - Used to AND with return data to zero out the upper byte.
p 00 00000 00001 0790
p 01 00000 00001 5BFF
p 01 00000 00001 00FF
#
# Jump unconditional over next instruction
p 00 00000 00001 0791
p 01 00000 00001 1000
p 01 00000 00001 0793
#
# Set r2 to 0xFFFF for Word Operations
p 00 00000 00001 0792
p 01 00000 00001 5BFF
p 01 00000 00001 FFFF
#
#
# Isolate the REPZ bit to decide between register and memory
p 00 00000 00001 0793
p 01 00000 00001 4E8F
p 01 00000 00001 4000
#
# Jump if zero to EA_MEM_FETCH:
p 00 00000 00001 0794
p 01 00000 00001 1002
p 01 00000 00001 07C0
#
#
# Copy biu_register_rm value to the biu_dataout register
p 00 00000 00001 0795
p 01 00000 00001 5FF5
p 01 00000 00001 0000
#
# CALL with Jump-Type4 to register table at 0x07A0
p 00 00000 00001 0796
p 01 00000 00001 1140
p 01 00000 00001 003D
#
# r0 = r0 AND r2  - Zero out the upper byte if this is a byte operation.
p 00 00000 00001 0797
p 01 00000 00001 499B
p 01 00000 00001 0000
#
# Return to calling code
p 00 00000 00001 0798
p 01 00000 00001 1030
p 01 00000 00001 1030
#
# --------------------------------------------------------------
#
# Procedure Register fetch table  { W , reg[2:0] }
#

# r0 = AL
p 00 00000 00001 07A0
p 01 00000 00001 590F
p 01 00000 00001 0000
#
# Return to calling code
p 00 00000 00001 07A1
p 01 00000 00001 1030
p 01 00000 00001 1030
#
# r0 = CL
p 00 00000 00001 07A2
p 01 00000 00001 592F
p 01 00000 00001 0000
#
# Return to calling code
p 00 00000 00001 07A3
p 01 00000 00001 1030
p 01 00000 00001 1030
#
# r0 = DL
p 00 00000 00001 07A4
p 01 00000 00001 593F
p 01 00000 00001 0000
#
# Return to calling code
p 00 00000 00001 07A5
p 01 00000 00001 1030
p 01 00000 00001 1030
#
# r0 = BL
p 00 00000 00001 07A6
p 01 00000 00001 591F
p 01 00000 00001 0000
#
# Return to calling code
p 00 00000 00001 07A7
p 01 00000 00001 1030
p 01 00000 00001 1030
#
##
#
# r0 = AH byte-swapped so upper byte is now in lower byte
p 00 00000 00001 07A8
p 01 00000 00001 390F
p 01 00000 00001 0000
#
# Return to calling code
p 00 00000 00001 07A9
p 01 00000 00001 1030
p 01 00000 00001 1030
#
# r0 = CH byte-swapped so upper byte is now in lower byte
p 00 00000 00001 07AA
p 01 00000 00001 392F
p 01 00000 00001 0000
#
# Return to calling code
p 00 00000 00001 07AB
p 01 00000 00001 1030
p 01 00000 00001 1030
#
# r0 = DH byte-swapped so upper byte is now in lower byte
p 00 00000 00001 07AC
p 01 00000 00001 393F
p 01 00000 00001 0000
#
# Return to calling code
p 00 00000 00001 07AD
p 01 00000 00001 1030
p 01 00000 00001 1030
#
# r0 = BH byte-swapped so upper byte is now in lower byte
p 00 00000 00001 07AE
p 01 00000 00001 391F
p 01 00000 00001 0000
#
# Return to calling code
p 00 00000 00001 07AF
p 01 00000 00001 1030
p 01 00000 00001 1030
#
##
#
# r0 = AX
p 00 00000 00001 07B0
p 01 00000 00001 590F
p 01 00000 00001 0000
#
# Return to calling code
p 00 00000 00001 07B1
p 01 00000 00001 1030
p 01 00000 00001 1030
#
# r0 = CX
p 00 00000 00001 07B2
p 01 00000 00001 592F
p 01 00000 00001 0000
#
# Return to calling code
p 00 00000 00001 07B3
p 01 00000 00001 1030
p 01 00000 00001 1030
#
# r0 = DX
p 00 00000 00001 07B4
p 01 00000 00001 593F
p 01 00000 00001 0000
#
# Return to calling code
p 00 00000 00001 07B5
p 01 00000 00001 1030
p 01 00000 00001 1030
#
# r0 = BX
p 00 00000 00001 07B6
p 01 00000 00001 591F
p 01 00000 00001 0000
#
# Return to calling code
p 00 00000 00001 07B7
p 01 00000 00001 1030
p 01 00000 00001 1030
#
##
#
# r0 = SP
p 00 00000 00001 07B8
p 01 00000 00001 594F
p 01 00000 00001 0000
#
# Return to calling code
p 00 00000 00001 07B9
p 01 00000 00001 1030
p 01 00000 00001 1030
#
# r0 = BP
p 00 00000 00001 07BA
p 01 00000 00001 595F
p 01 00000 00001 0000
#
# Return to calling code
p 00 00000 00001 07BB
p 01 00000 00001 1030
p 01 00000 00001 1030
#
# r0 = SI
p 00 00000 00001 07BC
p 01 00000 00001 596F
p 01 00000 00001 0000
#
# Return to calling code
p 00 00000 00001 07BD
p 01 00000 00001 1030
p 01 00000 00001 1030
#
# r0 = DI
p 00 00000 00001 07BE
p 01 00000 00001 597F
p 01 00000 00001 0000
#
# Return to calling code
p 00 00000 00001 07BF
p 01 00000 00001 1030
p 01 00000 00001 1030
#
# --------------------------------------------------------------
# EA_MEM_FETCH:
#
# Debounce the segment field in biu_command to be safe
p 00 00000 00001 07C0
p 01 00000 00001 4DDF
p 01 00000 00001 C003
#
# Select the segment to use.
# Isolate the REPNZ bit into Dummy
p 00 00000 00001 07C1
p 01 00000 00001 4E8F
p 01 00000 00001 8000
#
# If last_alu is zero, then jump to set segment to DS
p 00 00000 00001 07C2
p 01 00000 00001 1002
p 01 00000 00001 07C5
#
# Set the segment to SS  (Can be overridden)
p 00 00000 00001 07C3
p 01 00000 00001 5DDF
p 01 00000 00001 0400
#
# Jump unconditional over next instruction
p 00 00000 00001 07C4
p 01 00000 00001 1000
p 01 00000 00001 07C6
#
# Set the segment to DS  (Can be overridden)
p 00 00000 00001 07C5
p 01 00000 00001 5DDF
p 01 00000 00001 0C00
#
#
# r3 = biu_register_rm - The memory address to read the data from.
p 00 00000 00001 07C6
p 01 00000 00001 5CF5
p 01 00000 00001 0000
# 
# Dummy = r2 + 1 - if result=0, then WORD, else BYTE
p 00 00000 00001 07C7
p 01 00000 00001 2EBF
p 01 00000 00001 0001
# 
# If last_alu is zero, then jump to read word
p 00 00000 00001 07C8
p 01 00000 00001 1002
p 01 00000 00001 07CD
#
# CALL MEM_READ_BYTE
p 00 00000 00001 07C9
p 01 00000 00001 1100
p 01 00000 00001 0580
#
# r0 = biu_return_data
p 00 00000 00001 07CA
p 01 00000 00001 59F7
p 01 00000 00001 0000
# 
# Zero out high byte of biu_return_data into r0
# r0 = r0 AND 00FF
p 00 00000 00001 07CB
p 01 00000 00001 499F
p 01 00000 00001 00FF
# 
# Jump unconditional to end
p 00 00000 00001 07CC
p 01 00000 00001 1000
p 01 00000 00001 07CF
#
#
# CALL MEM_READ_WORD 
p 00 00000 00001 07CD
p 01 00000 00001 1100
p 01 00000 00001 0585
#
# r0 = biu_return_data
p 00 00000 00001 07CE
p 01 00000 00001 59F7
p 01 00000 00001 0000
# 
# 
# Write 1 clocks to clock counter
p 00 00000 00001 07CF
p 01 00000 00001 5FFF
p 01 00000 00001 C014
#
# CALL WAIT_CLOCKS
p 00 00000 00001 07D0
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Return to calling code
p 00 00000 00001 07D1
p 01 00000 00001 1030
p 01 00000 00001 1030
#
#
# --------------------------------------------------------------------
#
# PROCEDURE - FETCH_REG
#
# Fetches the register value into r0.
# Destroys r2.
#
# Uses Jump-Type4, so biu_dataout_reg needs will be populated with biu_register_reg.
#
# If a byte, then the upper byte or r0 will be zeroed out.
#
#
# --------------------------------------------------------------------
#
# Copy biu_register_reg value to the biu_dataout register
p 00 00000 00001 07D4
p 01 00000 00001 5FF6
p 01 00000 00001 0000
#
# CALL with Jump-Type4 to register table at 0x07A0
p 00 00000 00001 07D5
p 01 00000 00001 1140
p 01 00000 00001 003D
#
# Copy biu_register_reg value to r2
p 00 00000 00001 07D6
p 01 00000 00001 5BF6
p 01 00000 00001 0000
#
# Isolate W bit of r2 into Dummy
p 00 00000 00001 07D7
p 01 00000 00001 4EBF
p 01 00000 00001 0008
#
# If last_alu is non-zero, then jump over next instruction
p 00 00000 00001 07D8
p 01 00000 00001 1001
p 01 00000 00001 07DA
#
# Zero the upper byte of r0
p 00 00000 00001 07D9
p 01 00000 00001 499F
p 01 00000 00001 00FF
#
# Return to calling code
p 00 00000 00001 07DA
p 01 00000 00001 1030
p 01 00000 00001 1030
#
#
# --------------------------------------------------------------------
#
# PROCEDURE - WRITEBACK_EA
#
# Writes r0 to either memory or a register.
# Destroys r2.
#
# If a byte, then the upper byte or r0 will be zeroed out and written to the register.
#
# Uses REPZ bit to choose if EA/REG below is register or memory. 
#   REPZ=0 - biu_register_rm is memory address
#   REPZ=1 - biu_register_rm is a register number
#
# Uses REPNZ bit to choose the segment to use for the memory address
#   REPNZ=0 - DS
#   REPNZ=1 - SS
#
# CALL Address 0x07E0 - Writeback Byte
# CALL Address 0x07E2 - Writeback Word
#
# --------------------------------------------------------------------
#
# Set r2 to 0x00FF for Byte Operations  - Used to AND with return data to zero out the upper byte.
p 00 00000 00001 07E0
p 01 00000 00001 5BFF
p 01 00000 00001 00FF
#
# Jump unconditional over next instruction
p 00 00000 00001 07E1
p 01 00000 00001 1000
p 01 00000 00001 07E3
#
# Set r2 to 0xFFFF for Word Operations
p 00 00000 00001 07E2
p 01 00000 00001 5BFF
p 01 00000 00001 FFFF
#
#
# Isolate the REPZ bit to decide between register and memory
p 00 00000 00001 07E3
p 01 00000 00001 4E8F
p 01 00000 00001 4000
#
# Jump if zero to EA_MEM_WRITEBACK:
p 00 00000 00001 07E4
p 01 00000 00001 1002
p 01 00000 00001 07F0
#
#
# Copy biu_register_rm value to the biu_dataout register
p 00 00000 00001 07E5
p 01 00000 00001 5FF5
p 01 00000 00001 0000
#
# r0 = r0 AND r2  - Zero out the upper byte if this is a byte operation.
p 00 00000 00001 07E6
p 01 00000 00001 499B
p 01 00000 00001 0000
#
# CALL with Jump-Type5 to register table at 0x08C0
p 00 00000 00001 07E7
p 01 00000 00001 1150
p 01 00000 00001 0023
#
# Return to calling code
p 00 00000 00001 07E8
p 01 00000 00001 1030
p 01 00000 00001 0000
#
#
# --------------------------------------------------------------
# EA_MEM_WRITEBACK:
#
# Debounce the segment field in biu_command to be safe
p 00 00000 00001 07F0
p 01 00000 00001 4DDF
p 01 00000 00001 C003
#
# Select the segment to use.
# Isolate the REPNZ bit into Dummy
p 00 00000 00001 07F1
p 01 00000 00001 4E8F
p 01 00000 00001 8000
#
# If last_alu is zero, then jump to set segment to DS
p 00 00000 00001 07F2
p 01 00000 00001 1002
p 01 00000 00001 07F5
#
# Set the segment to SS  (Can be overridden)
p 00 00000 00001 07F3
p 01 00000 00001 5DDF
p 01 00000 00001 0400
#
# Jump unconditional over next instruction
p 00 00000 00001 07F4
p 01 00000 00001 1000
p 01 00000 00001 07F6
#
# Set the segment to DS  (Can be overridden)
p 00 00000 00001 07F5
p 01 00000 00001 5DDF
p 01 00000 00001 0C00
#
# r3 = biu_register_rm - The memory address to write the data to.
p 00 00000 00001 07F6
p 01 00000 00001 5CF5
p 01 00000 00001 0000
# 
# Copy r0 to the biu_dataout register - The data to be written to memory.
p 00 00000 00001 07F7
p 01 00000 00001 5FF9
p 01 00000 00001 0000
#
# Dummy = r2 + 1 - if result=0, then WORD, else BYTE
p 00 00000 00001 07F8
p 01 00000 00001 2EBF
p 01 00000 00001 0001
# 
# If last_alu is zero, then jump to read word
p 00 00000 00001 07F9
p 01 00000 00001 1002
p 01 00000 00001 07FC
#
# CALL MEM_WRITE_BYTE
p 00 00000 00001 07FA
p 01 00000 00001 1100
p 01 00000 00001 0587
#
# Return to calling code
p 00 00000 00001 07FB
p 01 00000 00001 1030
p 01 00000 00001 0000
#
# CALL MEM_WRITE_WORD 
p 00 00000 00001 07FC
p 01 00000 00001 1100
p 01 00000 00001 0589
#
# Return to calling code
p 00 00000 00001 07FD
p 01 00000 00001 1030
p 01 00000 00001 0000
#
#
#
# MODxx Processing - EA is an address
# Writes calculated EA to r0.
# Destroys r2.
#
#
# This microcode is entered through a Jump-Type2 which is a concatenation of the addressing byte's { imm , MOD[1:0] , RM[2:0] , 000 } fields.
# There are 3-bits, or 8 addresses reserved for each EA calculation type.
# The 8-bit combination requires a 256 address block, so we need to start the block at microdode address 0x0800
# 
#
# REPNZ is set to 0 to designate that the segment used should be DS
# REPNZ is set to 1 to designate that the segment used should be SS
#
#
# --------------------------------------------------------------
#
# MOD=00  RM=000   EA = BX + SI
# -------------------------------
#
# Write 7 clocks to r2
p 00 00000 00001 0800
p 01 00000 00001 5BFF
p 01 00000 00001 C08C
#
# r0 = BX
p 00 00000 00001 0801
p 01 00000 00001 591F
p 01 00000 00001 0000
#
# r0 = r0 + SI
p 00 00000 00001 0802
p 01 00000 00001 2969
p 01 00000 00001 0000
#
# Jump unconditional to MODxx ending
p 00 00000 00001 0803
p 01 00000 00001 1000
p 01 00000 00001 0780
#
# --------------------------------------------------------------
#
# MOD=00  RM=001   EA = BX + DI
# -------------------------------
#
# Write 8 clocks to r2
p 00 00000 00001 0808
p 01 00000 00001 5BFF
p 01 00000 00001 C0A0
#
# r0 = BX
p 00 00000 00001 0809
p 01 00000 00001 591F
p 01 00000 00001 0000
#
# r0 = r0 + DI
p 00 00000 00001 080A
p 01 00000 00001 2979
p 01 00000 00001 0000
#
# Jump unconditional to MODxx ending
p 00 00000 00001 080B
p 01 00000 00001 1000
p 01 00000 00001 0780
#
# --------------------------------------------------------------
#
# MOD=00  RM=010   EA = BP + SI
# -------------------------------
#
# Set REPNZ to 1 to denote SS should be used
p 00 00000 00001 0810
p 01 00000 00001 588F
p 01 00000 00001 8000
#
# Write 8 clocks to r2
p 00 00000 00001 0811
p 01 00000 00001 5BFF
p 01 00000 00001 C0A0
#
# r0 = BP
p 00 00000 00001 0812
p 01 00000 00001 595F
p 01 00000 00001 0000
#
# r0 = r0 + SI
p 00 00000 00001 0813
p 01 00000 00001 2969
p 01 00000 00001 0000
#
# Jump unconditional to MODxx ending
p 00 00000 00001 0814
p 01 00000 00001 1000
p 01 00000 00001 0780
#
# --------------------------------------------------------------
#
# MOD=00  RM=011   EA = BP + DI
# -------------------------------
#
# Set REPNZ to 1 to denote SS should be used
p 00 00000 00001 0818
p 01 00000 00001 588F
p 01 00000 00001 8000
#
# Write 7 clocks to r2
p 00 00000 00001 0819
p 01 00000 00001 5BFF
p 01 00000 00001 C08C
#
# r0 = BP
p 00 00000 00001 081A
p 01 00000 00001 595F
p 01 00000 00001 0000
#
# r0 = r0 + DI
p 00 00000 00001 081B
p 01 00000 00001 2979
p 01 00000 00001 0000
#
# Jump unconditional to MODxx ending
p 00 00000 00001 081C
p 01 00000 00001 1000
p 01 00000 00001 0780
#
# --------------------------------------------------------------
#
# MOD=00  RM=100   EA = SI
# -------------------------------
#
# Write 5 clocks to r2
p 00 00000 00001 0820
p 01 00000 00001 5BFF
p 01 00000 00001 C064
#
# r0 = SI
p 00 00000 00001 0821
p 01 00000 00001 596F
p 01 00000 00001 0000
#
# Jump unconditional to MODxx ending
p 00 00000 00001 0822
p 01 00000 00001 1000
p 01 00000 00001 0780
#
# --------------------------------------------------------------
#
# MOD=00  RM=101   EA = DI
# -------------------------------
#
# Write 5 clocks to r2
p 00 00000 00001 0828
p 01 00000 00001 5BFF
p 01 00000 00001 C064
#
# r0 = DI
p 00 00000 00001 0829
p 01 00000 00001 597F
p 01 00000 00001 0000
#
# Jump unconditional to MODxx ending
p 00 00000 00001 082A
p 01 00000 00001 1000
p 01 00000 00001 0780
#
# --------------------------------------------------------------
#
# MOD=00  RM=111   EA = Direct Access - Fetch a word from the prefetch queue
# -------------------------------
#
# Write 6 clocks to r2
p 00 00000 00001 0830
p 01 00000 00001 5BFF
p 01 00000 00001 C078
#
# CALL Fetch Opcode word with QS=Subsequent opcode byte
p 00 00000 00001 0831
p 01 00000 00001 1100
p 01 00000 00001 02E5 
#
# r0 = r3
p 00 00000 00001 0832
p 01 00000 00001 59FC
p 01 00000 00001 0000
#
# Jump unconditional to MODxx ending
p 00 00000 00001 0833
p 01 00000 00001 1000
p 01 00000 00001 0780
#
# --------------------------------------------------------------
#
# MOD=00  RM=111   EA = BX
# -------------------------------
#
# Write 5 clocks to r2
p 00 00000 00001 0838
p 01 00000 00001 5BFF
p 01 00000 00001 C064
#
# r0 = BX
p 00 00000 00001 0839
p 01 00000 00001 591F
p 01 00000 00001 0000
#
# Jump unconditional to MODxx ending
p 00 00000 00001 083A
p 01 00000 00001 1000
p 01 00000 00001 0780
#
# --------------------------------------------------------------
#
# MOD=01  RM=000   EA = BX + SI + D8
# -----------------------------------
#
# Write 11 clocks to r2
p 00 00000 00001 0840
p 01 00000 00001 5BFF
p 01 00000 00001 C0DC
#
# CALL Fetch Opcode byte with QS=Subsequent opcode byte into r3
p 00 00000 00001 0841
p 01 00000 00001 1100
p 01 00000 00001 02A5 
#
# CALL Sign Extend r3
p 00 00000 00001 0842
p 01 00000 00001 1100
p 01 00000 00001 033A
#
# r0 = BX
p 00 00000 00001 0843
p 01 00000 00001 591F
p 01 00000 00001 0000
#
# r0 = r0 + SI
p 00 00000 00001 0844
p 01 00000 00001 2969
p 01 00000 00001 0000
#
# r0 = r0 + r3  - Add the sign extended displacment in r3
p 00 00000 00001 0845
p 01 00000 00001 299C
p 01 00000 00001 0000
#
# Jump unconditional to MODxx ending
p 00 00000 00001 0846
p 01 00000 00001 1000
p 01 00000 00001 0780
#
# --------------------------------------------------------------
#
# MOD=01  RM=001   EA = BX + DI + D8
# -----------------------------------
#
# Write 12 clocks to r2
p 00 00000 00001 0848
p 01 00000 00001 5BFF
p 01 00000 00001 C0F0
#
# CALL Fetch Opcode byte with QS=Subsequent opcode byte into r3
p 00 00000 00001 0849
p 01 00000 00001 1100
p 01 00000 00001 02A5 
#
# CALL Sign Extend r3
p 00 00000 00001 084A
p 01 00000 00001 1100
p 01 00000 00001 033A
#
# r0 = BX
p 00 00000 00001 084B
p 01 00000 00001 591F
p 01 00000 00001 0000
#
# r0 = r0 + DI
p 00 00000 00001 084C
p 01 00000 00001 2979
p 01 00000 00001 0000
#
# r0 = r0 + r3  - Add the sign extended displacment in r3
p 00 00000 00001 084D
p 01 00000 00001 299C
p 01 00000 00001 0000
#
# Jump unconditional to MODxx ending
p 00 00000 00001 084E
p 01 00000 00001 1000
p 01 00000 00001 0780
#
# --------------------------------------------------------------
#
# MOD=01  RM=010   EA = BP + SI + D8
# -----------------------------------
#
# Set REPNZ to 1 to denote SS should be used
p 00 00000 00001 0850
p 01 00000 00001 588F
p 01 00000 00001 8000
#
# Write 12 clocks to r2
p 00 00000 00001 0851
p 01 00000 00001 5BFF
p 01 00000 00001 C0F0
#
# CALL Fetch Opcode byte with QS=Subsequent opcode byte into r3
p 00 00000 00001 0852
p 01 00000 00001 1100
p 01 00000 00001 02A5 
#
# CALL Sign Extend r3
p 00 00000 00001 0853
p 01 00000 00001 1100
p 01 00000 00001 033A
#
# r0 = BP
p 00 00000 00001 0854
p 01 00000 00001 595F
p 01 00000 00001 0000
#
# r0 = r0 + SI
p 00 00000 00001 0855
p 01 00000 00001 2969
p 01 00000 00001 0000
#
# r0 = r0 + r3  - Add the sign extended displacment in r3
p 00 00000 00001 0856
p 01 00000 00001 299C
p 01 00000 00001 0000
#
# Jump unconditional to MODxx ending
p 00 00000 00001 0857
p 01 00000 00001 1000
p 01 00000 00001 0780
#
# --------------------------------------------------------------
#
# MOD=01  RM=011   EA = BP + DI + D8
# -----------------------------------
#
# Set REPNZ to 1 to denote SS should be used
p 00 00000 00001 0858
p 01 00000 00001 588F
p 01 00000 00001 8000
#
# Write 11 clocks to r2
p 00 00000 00001 0859
p 01 00000 00001 5BFF
p 01 00000 00001 C0DC
#
# CALL Fetch Opcode byte with QS=Subsequent opcode byte into r3
p 00 00000 00001 085A
p 01 00000 00001 1100
p 01 00000 00001 02A5 
#
# CALL Sign Extend r3
p 00 00000 00001 085B
p 01 00000 00001 1100
p 01 00000 00001 033A
#
# r0 = BP
p 00 00000 00001 085C
p 01 00000 00001 595F
p 01 00000 00001 0000
#
# r0 = r0 + DI
p 00 00000 00001 085D
p 01 00000 00001 2979
p 01 00000 00001 0000
#
# r0 = r0 + r3  - Add the sign extended displacment in r3
p 00 00000 00001 085E
p 01 00000 00001 299C
p 01 00000 00001 0000
#
# Jump unconditional to MODxx ending
p 00 00000 00001 085F
p 01 00000 00001 1000
p 01 00000 00001 0780
#
# --------------------------------------------------------------
#
# MOD=01  RM=100   EA = SI + D8
# -----------------------------------
#
# Write 9 clocks to r2
p 00 00000 00001 0860
p 01 00000 00001 5BFF
p 01 00000 00001 C0B4
#
# CALL Fetch Opcode byte with QS=Subsequent opcode byte into r3
p 00 00000 00001 0861
p 01 00000 00001 1100
p 01 00000 00001 02A5 
#
# CALL Sign Extend r3
p 00 00000 00001 0862
p 01 00000 00001 1100
p 01 00000 00001 033A
#
# r0 = SI
p 00 00000 00001 0863
p 01 00000 00001 596F
p 01 00000 00001 0000
#
# r0 = r0 + r3  - Add the sign extended displacment in r3
p 00 00000 00001 0864
p 01 00000 00001 299C
p 01 00000 00001 0000
#
# Jump unconditional to MODxx ending
p 00 00000 00001 0865
p 01 00000 00001 1000
p 01 00000 00001 0780
#
# --------------------------------------------------------------
#
# MOD=01  RM=101   EA = DI + D8
# -----------------------------------
#
# Write 9 clocks to r2
p 00 00000 00001 0868
p 01 00000 00001 5BFF
p 01 00000 00001 C0B4
#
# CALL Fetch Opcode byte with QS=Subsequent opcode byte into r3
p 00 00000 00001 0869
p 01 00000 00001 1100
p 01 00000 00001 02A5 
#
# CALL Sign Extend r3
p 00 00000 00001 086A
p 01 00000 00001 1100
p 01 00000 00001 033A
#
# r0 = DI
p 00 00000 00001 086B
p 01 00000 00001 597F
p 01 00000 00001 0000
#
# r0 = r0 + r3  - Add the sign extended displacment in r3
p 00 00000 00001 086C
p 01 00000 00001 299C
p 01 00000 00001 0000
#
# Jump unconditional to MODxx ending
p 00 00000 00001 086D
p 01 00000 00001 1000
p 01 00000 00001 0780
#
# --------------------------------------------------------------
#
# MOD=01  RM=110   EA = BP + D8
# -----------------------------------
#
# Set REPNZ to 1 to denote SS should be used
p 00 00000 00001 0870
p 01 00000 00001 588F
p 01 00000 00001 8000
#
# Write 9 clocks to r2
p 00 00000 00001 0871
p 01 00000 00001 5BFF
p 01 00000 00001 C0B4
#
# CALL Fetch Opcode byte with QS=Subsequent opcode byte into r3
p 00 00000 00001 0872
p 01 00000 00001 1100
p 01 00000 00001 02A5 
#
# CALL Sign Extend r3
p 00 00000 00001 0873
p 01 00000 00001 1100
p 01 00000 00001 033A
#
# r0 = BP
p 00 00000 00001 0874
p 01 00000 00001 595F
p 01 00000 00001 0000
#
# r0 = r0 + r3  - Add the sign extended displacment in r3
p 00 00000 00001 0875
p 01 00000 00001 299C
p 01 00000 00001 0000
#
# Jump unconditional to MODxx ending
p 00 00000 00001 0876
p 01 00000 00001 1000
p 01 00000 00001 0780
#
# --------------------------------------------------------------
#
# MOD=01  RM=111   EA = BP + D8
# -----------------------------------
#
# Write 9 clocks to r2
p 00 00000 00001 0878
p 01 00000 00001 5BFF
p 01 00000 00001 C0B4
#
# CALL Fetch Opcode byte with QS=Subsequent opcode byte into r3
p 00 00000 00001 0879
p 01 00000 00001 1100
p 01 00000 00001 02A5 
#
# CALL Sign Extend r3
p 00 00000 00001 087A
p 01 00000 00001 1100
p 01 00000 00001 033A
#
# r0 = BX
p 00 00000 00001 087B
p 01 00000 00001 591F
p 01 00000 00001 0000
#
# r0 = r0 + r3  - Add the sign extended displacment in r3
p 00 00000 00001 087C
p 01 00000 00001 299C
p 01 00000 00001 0000
#
# Jump unconditional to MODxx ending
p 00 00000 00001 087D
p 01 00000 00001 1000
p 01 00000 00001 0780
#
# --------------------------------------------------------------
# --------------------------------------------------------------
#
# MOD=10  RM=000   EA = BX + SI + D16
# -----------------------------------
#
# Write 11 clocks to r2
p 00 00000 00001 0880
p 01 00000 00001 5BFF
p 01 00000 00001 C0DC
#
# CALL Fetch Opcode word with QS=Subsequent opcode byte into r3
p 00 00000 00001 0881
p 01 00000 00001 1100
p 01 00000 00001 02E5 
#
# r0 = BX
p 00 00000 00001 0882
p 01 00000 00001 591F
p 01 00000 00001 0000
#
# r0 = r0 + SI
p 00 00000 00001 0883
p 01 00000 00001 2969
p 01 00000 00001 0000
#
# r0 = r0 + r3  - Add the 16-bit displacment in r3
p 00 00000 00001 0884
p 01 00000 00001 299C
p 01 00000 00001 0000
#
# Jump unconditional to MODxx ending
p 00 00000 00001 0885
p 01 00000 00001 1000
p 01 00000 00001 0780
#
# --------------------------------------------------------------
#
# MOD=10  RM=001   EA = BX + DI + D16
# -----------------------------------
#
# Write 12 clocks to r2
p 00 00000 00001 0888
p 01 00000 00001 5BFF
p 01 00000 00001 C0F0
#
# CALL Fetch Opcode word with QS=Subsequent opcode byte into r3
p 00 00000 00001 0889
p 01 00000 00001 1100
p 01 00000 00001 02E5 
#
# r0 = BX
p 00 00000 00001 088A
p 01 00000 00001 591F
p 01 00000 00001 0000
#
# r0 = r0 + DI
p 00 00000 00001 088B
p 01 00000 00001 2979
p 01 00000 00001 0000
#
# r0 = r0 + r3  - Add the 16-bit displacment in r3
p 00 00000 00001 088C
p 01 00000 00001 299C
p 01 00000 00001 0000
#
# Jump unconditional to MODxx ending
p 00 00000 00001 088D
p 01 00000 00001 1000
p 01 00000 00001 0780
#
# --------------------------------------------------------------
#
# MOD=10  RM=010   EA = BP + SI + D16
# -----------------------------------
#
# Set REPNZ to 1 to denote SS should be used
p 00 00000 00001 0890
p 01 00000 00001 588F
p 01 00000 00001 8000
#
# Write 12 clocks to r2
p 00 00000 00001 0891
p 01 00000 00001 5BFF
p 01 00000 00001 C0F0
#
# CALL Fetch Opcode word with QS=Subsequent opcode byte into r3
p 00 00000 00001 0892
p 01 00000 00001 1100
p 01 00000 00001 02E5 
#
# r0 = BP
p 00 00000 00001 0893
p 01 00000 00001 595F
p 01 00000 00001 0000
#
# r0 = r0 + SI
p 00 00000 00001 0894
p 01 00000 00001 2969
p 01 00000 00001 0000
#
# r0 = r0 + r3  - Add the 16-bit displacment in r3
p 00 00000 00001 0895
p 01 00000 00001 299C
p 01 00000 00001 0000
#
# Jump unconditional to MODxx ending
p 00 00000 00001 0896
p 01 00000 00001 1000
p 01 00000 00001 0780
#
# --------------------------------------------------------------
#
# MOD=10  RM=011   EA = BP + DI + D16
# -----------------------------------
#
# Set REPNZ to 1 to denote SS should be used
p 00 00000 00001 0898
p 01 00000 00001 588F
p 01 00000 00001 8000
#
# Write 11 clocks to r2
p 00 00000 00001 0899
p 01 00000 00001 5BFF
p 01 00000 00001 C0DC
#
# CALL Fetch Opcode word with QS=Subsequent opcode byte into r3
p 00 00000 00001 089A
p 01 00000 00001 1100
p 01 00000 00001 02E5 
#
# r0 = BP
p 00 00000 00001 089B
p 01 00000 00001 595F
p 01 00000 00001 0000
#
# r0 = r0 + DI
p 00 00000 00001 089C
p 01 00000 00001 2979
p 01 00000 00001 0000
#
# r0 = r0 + r3  - Add the 16-bit displacment in r3
p 00 00000 00001 089D
p 01 00000 00001 299C
p 01 00000 00001 0000
#
# Jump unconditional to MODxx ending
p 00 00000 00001 089E
p 01 00000 00001 1000
p 01 00000 00001 0780
#
# --------------------------------------------------------------
#
# MOD=10  RM=100   EA = SI + D16
# -----------------------------------
#
# Write 9 clocks to r2
p 00 00000 00001 08A0
p 01 00000 00001 5BFF
p 01 00000 00001 C0B4
#
# CALL Fetch Opcode word with QS=Subsequent opcode byte into r3
p 00 00000 00001 08A1
p 01 00000 00001 1100
p 01 00000 00001 02E5 
#
# r0 = SI
p 00 00000 00001 08A2
p 01 00000 00001 596F
p 01 00000 00001 0000
#
# r0 = r0 + r3  - Add the 16-bit displacment in r3
p 00 00000 00001 08A3
p 01 00000 00001 299C
p 01 00000 00001 0000
#
# Jump unconditional to MODxx ending
p 00 00000 00001 08A4
p 01 00000 00001 1000
p 01 00000 00001 0780
#
# --------------------------------------------------------------
#
# MOD=10  RM=101   EA = DI + D16
# -----------------------------------
#
# Write 9 clocks to r2
p 00 00000 00001 08A8
p 01 00000 00001 5BFF
p 01 00000 00001 C0B4
#
# CALL Fetch Opcode word with QS=Subsequent opcode byte into r3
p 00 00000 00001 08A9
p 01 00000 00001 1100
p 01 00000 00001 02E5 
#
# r0 = DI
p 00 00000 00001 08AA
p 01 00000 00001 597F
p 01 00000 00001 0000
#
# r0 = r0 + r3  - Add the 16-bit displacment in r3
p 00 00000 00001 08AB
p 01 00000 00001 299C
p 01 00000 00001 0000
#
# Jump unconditional to MODxx ending
p 00 00000 00001 08AC
p 01 00000 00001 1000
p 01 00000 00001 0780
#
# --------------------------------------------------------------
#
# MOD=10  RM=110   EA = BP + D16
# -----------------------------------
#
# Set REPNZ to 1 to denote SS should be used
p 00 00000 00001 08B0
p 01 00000 00001 588F
p 01 00000 00001 8000
#
# Write 9 clocks to r2
p 00 00000 00001 08B1
p 01 00000 00001 5BFF
p 01 00000 00001 C0B4
#
# CALL Fetch Opcode word with QS=Subsequent opcode byte into r3
p 00 00000 00001 08B2
p 01 00000 00001 1100
p 01 00000 00001 02E5 
#
# r0 = BP
p 00 00000 00001 08B3
p 01 00000 00001 595F
p 01 00000 00001 0000
#
# r0 = r0 + r3  - Add the 16-bit displacment in r3
p 00 00000 00001 08B4
p 01 00000 00001 299C
p 01 00000 00001 0000
#
# Jump unconditional to MODxx ending
p 00 00000 00001 08B5
p 01 00000 00001 1000
p 01 00000 00001 0780
#
# --------------------------------------------------------------
#
# MOD=10  RM=111   EA = BX + D16
# -----------------------------------
#
# Write 9 clocks to r2
p 00 00000 00001 08B8
p 01 00000 00001 5BFF
p 01 00000 00001 C0B4
#
# CALL Fetch Opcode word with QS=Subsequent opcode byte into r3
p 00 00000 00001 08B9
p 01 00000 00001 1100
p 01 00000 00001 02E5 
#
# r0 = BX
p 00 00000 00001 08BA
p 01 00000 00001 591F
p 01 00000 00001 0000
#
# r0 = r0 + r3  - Add the 16-bit displacment in r3
p 00 00000 00001 08BB
p 01 00000 00001 299C
p 01 00000 00001 0000
#
# Jump unconditional to MODxx ending
p 00 00000 00001 08BC
p 01 00000 00001 1000
p 01 00000 00001 0780
#
#
# Register Writeback Processing
#
# This microcode is entered through a Jump-Type5 which is a concatenation of the addressing byte's { imm[6:0] , biu_dataout[3:0] , 00 } fields.
# There are 2-bits, or 4 addresses reserved for each register
# 
# Register data is held in r0.  It is assumed that if a byte operation that the upper byte is zero'ed out already.
#
# --------------------------------------------------------------
#
# Zero out AL 
p 00 00000 00001 08C0
p 01 00000 00001 400F
p 01 00000 00001 FF00
#
# AX = AX OR r0
p 00 00000 00001 08C1
p 01 00000 00001 5009
p 01 00000 00001 0000
#
# Return to calling code
p 00 00000 00001 08C2
p 01 00000 00001 1030
p 01 00000 00001 0000
#
# ##
#
# Zero out CL
p 00 00000 00001 08C4
p 01 00000 00001 422F
p 01 00000 00001 FF00
#
# CX = CX OR r0
p 00 00000 00001 08C5
p 01 00000 00001 5229
p 01 00000 00001 0000
#
# Return to calling code
p 00 00000 00001 08C6
p 01 00000 00001 1030
p 01 00000 00001 0000
#
# ##
#
# Zero out DL
p 00 00000 00001 08C8
p 01 00000 00001 433F
p 01 00000 00001 FF00
#
# DX = DX OR r0
p 00 00000 00001 08C9
p 01 00000 00001 5339
p 01 00000 00001 0000
#
# Return to calling code
p 00 00000 00001 08CA
p 01 00000 00001 1030
p 01 00000 00001 0000
#
## ##
#
# Zero out BL
p 00 00000 00001 08CC
p 01 00000 00001 411F
p 01 00000 00001 FF00
#
# BX = BX OR r0
p 00 00000 00001 08CD
p 01 00000 00001 5119
p 01 00000 00001 0000
#
# Return to calling code
p 00 00000 00001 08CE
p 01 00000 00001 1030
p 01 00000 00001 0000
#
## 
#
# Zero out AH
p 00 00000 00001 08D0
p 01 00000 00001 400F
p 01 00000 00001 00FF
#
# r0 = swap bytes
p 00 00000 00001 08D1
p 01 00000 00001 3999
p 01 00000 00001 0000
#
# AX = AX OR r0
p 00 00000 00001 08D2
p 01 00000 00001 5009
p 01 00000 00001 0000
#
# Return to calling code
p 00 00000 00001 08D3
p 01 00000 00001 1030
p 01 00000 00001 0000
#
#
## 
#
# Zero out CH
p 00 00000 00001 08D4
p 01 00000 00001 422F
p 01 00000 00001 00FF
#
# r0 = swap bytes
p 00 00000 00001 08D5
p 01 00000 00001 3999
p 01 00000 00001 0000
#
# CX = CX OR r0
p 00 00000 00001 08D6
p 01 00000 00001 5229
p 01 00000 00001 0000
#
# Return to calling code
p 00 00000 00001 08D7
p 01 00000 00001 1030
p 01 00000 00001 0000
#
#
## 
#
# Zero out DH
p 00 00000 00001 08D8
p 01 00000 00001 433F
p 01 00000 00001 00FF
#
# r0 = swap bytes
p 00 00000 00001 08D9
p 01 00000 00001 3999
p 01 00000 00001 0000
#
# DX = DX OR r0
p 00 00000 00001 08DA
p 01 00000 00001 5339
p 01 00000 00001 0000
#
# Return to calling code
p 00 00000 00001 08DB
p 01 00000 00001 1030
p 01 00000 00001 0000
#
#
## 
#
# Zero out BH
p 00 00000 00001 08DC
p 01 00000 00001 411F
p 01 00000 00001 00FF
#
# r0 = swap bytes
p 00 00000 00001 08DD
p 01 00000 00001 3999
p 01 00000 00001 0000
#
# BX = BX OR r0
p 00 00000 00001 08DE
p 01 00000 00001 5119
p 01 00000 00001 0000
#
# Return to calling code
p 00 00000 00001 08DF
p 01 00000 00001 1030
p 01 00000 00001 0000
#
#
#
## 
#
# AX = r0
p 00 00000 00001 08E0
p 01 00000 00001 509F
p 01 00000 00001 0000
#
# Return to calling code
p 00 00000 00001 08E1
p 01 00000 00001 1030
p 01 00000 00001 0000
#
## 
#
# CX = r0
p 00 00000 00001 08E4
p 01 00000 00001 529F
p 01 00000 00001 0000
#
# Return to calling code
p 00 00000 00001 08E5
p 01 00000 00001 1030
p 01 00000 00001 0000
#
## 
#
# DX = r0
p 00 00000 00001 08E8
p 01 00000 00001 539F
p 01 00000 00001 0000
#
# Return to calling code
p 00 00000 00001 08E9
p 01 00000 00001 1030
p 01 00000 00001 0000
#
## 
#
# BX = r0
p 00 00000 00001 08EC
p 01 00000 00001 519F
p 01 00000 00001 0000
#
# Return to calling code
p 00 00000 00001 08ED
p 01 00000 00001 1030
p 01 00000 00001 0000
#
## 
#
# SP = r0
p 00 00000 00001 08F0
p 01 00000 00001 549F
p 01 00000 00001 0000
#
# Return to calling code
p 00 00000 00001 08F1
p 01 00000 00001 1030
p 01 00000 00001 0000
#
## 
#
# BP = r0
p 00 00000 00001 08F4
p 01 00000 00001 559F
p 01 00000 00001 0000
#
# Return to calling code
p 00 00000 00001 08F5
p 01 00000 00001 1030
p 01 00000 00001 0000
#
## 
#
# SI = r0
p 00 00000 00001 08F8
p 01 00000 00001 569F
p 01 00000 00001 0000
#
# Return to calling code
p 00 00000 00001 08F9
p 01 00000 00001 1030
p 01 00000 00001 0000
#
## 
#
# DI = r0
p 00 00000 00001 08FC
p 01 00000 00001 579F
p 01 00000 00001 0000
#
# Return to calling code
p 00 00000 00001 08FD
p 01 00000 00001 1030
p 01 00000 00001 0000
#
#
# --------------------------------------------------------------------
#
# PROCEDURE - WRITEBACK_REG
#
# Writes r0 to a register.
#
# If a byte, then the upper byte or r0 will be zeroed out and merged into the register.
#
# CALL Address 0x0900 - Writeback Byte
# CALL Address 0x0901 - Writeback Word
#
# --------------------------------------------------------------------
#
# Zero the upper byte of r0 if a Byte operation
p 00 00000 00001 0900
p 01 00000 00001 499F
p 01 00000 00001 00FF
#
# Copy biu_register_reg value to the biu_dataout register
p 00 00000 00001 0901
p 01 00000 00001 5FF6
p 01 00000 00001 0000
#
# Jump-Type5 to register table at 0x08C0
p 00 00000 00001 0902
p 01 00000 00001 1150
p 01 00000 00001 0023
#
# Return to calling code
p 00 00000 00001 0903
p 01 00000 00001 1030
p 01 00000 00001 0000
#
#
#
# -----------------------------------------------------
#
#  0x08   OR - REG8/MEM8 , REG8
#
# -----------------------------------------------------
#
# CALL CALC_EA_BYTE
p 00 00000 00001 0906
p 01 00000 00001 1100
p 01 00000 00001 0760
#
# CALL FETCH_EA_BYTE into r0
p 00 00000 00001 0907
p 01 00000 00001 1100
p 01 00000 00001 0790
#
# r1 <= r0 - Move results held in r0 to r1
p 00 00000 00001 0908
p 01 00000 00001 5AF9
p 01 00000 00001 0000
#
# CALL FETCH_REG into r0
p 00 00000 00001 0909
p 01 00000 00001 1100
p 01 00000 00001 07D4
#
#
# Perform the ALU
# ----------------
#
# r0 = r0 OR r1
p 00 00000 00001 090A
p 01 00000 00001 599A
p 01 00000 00001 0000
#
# CALL CALCULATE_FLAGS_BYTE
p 00 00000 00001 090B
p 01 00000 00001 1100
p 01 00000 00001 0990
#
# Zero the CF and OF Flags
p 00 00000 00001 090C
p 01 00000 00001 488F
p 01 00000 00001 F7FE
#
# ----------------
#
# CALL WRITEBACK_EA_BYTE
p 00 00000 00001 090D
p 01 00000 00001 1100
p 01 00000 00001 07E0
#
# Strobe BIU - Fetch Opcode and set QS[1:0] to Subsequent Byte of Opcode 
p 00 00000 00001 090E
p 01 00000 00001 5DDF
p 01 00000 00001 100C
#
# Debounce BIU Strobe
p 00 00000 00001 090F
p 01 00000 00001 4DDF
p 01 00000 00001 CFF3
#
# Jump unconditional to main microcode loop
p 00 00000 00001 0910
p 01 00000 00001 1000
p 01 00000 00001 0004
#
#
# -----------------------------------------------------
#
#  0x09   OR - REG16/MEM16 , REG16 
#
# -----------------------------------------------------
#
# CALL CALC_EA_WORD
p 00 00000 00001 0915
p 01 00000 00001 1100
p 01 00000 00001 0762
#
# CALL FETCH_EA_WORD into r0
p 00 00000 00001 0916
p 01 00000 00001 1100
p 01 00000 00001 0792
#
# r1 <= r0 - Move results held in r0 to r1
p 00 00000 00001 0917
p 01 00000 00001 5AF9
p 01 00000 00001 0000
#
# CALL FETCH_REG into r0
p 00 00000 00001 0918
p 01 00000 00001 1100
p 01 00000 00001 07D4
#
#
# Perform the ALU
# ----------------
#
# r0 = r0 OR r1
p 00 00000 00001 0919
p 01 00000 00001 599A
p 01 00000 00001 0000
#
# CALL CALCULATE_FLAGS_WORD
p 00 00000 00001 091A
p 01 00000 00001 1100
p 01 00000 00001 03D3
#
# Zero the CF and OF Flags
p 00 00000 00001 091B
p 01 00000 00001 488F
p 01 00000 00001 F7FE
#
# ----------------
#
# CALL WRITEBACK_EA_WORD
p 00 00000 00001 091C
p 01 00000 00001 1100
p 01 00000 00001 07E2
#
# Strobe BIU - Fetch Opcode and set QS[1:0] to Subsequent Byte of Opcode 
p 00 00000 00001 091D
p 01 00000 00001 5DDF
p 01 00000 00001 100C
#
# Debounce BIU Strobe
p 00 00000 00001 091E
p 01 00000 00001 4DDF
p 01 00000 00001 CFF3
#
# Jump unconditional to main microcode loop
p 00 00000 00001 091F
p 01 00000 00001 1000
p 01 00000 00001 0004
#
#
#
# -----------------------------------------------------
#
# 0x0A   OR - REG8 , REG8/MEM8 
#
# -----------------------------------------------------
#
# CALL CALC_EA_BYTE
p 00 00000 00001 0924
p 01 00000 00001 1100
p 01 00000 00001 0760
#
# CALL FETCH_EA_BYTE into r0
p 00 00000 00001 0925
p 01 00000 00001 1100
p 01 00000 00001 0790
#
# r1 <= r0 - Move results held in r0 to r1
p 00 00000 00001 0926
p 01 00000 00001 5AF9
p 01 00000 00001 0000
#
# CALL FETCH_REG into r0
p 00 00000 00001 0927
p 01 00000 00001 1100
p 01 00000 00001 07D4
#
#
# Perform the ALU
# ----------------
#
# r0 = r0 OR r1
p 00 00000 00001 0928
p 01 00000 00001 599A
p 01 00000 00001 0000
#
# CALL CALCULATE_FLAGS_BYTE
p 00 00000 00001 0929
p 01 00000 00001 1100
p 01 00000 00001 0990
#
# Zero the CF and OF Flags
p 00 00000 00001 092A
p 01 00000 00001 488F
p 01 00000 00001 F7FE
#
# ----------------
#
# CALL WRITEBACK_REG_BYTE
p 00 00000 00001 092B
p 01 00000 00001 1100
p 01 00000 00001 0900
#
# Strobe BIU - Fetch Opcode and set QS[1:0] to Subsequent Byte of Opcode 
p 00 00000 00001 092C
p 01 00000 00001 5DDF
p 01 00000 00001 100C
#
# Debounce BIU Strobe
p 00 00000 00001 092D
p 01 00000 00001 4DDF
p 01 00000 00001 CFF3
#
# Jump unconditional to main microcode loop
p 00 00000 00001 092E
p 01 00000 00001 1000
p 01 00000 00001 0004
#
#
#
# -----------------------------------------------------
#
# 0x0B   OR - REG16 , REG16/MEM16 
#
# -----------------------------------------------------
#
# CALL CALC_EA_WORD
p 00 00000 00001 0933
p 01 00000 00001 1100
p 01 00000 00001 0762
#
# CALL FETCH_EA_WORD into r0
p 00 00000 00001 0934
p 01 00000 00001 1100
p 01 00000 00001 0792
#
# r1 <= r0 - Move results held in r0 to r1
p 00 00000 00001 0935
p 01 00000 00001 5AF9
p 01 00000 00001 0000
#
# CALL FETCH_REG into r0
p 00 00000 00001 0936
p 01 00000 00001 1100
p 01 00000 00001 07D4
#
#
# Perform the ALU
# ----------------
#
# r0 = r0 OR r1
p 00 00000 00001 0937
p 01 00000 00001 599A
p 01 00000 00001 0000
#
# CALL CALCULATE_FLAGS_WORD
p 00 00000 00001 0938
p 01 00000 00001 1100
p 01 00000 00001 03D3
#
# Zero the CF and OF Flags
p 00 00000 00001 0939
p 01 00000 00001 488F
p 01 00000 00001 F7FE
#
# ----------------
#
# CALL WRITEBACK_REG_WORD
p 00 00000 00001 093A
p 01 00000 00001 1100
p 01 00000 00001 0901
#
# Strobe BIU - Fetch Opcode and set QS[1:0] to Subsequent Byte of Opcode 
p 00 00000 00001 093B
p 01 00000 00001 5DDF
p 01 00000 00001 100C
#
# Debounce BIU Strobe
p 00 00000 00001 093C
p 01 00000 00001 4DDF
p 01 00000 00001 CFF3
#
# Jump unconditional to main microcode loop
p 00 00000 00001 093D
p 01 00000 00001 1000
p 01 00000 00001 0004
#
#
#
# -----------------------------------------------------
#
# 0x0C   OR - AL,IMM8 
#
# -----------------------------------------------------
#
# CALL Fetch byte from prefetch queue with QS=Initial opcode byte into r3
p 00 00000 00001 0940
p 01 00000 00001 1100
p 01 00000 00001 02A0
#
# AX <= AX OR r3
p 00 00000 00001 0941
p 01 00000 00001 500C
p 01 00000 00001 0000
#
# CALL CALCULATE_FLAGS_BYTE
p 00 00000 00001 0942
p 01 00000 00001 1100
p 01 00000 00001 0990
#
# Zero the CF and OF Flags
p 00 00000 00001 0943
p 01 00000 00001 488F
p 01 00000 00001 F7FE
#
# Write to clock counter to equal 4 clocks for this instruction
p 00 00000 00001 0944
p 01 00000 00001 5FFF
p 01 00000 00001 C020
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0945
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Jump unconditional to queue strobe and ending
p 00 00000 00001 0946
p 01 00000 00001 1000
p 01 00000 00001 093B
#
#
# -----------------------------------------------------
#
# 0x0D   OR - AX,IMM16 
#
# -----------------------------------------------------
#
# CALL Fetch word from prefetch queue with QS=Initial opcode byte into r3
p 00 00000 00001 0947
p 01 00000 00001 1100
p 01 00000 00001 02E0
#
# AX <= AX OR r3
p 00 00000 00001 0948
p 01 00000 00001 500C
p 01 00000 00001 0000
#
# CALL CALCULATE_FLAGS_WORD
p 00 00000 00001 0949
p 01 00000 00001 1100
p 01 00000 00001 03D3
#
# Jump unconditional to common code
p 00 00000 00001 094A
p 01 00000 00001 1000
p 01 00000 00001 0943
#
#
#
# -----------------------------------------------------
#
#  0x30   XOR - REG8/MEM8 , REG8 
#
# -----------------------------------------------------
#
# CALL CALC_EA_BYTE
p 00 00000 00001 0950
p 01 00000 00001 1100
p 01 00000 00001 0760
#
# CALL FETCH_EA_BYTE into r0
p 00 00000 00001 0951
p 01 00000 00001 1100
p 01 00000 00001 0790
#
# r1 <= r0 - Move results held in r0 to r1
p 00 00000 00001 0952
p 01 00000 00001 5AF9
p 01 00000 00001 0000
#
# CALL FETCH_REG into r0
p 00 00000 00001 0953
p 01 00000 00001 1100
p 01 00000 00001 07D4
#
#
# Perform the ALU
# ----------------
#
# r0 = r0 XOR r1
p 00 00000 00001 0954
p 01 00000 00001 699A
p 01 00000 00001 0000
#
# Jump unconditional to common code
p 00 00000 00001 0955
p 01 00000 00001 1000
p 01 00000 00001 090B
#
#
# -----------------------------------------------------
#
#  0x31   XOR - REG16/MEM16 , REG16 
#
# -----------------------------------------------------
#
# CALL CALC_EA_WORD
p 00 00000 00001 0956
p 01 00000 00001 1100
p 01 00000 00001 0762
#
# CALL FETCH_EA_WORD into r0
p 00 00000 00001 0957
p 01 00000 00001 1100
p 01 00000 00001 0792
#
# r1 <= r0 - Move results held in r0 to r1
p 00 00000 00001 0958
p 01 00000 00001 5AF9
p 01 00000 00001 0000
#
# CALL FETCH_REG into r0
p 00 00000 00001 0959
p 01 00000 00001 1100
p 01 00000 00001 07D4
#
#
# Perform the ALU
# ----------------
#
# r0 = r0 XOR r1
p 00 00000 00001 095A
p 01 00000 00001 699A
p 01 00000 00001 0000
#
# Jump unconditional to common code
p 00 00000 00001 095B
p 01 00000 00001 1000
p 01 00000 00001 091A
#
#
# -----------------------------------------------------
#
# 0x32   XOR - REG8 , REG8/MEM8 
#
# -----------------------------------------------------
#
# CALL CALC_EA_BYTE
p 00 00000 00001 095C
p 01 00000 00001 1100
p 01 00000 00001 0760
#
# CALL FETCH_EA_BYTE into r0
p 00 00000 00001 095D
p 01 00000 00001 1100
p 01 00000 00001 0790
#
# r1 <= r0 - Move results held in r0 to r1
p 00 00000 00001 095E
p 01 00000 00001 5AF9
p 01 00000 00001 0000
#
# CALL FETCH_REG into r0
p 00 00000 00001 095F
p 01 00000 00001 1100
p 01 00000 00001 07D4
#
#
# Perform the ALU
# ----------------
#
# r0 = r0 XOR r1
p 00 00000 00001 0960
p 01 00000 00001 699A
p 01 00000 00001 0000
#
# Jump unconditional to common code
p 00 00000 00001 0961
p 01 00000 00001 1000
p 01 00000 00001 0929
#
#
# -----------------------------------------------------
#
# 0x33   XOR - REG16 , REG16/MEM16 
#
# -----------------------------------------------------
#
# CALL CALC_EA_WORD
p 00 00000 00001 0962
p 01 00000 00001 1100
p 01 00000 00001 0762
#
# CALL FETCH_EA_WORD into r0
p 00 00000 00001 0963
p 01 00000 00001 1100
p 01 00000 00001 0792
#
# r1 <= r0 - Move results held in r0 to r1
p 00 00000 00001 0964
p 01 00000 00001 5AF9
p 01 00000 00001 0000
#
# CALL FETCH_REG into r0
p 00 00000 00001 0965
p 01 00000 00001 1100
p 01 00000 00001 07D4
#
#
# Perform the ALU
# ----------------
#
# r0 = r0 XOR r1
p 00 00000 00001 0966
p 01 00000 00001 699A
p 01 00000 00001 0000
#
# Jump unconditional to common code
p 00 00000 00001 0967
p 01 00000 00001 1000
p 01 00000 00001 0938
#
#
# -----------------------------------------------------
#
# 0x34   XOR - AL,IMM8 
#
# -----------------------------------------------------
#
# CALL Fetch byte from prefetch queue with QS=Initial opcode byte into r3
p 00 00000 00001 0968
p 01 00000 00001 1100
p 01 00000 00001 02A0
#
# AX <= AX XOR r3
p 00 00000 00001 0969
p 01 00000 00001 600C
p 01 00000 00001 0000
#
# Jump unconditional to common code
p 00 00000 00001 096A
p 01 00000 00001 1000
p 01 00000 00001 0942
#
#
#
# -----------------------------------------------------
#
# 0x35   XOR - AX,IMM16 
#
# -----------------------------------------------------
#
# CALL Fetch word from prefetch queue with QS=Initial opcode byte into r3
p 00 00000 00001 096B
p 01 00000 00001 1100
p 01 00000 00001 02E0
#
# AX <= AX XOR r3
p 00 00000 00001 096C
p 01 00000 00001 600C
p 01 00000 00001 0000
#
# Jump unconditional to common code
p 00 00000 00001 096D
p 01 00000 00001 1000
p 01 00000 00001 0949
#
#
#
# -----------------------------------------------------
#
#  0x20   AND - REG8/MEM8 , REG8 
#
# -----------------------------------------------------
#
# CALL CALC_EA_BYTE
p 00 00000 00001 0970
p 01 00000 00001 1100
p 01 00000 00001 0760
#
# CALL FETCH_EA_BYTE into r0
p 00 00000 00001 0971
p 01 00000 00001 1100
p 01 00000 00001 0790
#
# r1 <= r0 - Move results held in r0 to r1
p 00 00000 00001 0972
p 01 00000 00001 5AF9
p 01 00000 00001 0000
#
# CALL FETCH_REG into r0
p 00 00000 00001 0973
p 01 00000 00001 1100
p 01 00000 00001 07D4
#
#
# Perform the ALU
# ----------------
#
# r0 = r0 AND r1
p 00 00000 00001 0974
p 01 00000 00001 499A
p 01 00000 00001 0000
#
# Jump unconditional to common code
p 00 00000 00001 0975
p 01 00000 00001 1000
p 01 00000 00001 090B
#
#
# -----------------------------------------------------
#
#  0x21   AND - REG16/MEM16 , REG16 
#
# -----------------------------------------------------
#
# CALL CALC_EA_WORD
p 00 00000 00001 0976
p 01 00000 00001 1100
p 01 00000 00001 0762
#
# CALL FETCH_EA_WORD into r0
p 00 00000 00001 0977
p 01 00000 00001 1100
p 01 00000 00001 0792
#
# r1 <= r0 - Move results held in r0 to r1
p 00 00000 00001 0978
p 01 00000 00001 5AF9
p 01 00000 00001 0000
#
# CALL FETCH_REG into r0
p 00 00000 00001 0979
p 01 00000 00001 1100
p 01 00000 00001 07D4
#
#
# Perform the ALU
# ----------------
#
# r0 = r0 AND r1
p 00 00000 00001 097A
p 01 00000 00001 499A
p 01 00000 00001 0000
#
# Jump unconditional to common code
p 00 00000 00001 097B
p 01 00000 00001 1000
p 01 00000 00001 091A
#
#
# -----------------------------------------------------
#
# 0x22   AND - REG8 , REG8/MEM8 
#
# -----------------------------------------------------
#
# CALL CALC_EA_BYTE
p 00 00000 00001 097C
p 01 00000 00001 1100
p 01 00000 00001 0760
#
# CALL FETCH_EA_BYTE into r0
p 00 00000 00001 097D
p 01 00000 00001 1100
p 01 00000 00001 0790
#
# r1 <= r0 - Move results held in r0 to r1
p 00 00000 00001 097E
p 01 00000 00001 5AF9
p 01 00000 00001 0000
#
# CALL FETCH_REG into r0
p 00 00000 00001 097F
p 01 00000 00001 1100
p 01 00000 00001 07D4
#
#
# Perform the ALU
# ----------------
#
# r0 = r0 AND r1
p 00 00000 00001 0980
p 01 00000 00001 499A
p 01 00000 00001 0000
#
# Jump unconditional to common code
p 00 00000 00001 0981
p 01 00000 00001 1000
p 01 00000 00001 0929
#
#
#
# -----------------------------------------------------
#
# 0x23   AND - REG16 , REG16/MEM16 
#
# -----------------------------------------------------
#
# CALL CALC_EA_WORD
p 00 00000 00001 0982
p 01 00000 00001 1100
p 01 00000 00001 0762
#
# CALL FETCH_EA_WORD into r0
p 00 00000 00001 0983
p 01 00000 00001 1100
p 01 00000 00001 0792
#
# r1 <= r0 - Move results held in r0 to r1
p 00 00000 00001 0984
p 01 00000 00001 5AF9
p 01 00000 00001 0000
#
# CALL FETCH_REG into r0
p 00 00000 00001 0985
p 01 00000 00001 1100
p 01 00000 00001 07D4
#
#
# Perform the ALU
# ----------------
#
# r0 = r0 AND r1
p 00 00000 00001 0986
p 01 00000 00001 499A
p 01 00000 00001 0000
#
# Jump unconditional to common code
p 00 00000 00001 0987
p 01 00000 00001 1000
p 01 00000 00001 0938
#
#
#
# -----------------------------------------------------
#
# 0x25   AND - AX,IMM16 
#
# -----------------------------------------------------
#
# CALL Fetch word from prefetch queue with QS=Initial opcode byte into r3
p 00 00000 00001 098B
p 01 00000 00001 1100
p 01 00000 00001 02E0
#
# AX <= AX AND r3
p 00 00000 00001 098C
p 01 00000 00001 400C
p 01 00000 00001 0000
#
# Jump unconditional to common code
p 00 00000 00001 098D
p 01 00000 00001 1000
p 01 00000 00001 0949
#
#
# -----------------------------------------------------
#
# PROCEDURE - Calculate All Flags for BYTES
#
# Input is assumed to be in the alu_last_result or r2
# Bit[8] of alu_last_result assumed to be the Carry8
#
# Destroys r2 and r3
#
# * Jump to 0x0992 to not zero out the flag bits.
#
# -----------------------------------------------------
#
#
# Calculate the S Flag
#
# r2 <= last_alu result
p 00 00000 00001 0990
p 01 00000 00001 5BFD
p 01 00000 00001 0000
#
# Zero out the O, A, P, Z, S, C bit fields in Flag register
p 00 00000 00001 0991
p 01 00000 00001 488F
p 01 00000 00001 F72A
#
# Isolate Bit[7] from r2 into Dummy
p 00 00000 00001 0992
p 01 00000 00001 4EBF
p 01 00000 00001 0080
#
# if alu_last_result is zero then jump over next instruction
p 00 00000 00001 0993
p 01 00000 00001 1002
p 01 00000 00001 0995
#
# Set the Sign Flag bit to a 1
p 00 00000 00001 0994
p 01 00000 00001 588F
p 01 00000 00001 0080
#
#
# Calculate the A, P flags
#
# Store r2 to r2 to make r2 the last_alu result
p 00 00000 00001 0995
p 01 00000 00001 5BFB
p 01 00000 00001 0000
#
# Isolate the A and P flags from System Signals into r3 using AND
p 00 00000 00001 0996
p 01 00000 00001 4CEF
p 01 00000 00001 0014
#
# Merge r3 into the Flags register using OR
p 00 00000 00001 0997
p 01 00000 00001 588C
p 01 00000 00001 0000
#
#
# Calculate the O flag
#
# Isolate the Overflow8 flag from System Signals into r3 
p 00 00000 00001 0998
p 01 00000 00001 4CEF
p 01 00000 00001 0200
#
# if alu_last_result is zero then jump over next instruction
p 00 00000 00001 0999
p 01 00000 00001 1002
p 01 00000 00001 099B
#
# Set the Overflow Flag bit to a 1
p 00 00000 00001 099A
p 01 00000 00001 588F
p 01 00000 00001 0800
#
# Calculate the C flag
#
# Isolate the System Signals[13] which is the Carry8 signal into Dummy
p 00 00000 00001 099B
p 01 00000 00001 4EEF
p 01 00000 00001 2000
#
# if alu_last_result is zero then jump over next instruction
p 00 00000 00001 099C
p 01 00000 00001 1002
p 01 00000 00001 099E
#
# Set the Carry Flag bit to a 1
p 00 00000 00001 099D
p 01 00000 00001 588F
p 01 00000 00001 0001
#
# Calculate the Z Flag
#
# r2 <= r2 AND 00FF to zero out the upper byte
p 00 00000 00001 099E
p 01 00000 00001 4BBF
p 01 00000 00001 00FF
#
# if alu_last_result is not zero then jump to end
p 00 00000 00001 099F
p 01 00000 00001 1001
p 01 00000 00001 09A1
#
# Set the Zero Flag bit to a 1
p 00 00000 00001 09A0
p 01 00000 00001 588F
p 01 00000 00001 0040
#
# Return to calling address
p 00 00000 00001 09A1
p 01 00000 00001 1030
p 01 00000 00001 0000
#
#
# -----------------------------------------------------
#
#  0x00   ADD - REG8/MEM8 , REG8  
#
# -----------------------------------------------------
#
# CALL CALC_EA_BYTE
p 00 00000 00001 09A6
p 01 00000 00001 1100
p 01 00000 00001 0760
#
# CALL FETCH_EA_BYTE into r0
p 00 00000 00001 09A7
p 01 00000 00001 1100
p 01 00000 00001 0790
#
# r1 <= r0 - Move results held in r0 to r1
p 00 00000 00001 09A8
p 01 00000 00001 5AF9
p 01 00000 00001 0000
#
# CALL FETCH_REG into r0
p 00 00000 00001 09A9
p 01 00000 00001 1100
p 01 00000 00001 07D4
#
#
# Perform the ALU
# ----------------
#
# CALL ADD_BYTE
p 00 00000 00001 09AA
p 01 00000 00001 1100
p 01 00000 00001 09C9
#
# Jump unconditional to common code
p 00 00000 00001 09AB
p 01 00000 00001 1000
p 01 00000 00001 090D
#
#
# -----------------------------------------------------
#
#  0x01   ADD - REG16/MEM16 , REG16 
#
# -----------------------------------------------------
#
# CALL CALC_EA_WORD
p 00 00000 00001 09AC
p 01 00000 00001 1100
p 01 00000 00001 0762
#
# CALL FETCH_EA_WORD into r0
p 00 00000 00001 09AD
p 01 00000 00001 1100
p 01 00000 00001 0792
#
# r1 <= r0 - Move results held in r0 to r1
p 00 00000 00001 09AE
p 01 00000 00001 5AF9
p 01 00000 00001 0000
#
# CALL FETCH_REG into r0
p 00 00000 00001 09AF
p 01 00000 00001 1100
p 01 00000 00001 07D4
#
#
# Perform the ALU
# ----------------
#
# CALL ADD_WORD
p 00 00000 00001 09B0
p 01 00000 00001 1100
p 01 00000 00001 09CC
#
# Jump unconditional to common code
p 00 00000 00001 09B1
p 01 00000 00001 1000
p 01 00000 00001 091C
#
#
# -----------------------------------------------------
#
# 0x02   ADD - REG8 , REG8/MEM8 
#
# -----------------------------------------------------
#
# CALL CALC_EA_BYTE
p 00 00000 00001 09B2
p 01 00000 00001 1100
p 01 00000 00001 0760
#
# CALL FETCH_EA_BYTE into r0
p 00 00000 00001 09B3
p 01 00000 00001 1100
p 01 00000 00001 0790
#
# r1 <= r0 - Move results held in r0 to r1
p 00 00000 00001 09B4
p 01 00000 00001 5AF9
p 01 00000 00001 0000
#
# CALL FETCH_REG into r0
p 00 00000 00001 09B5
p 01 00000 00001 1100
p 01 00000 00001 07D4
#
#
# Perform the ALU
# ----------------
#
# CALL ADD_BYTE
p 00 00000 00001 09B6
p 01 00000 00001 1100
p 01 00000 00001 09C9
#
# Jump unconditional to common code
p 00 00000 00001 09B7
p 01 00000 00001 1000
p 01 00000 00001 092B
#
#
#
# -----------------------------------------------------
#
# 0x03   ADD - REG16 , REG16/MEM16 
#
# -----------------------------------------------------
#
# CALL CALC_EA_WORD
p 00 00000 00001 09B8
p 01 00000 00001 1100
p 01 00000 00001 0762
#
# CALL FETCH_EA_WORD into r0
p 00 00000 00001 09B9
p 01 00000 00001 1100
p 01 00000 00001 0792
#
# r1 <= r0 - Move results held in r0 to r1
p 00 00000 00001 09BA
p 01 00000 00001 5AF9
p 01 00000 00001 0000
#
# CALL FETCH_REG into r0
p 00 00000 00001 09BB
p 01 00000 00001 1100
p 01 00000 00001 07D4
#
#
# Perform the ALU
# ----------------
#
# CALL ADD_WORD
p 00 00000 00001 09BC
p 01 00000 00001 1100
p 01 00000 00001 09CC
#
# Jump unconditional to common code
p 00 00000 00001 09BD
p 01 00000 00001 1000
p 01 00000 00001 093A
#
#
# -----------------------------------------------------
#
# 0x04   ADD - AL,IMM8 
#
# -----------------------------------------------------
#
# CALL Fetch byte from prefetch queue with QS=Initial opcode byte into r3
p 00 00000 00001 09BE
p 01 00000 00001 1100
p 01 00000 00001 02A0
#
# r0 <= AX + r3
p 00 00000 00001 09BF
p 01 00000 00001 290C
p 01 00000 00001 0000
#
# CALL CALCULATE_FLAGS_BYTE
p 00 00000 00001 09C0
p 01 00000 00001 1100
p 01 00000 00001 0990
#
# Jump unconditional to common code
p 00 00000 00001 09C1
p 01 00000 00001 1000
p 01 00000 00001 09EE
#
#
#
# -----------------------------------------------------
#
# 0x05   ADD - AX,IMM16 
#
# -----------------------------------------------------
#
# CALL Fetch word from prefetch queue with QS=Initial opcode byte into r3
p 00 00000 00001 09C2
p 01 00000 00001 1100
p 01 00000 00001 02E0
#
# AX <= AX + r3
p 00 00000 00001 09C3
p 01 00000 00001 200C
p 01 00000 00001 0000
#
# CALL CALCULATE_FLAGS_WORD
p 00 00000 00001 09C4
p 01 00000 00001 1100
p 01 00000 00001 03D3
#
# Jump unconditional to common code
p 00 00000 00001 09C5
p 01 00000 00001 1000
p 01 00000 00001 0944
#
#
#
# -----------------------------------------------------
#
# PROCEDURE - ADD for Bytes
#
# r0 = r0 + r1
# All Byte Flags are then calculated
#
# -----------------------------------------------------
#
# r0 = r0 + r1
p 00 00000 00001 09C9
p 01 00000 00001 299A
p 01 00000 00001 0000
#
# CALL CALCULATE_FLAGS_BYTE
p 00 00000 00001 09CA
p 01 00000 00001 1100
p 01 00000 00001 0990
#
# Return to calling code
p 00 00000 00001 09CB
p 01 00000 00001 1030
p 01 00000 00001 0000
#
#
# -----------------------------------------------------
#
# PROCEDURE - ADD for Words
#
# r0 = r0 + r1
# All Word Flags are then calculated
#
# -----------------------------------------------------
#
# r0 = r0 + r1
p 00 00000 00001 09CC
p 01 00000 00001 299A
p 01 00000 00001 0000
#
# CALL CALCULATE_FLAGS_WORD
p 00 00000 00001 09CD
p 01 00000 00001 1100
p 01 00000 00001 03D3
#
# Return to calling code
p 00 00000 00001 09CE
p 01 00000 00001 1030
p 01 00000 00001 0000
#
#
# -----------------------------------------------------
#
#  0x10   ADC - REG8/MEM8 , REG8 
#
# -----------------------------------------------------
#
# CALL CALC_EA_BYTE
p 00 00000 00001 09D2
p 01 00000 00001 1100
p 01 00000 00001 0760
#
# CALL FETCH_EA_BYTE into r0
p 00 00000 00001 09D3
p 01 00000 00001 1100
p 01 00000 00001 0790
#
# r1 <= r0 - Move results held in r0 to r1
p 00 00000 00001 09D4
p 01 00000 00001 5AF9
p 01 00000 00001 0000
#
# CALL FETCH_REG into r0
p 00 00000 00001 09D5
p 01 00000 00001 1100
p 01 00000 00001 07D4
#
#
# Perform the ALU
# ----------------
#
# CALL ADC_BYTE
p 00 00000 00001 09D6
p 01 00000 00001 1100
p 01 00000 00001 0A03
#
# Jump unconditional to common code
p 00 00000 00001 09D7
p 01 00000 00001 1000
p 01 00000 00001 090D
#
#
# -----------------------------------------------------
#
#  0x11   ADC - REG16/MEM16 , REG16 
#
# -----------------------------------------------------
#
# CALL CALC_EA_WORD
p 00 00000 00001 09D8
p 01 00000 00001 1100
p 01 00000 00001 0762
#
# CALL FETCH_EA_WORD into r0
p 00 00000 00001 09D9
p 01 00000 00001 1100
p 01 00000 00001 0792
#
# r1 <= r0 - Move results held in r0 to r1
p 00 00000 00001 09DA
p 01 00000 00001 5AF9
p 01 00000 00001 0000
#
# CALL FETCH_REG into r0
p 00 00000 00001 09DB
p 01 00000 00001 1100
p 01 00000 00001 07D4
#
#
# Perform the ALU
# ----------------
#
# CALL ADC_WORD
p 00 00000 00001 09DC
p 01 00000 00001 1100
p 01 00000 00001 0A12
#
# Jump unconditional to common code
p 00 00000 00001 09DD
p 01 00000 00001 1000
p 01 00000 00001 091C
#
#
# -----------------------------------------------------
#
# 0x12   ADC - REG8 , REG8/MEM8 
#
# -----------------------------------------------------
#
# CALL CALC_EA_BYTE
p 00 00000 00001 09DE
p 01 00000 00001 1100
p 01 00000 00001 0760
#
# CALL FETCH_EA_BYTE into r0
p 00 00000 00001 09DF
p 01 00000 00001 1100
p 01 00000 00001 0790
#
# r1 <= r0 - Move results held in r0 to r1
p 00 00000 00001 09E0
p 01 00000 00001 5AF9
p 01 00000 00001 0000
#
# CALL FETCH_REG into r0
p 00 00000 00001 09E1
p 01 00000 00001 1100
p 01 00000 00001 07D4
#
#
# Perform the ALU
# ----------------
#
# CALL ADC_BYTE 
p 00 00000 00001 09E2
p 01 00000 00001 1100
p 01 00000 00001 0A03
#
# Jump unconditional to common code
p 00 00000 00001 09E3
p 01 00000 00001 1000
p 01 00000 00001 092B
#
#
#
# -----------------------------------------------------
#
# 0x13   ADC - REG16 , REG16/MEM16 
#
# -----------------------------------------------------
#
# CALL CALC_EA_WORD
p 00 00000 00001 09E4
p 01 00000 00001 1100
p 01 00000 00001 0762
#
# CALL FETCH_EA_WORD into r0
p 00 00000 00001 09E5
p 01 00000 00001 1100
p 01 00000 00001 0792
#
# r1 <= r0 - Move results held in r0 to r1
p 00 00000 00001 09E6
p 01 00000 00001 5AF9
p 01 00000 00001 0000
#
# CALL FETCH_REG into r0
p 00 00000 00001 09E7
p 01 00000 00001 1100
p 01 00000 00001 07D4
#
#
# Perform the ALU
# ----------------
#
# CALL ADC_WORD
p 00 00000 00001 09E8
p 01 00000 00001 1100
p 01 00000 00001 0A12
#
# Jump unconditional to common code
p 00 00000 00001 09E9
p 01 00000 00001 1000
p 01 00000 00001 093A
#
#
# -----------------------------------------------------
#
# 0x14   ADC - AL,IMM8 
#
# -----------------------------------------------------
#
# CALL Fetch byte from prefetch queue with QS=Initial opcode byte into r3
p 00 00000 00001 09EA
p 01 00000 00001 1100
p 01 00000 00001 02A0
#
# r0 = AX
p 00 00000 00001 09EB
p 01 00000 00001 590F
p 01 00000 00001 0000
#
# r1 = r3
p 00 00000 00001 09EC
p 01 00000 00001 5ACF
p 01 00000 00001 0000
#
# CALL ADC_BYTE
p 00 00000 00001 09ED
p 01 00000 00001 1100
p 01 00000 00001 0A03
#
# Zero out upper byte of r0
p 00 00000 00001 09EE
p 01 00000 00001 499F
p 01 00000 00001 00FF
#
# Zero out AL 
p 00 00000 00001 09EF
p 01 00000 00001 400F
p 01 00000 00001 FF00
#
# AX = AH or r0 - Merge AH with r0 results
p 00 00000 00001 09F0
p 01 00000 00001 5009
p 01 00000 00001 0000
#
# Jump unconditional to common code
p 00 00000 00001 09F1
p 01 00000 00001 1000
p 01 00000 00001 0944
#
#
# -----------------------------------------------------
#
# 0x15   ADC - AX,IMM16 
#
# -----------------------------------------------------
#
# CALL Fetch word from prefetch queue with QS=Initial opcode byte into r3
p 00 00000 00001 09F4
p 01 00000 00001 1100
p 01 00000 00001 02E0
#
# r0 = AX
p 00 00000 00001 09F5
p 01 00000 00001 590F
p 01 00000 00001 0000
#
# r1 = r3
p 00 00000 00001 09F6
p 01 00000 00001 5ACF
p 01 00000 00001 0000
#
# CALL ADC_WORD
p 00 00000 00001 09F7
p 01 00000 00001 1100
p 01 00000 00001 0A12
#
# AX = r0
p 00 00000 00001 09F8
p 01 00000 00001 50F9
p 01 00000 00001 0000
#
# Jump unconditional to common code
p 00 00000 00001 09F9
p 01 00000 00001 1000
p 01 00000 00001 0944
#
#
# -----------------------------------------------------
#
# 0x24   AND - AL,IMM8 
#
# -----------------------------------------------------
#
# CALL Fetch byte from prefetch queue with QS=Initial opcode byte into r3
p 00 00000 00001 09FD
p 01 00000 00001 1100
p 01 00000 00001 02A0
#
# r3 <= r3 or FF00 - Fill the upper byte with 1's so the following AND will have no affect
p 00 00000 00001 09FE
p 01 00000 00001 5CCF
p 01 00000 00001 FF00
#
# AX <= AX AND r3
p 00 00000 00001 09FF
p 01 00000 00001 400C
p 01 00000 00001 0000
#
# CALL CALCULATE_FLAGS_BYTE
p 00 00000 00001 0A00
p 01 00000 00001 1100
p 01 00000 00001 0990
#
# Jump unconditional to common code
p 00 00000 00001 0A01
p 01 00000 00001 1000
p 01 00000 00001 0943
#
# -----------------------------------------------------
#
# PROCEDURE - ADC for Bytes
#
# r0 = r0 + r1 + C
# All Byte Flags are then calculated
#
# -----------------------------------------------------
#
# Isolate Carry flags bit[0] into r3
p 00 00000 00001 0A03
p 01 00000 00001 4C8F
p 01 00000 00001 0001
#
# r0 = r0 + r3 
p 00 00000 00001 0A04
p 01 00000 00001 299C
p 01 00000 00001 0000
#
# CALL CALCULATE_FLAGS_BYTE
p 00 00000 00001 0A05
p 01 00000 00001 1100
p 01 00000 00001 0990
#
# r0 = r0 + r1
p 00 00000 00001 0A06
p 01 00000 00001 299A
p 01 00000 00001 0000
#
# r2 <= last_alu result - This is done to prepare for flag calculation
p 00 00000 00001 0A07
p 01 00000 00001 5BFD
p 01 00000 00001 0000
#
# Zero out the P, Z, S bit fields in Flag register in case they were set by intermediate result
p 00 00000 00001 0A08
p 01 00000 00001 488F
p 01 00000 00001 FF3B
#
# CALL CALCULATE_FLAGS_BYTE_NO_FLAGS_ZEROING
p 00 00000 00001 0A09
p 01 00000 00001 1100
p 01 00000 00001 0992
#
# Return to calling code
p 00 00000 00001 0A0A
p 01 00000 00001 1030
p 01 00000 00001 0000
#
#
# -----------------------------------------------------
#
# PROCEDURE - ADC for Words
#
# r0 = r0 + r1 + C
# All Word Flags are then calculated
#
# -----------------------------------------------------
#
# Isolate Carry flags bit[0] into r3
p 00 00000 00001 0A12
p 01 00000 00001 4C8F
p 01 00000 00001 0001
#
# r0 = r0 + r3
p 00 00000 00001 0A13
p 01 00000 00001 299C
p 01 00000 00001 0000
#
# CALL CALCULATE_FLAGS_WORD
p 00 00000 00001 0A14
p 01 00000 00001 1100
p 01 00000 00001 03D3
#
# r0 = r0 + r1
p 00 00000 00001 0A15
p 01 00000 00001 299A
p 01 00000 00001 0000
#
# r2 <= last_alu result - This is done to prepare for flag calculation
p 00 00000 00001 0A16
p 01 00000 00001 5BFD
p 01 00000 00001 0000
#
# Zero out the P, Z, S bit fields in Flag register in case they were set by intermediate result
p 00 00000 00001 0A17
p 01 00000 00001 488F
p 01 00000 00001 FF3B
#
# CALL CALCULATE_FLAGS_WORD_NO_FLAGS_ZEROING
p 00 00000 00001 0A18
p 01 00000 00001 1100
p 01 00000 00001 03D5
#
# Return to calling code
p 00 00000 00001 0A19
p 01 00000 00001 1030
p 01 00000 00001 0000
#
#
# -----------------------------------------------------
#
#  0x28   SUB - REG8/MEM8 , REG8
#
# -----------------------------------------------------
#
# CALL CALC_EA_BYTE
p 00 00000 00001 0A20
p 01 00000 00001 1100
p 01 00000 00001 0760
#
# CALL FETCH_REG into r0
p 00 00000 00001 0A21
p 01 00000 00001 1100
p 01 00000 00001 07D4
#
# r1 <= r0 - Move results held in r0 to r1
p 00 00000 00001 0A22
p 01 00000 00001 5AF9
p 01 00000 00001 0000
#
# CALL FETCH_EA_BYTE into r0
p 00 00000 00001 0A23
p 01 00000 00001 1100
p 01 00000 00001 0790
#
#
# Perform the ALU
# ----------------
#
# CALL SUB_BYTE
p 00 00000 00001 0A24
p 01 00000 00001 1100
p 01 00000 00001 0A46
#
# Jump unconditional to common code
p 00 00000 00001 0A25
p 01 00000 00001 1000
p 01 00000 00001 090D
#
#
# -----------------------------------------------------
#
#  0x29   SUB - REG16/MEM16 , REG16 
#
# -----------------------------------------------------
#
# CALL CALC_EA_WORD
p 00 00000 00001 0A26
p 01 00000 00001 1100
p 01 00000 00001 0762
#
# CALL FETCH_REG into r0
p 00 00000 00001 0A27
p 01 00000 00001 1100
p 01 00000 00001 07D4
#
# r1 <= r0 - Move results held in r0 to r1
p 00 00000 00001 0A28
p 01 00000 00001 5AF9
p 01 00000 00001 0000
#
# CALL FETCH_EA_WORD into r0
p 00 00000 00001 0A29
p 01 00000 00001 1100
p 01 00000 00001 0792
#
#
# Perform the ALU
# ----------------
#
# CALL SUB_WORD
p 00 00000 00001 0A2A
p 01 00000 00001 1100
p 01 00000 00001 0A52
#
# Jump unconditional to common code
p 00 00000 00001 0A2B
p 01 00000 00001 1000
p 01 00000 00001 091C
#
#
# -----------------------------------------------------
#
# 0x2A   SUB - REG8 , REG8/MEM8 
#
# -----------------------------------------------------
#
# CALL CALC_EA_BYTE
p 00 00000 00001 0A2C
p 01 00000 00001 1100
p 01 00000 00001 0760
#
# CALL FETCH_EA_BYTE into r0
p 00 00000 00001 0A2D
p 01 00000 00001 1100
p 01 00000 00001 0790
#
# r1 <= r0 - Move results held in r0 to r1
p 00 00000 00001 0A2E
p 01 00000 00001 5AF9
p 01 00000 00001 0000
#
# CALL FETCH_REG into r0
p 00 00000 00001 0A2F
p 01 00000 00001 1100
p 01 00000 00001 07D4
#
#
# Perform the ALU
# ----------------
#
# CALL SUB_BYTE
p 00 00000 00001 0A30
p 01 00000 00001 1100
p 01 00000 00001 0A46
#
# Jump unconditional to common code
p 00 00000 00001 0A31
p 01 00000 00001 1000
p 01 00000 00001 092B
#
#
# -----------------------------------------------------
#
# 0x2B   SUB - REG16 , REG16/MEM16 
#
# -----------------------------------------------------
#
# CALL CALC_EA_WORD
p 00 00000 00001 0A32
p 01 00000 00001 1100
p 01 00000 00001 0762
#
# CALL FETCH_EA_WORD into r0
p 00 00000 00001 0A33
p 01 00000 00001 1100
p 01 00000 00001 0792
#
# r1 <= r0 - Move results held in r0 to r1
p 00 00000 00001 0A34
p 01 00000 00001 5AF9
p 01 00000 00001 0000
#
# CALL FETCH_REG into r0
p 00 00000 00001 0A35
p 01 00000 00001 1100
p 01 00000 00001 07D4
#
#
# Perform the ALU
# ----------------
#
# CALL SUB_WORD
p 00 00000 00001 0A36
p 01 00000 00001 1100
p 01 00000 00001 0A52
#
# Jump unconditional to common code
p 00 00000 00001 0A37
p 01 00000 00001 1000
p 01 00000 00001 093A
#
#
# -----------------------------------------------------
#
# 0x2C   SUB - AL,IMM8 
#
# -----------------------------------------------------
#
# CALL Fetch byte from prefetch queue with QS=Initial opcode byte into r3
p 00 00000 00001 0A38
p 01 00000 00001 1100
p 01 00000 00001 02A0
#
# r0 = AX
p 00 00000 00001 0A39
p 01 00000 00001 590F
p 01 00000 00001 0000
#
# r1 = r3
p 00 00000 00001 0A3A
p 01 00000 00001 5ACF
p 01 00000 00001 0000
#
# CALL SUB_BYTE
p 00 00000 00001 0A3B
p 01 00000 00001 1100
p 01 00000 00001 0A46
#
# Zero out upper byte of r0
p 00 00000 00001 0A3C
p 01 00000 00001 499F
p 01 00000 00001 00FF
#
# Zero out AL 
p 00 00000 00001 0A3D
p 01 00000 00001 400F
p 01 00000 00001 FF00
#
# AX = AH or r0 - Merge AH with r0 results
p 00 00000 00001 0A3E
p 01 00000 00001 5009
p 01 00000 00001 0000
#
# Jump unconditional to common code
p 00 00000 00001 0A3F
p 01 00000 00001 1000
p 01 00000 00001 0944
#
#
# -----------------------------------------------------
#
# 0x2D   SUB - AX,IMM16 
#
# -----------------------------------------------------
#
# CALL Fetch word from prefetch queue with QS=Initial opcode byte into r3
p 00 00000 00001 0A40
p 01 00000 00001 1100
p 01 00000 00001 02E0
#
# r0 = AX
p 00 00000 00001 0A41
p 01 00000 00001 590F
p 01 00000 00001 0000
#
# r1 = r3
p 00 00000 00001 0A42
p 01 00000 00001 5ACF
p 01 00000 00001 0000
#
# CALL SUB_WORD
p 00 00000 00001 0A43
p 01 00000 00001 1100
p 01 00000 00001 0A52
#
# AX = r0
p 00 00000 00001 0A44
p 01 00000 00001 50F9
p 01 00000 00001 0000
#
# Jump unconditional to common code
p 00 00000 00001 0A45
p 01 00000 00001 1000
p 01 00000 00001 0944
#
#
# -----------------------------------------------------
#
# PROCEDURE - SUB for Bytes
#
# r0 = r0 - r1  ((2's complement addition))
# All Byte Flags are then calculated
#
# -----------------------------------------------------
#
# Two's complement r1: Invert r1  (r1 = r1 XOR FFFF)
p 00 00000 00001 0A46
p 01 00000 00001 6AAF
p 01 00000 00001 FFFF
#
# r0 = r0 + r1
p 00 00000 00001 0A47
p 01 00000 00001 299A
p 01 00000 00001 0000
#
# CALL CALCULATE_FLAGS_BYTE
p 00 00000 00001 0A48
p 01 00000 00001 1100
p 01 00000 00001 0990
#
# Finish the Two's complement r0: r0 = r0 + 1
p 00 00000 00001 0A49
p 01 00000 00001 299F
p 01 00000 00001 0001
#
# r2 <= last_alu result - This is done to prepare for flag calculation
p 00 00000 00001 0A4A
p 01 00000 00001 5BFD
p 01 00000 00001 0000
#
# Zero out the P, Z, S bit fields in Flag register in case they were set by intermediate result
p 00 00000 00001 0A4B
p 01 00000 00001 488F
p 01 00000 00001 FF3B
#
# CALL CALCULATE_FLAGS_BYTE_NO_FLAGS_ZEROING
p 00 00000 00001 0A4C
p 01 00000 00001 1100
p 01 00000 00001 0992
#
# Invert the Carry and Aux Carry bit - Flags[4,0] - since this is subtraction
p 00 00000 00001 0A4D
p 01 00000 00001 688F
p 01 00000 00001 0011
#
# Return to calling code
p 00 00000 00001 0A4E
p 01 00000 00001 1030
p 01 00000 00001 0000
#
#
# -----------------------------------------------------
#
# PROCEDURE - SUB for Words
#
# r0 = r0 - r1  ((2's complement addition))
# All Word Flags are then calculated
#
# -----------------------------------------------------
#
#
# Two's complement r1: Invert r1  (r1 = r1 XOR FFFF)
p 00 00000 00001 0A52
p 01 00000 00001 6AAF
p 01 00000 00001 FFFF
#
# r0 = r0 + r1
p 00 00000 00001 0A53
p 01 00000 00001 299A
p 01 00000 00001 0000
#
# CALL CALCULATE_FLAGS_WORD
p 00 00000 00001 0A54
p 01 00000 00001 1100
p 01 00000 00001 03D3
#
# Finish the Two's complement r0: r0 = r0 + 1
p 00 00000 00001 0A55
p 01 00000 00001 299F
p 01 00000 00001 0001
#
# r2 <= last_alu result - This is done to prepare for flag calculation
p 00 00000 00001 0A56
p 01 00000 00001 5BFD
p 01 00000 00001 0000
#
# Zero out the P, Z, S bit fields in Flag register in case they were set by intermediate result
p 00 00000 00001 0A57
p 01 00000 00001 488F
p 01 00000 00001 FF3B
#
# CALL CALCULATE_FLAGS_WORD_NO_FLAGS_ZEROING
p 00 00000 00001 0A58
p 01 00000 00001 1100
p 01 00000 00001 03D5
#
# Invert the Carry and Aux Carry bit - Flags[4,0] - since this is subtraction
p 00 00000 00001 0A59
p 01 00000 00001 688F
p 01 00000 00001 0011
#
# Return to calling code
p 00 00000 00001 0A5A
p 01 00000 00001 1030
p 01 00000 00001 0000
#
#
# -----------------------------------------------------
#
#  0x38   CMP - REG8/MEM8 , REG8
#
# -----------------------------------------------------
#
# CALL CALC_EA_BYTE
p 00 00000 00001 0A60
p 01 00000 00001 1100
p 01 00000 00001 0760
#
# CALL FETCH_REG into r0
p 00 00000 00001 0A61
p 01 00000 00001 1100
p 01 00000 00001 07D4
#
# r1 <= r0 - Move results held in r0 to r1
p 00 00000 00001 0A62
p 01 00000 00001 5AF9
p 01 00000 00001 0000
#
# CALL FETCH_EA_BYTE into r0
p 00 00000 00001 0A63
p 01 00000 00001 1100
p 01 00000 00001 0790
#
#
# Perform the ALU
# ----------------
#
# CALL SUB_BYTE
p 00 00000 00001 0A64
p 01 00000 00001 1100
p 01 00000 00001 0A46
#
# Jump unconditional to common code
p 00 00000 00001 0A65
p 01 00000 00001 1000
p 01 00000 00001 090E
#
#
# -----------------------------------------------------
#
#  0x39   CMP - REG16/MEM16 , REG16 
#
# -----------------------------------------------------
#
# CALL CALC_EA_WORD
p 00 00000 00001 0A66
p 01 00000 00001 1100
p 01 00000 00001 0762
#
# CALL FETCH_REG into r0
p 00 00000 00001 0A67
p 01 00000 00001 1100
p 01 00000 00001 07D4
#
# r1 <= r0 - Move results held in r0 to r1
p 00 00000 00001 0A68
p 01 00000 00001 5AF9
p 01 00000 00001 0000
#
# CALL FETCH_EA_WORD into r0
p 00 00000 00001 0A69
p 01 00000 00001 1100
p 01 00000 00001 0792
#
#
# Perform the ALU
# ----------------
#
# CALL SUB_WORD
p 00 00000 00001 0A6A
p 01 00000 00001 1100
p 01 00000 00001 0A52
#
# Jump unconditional to common code
p 00 00000 00001 0A6B
p 01 00000 00001 1000
p 01 00000 00001 091D
#
#
# -----------------------------------------------------
#
# 0x3A   CMP - REG8 , REG8/MEM8 
#
# -----------------------------------------------------
#
# CALL CALC_EA_BYTE
p 00 00000 00001 0A6C
p 01 00000 00001 1100
p 01 00000 00001 0760
#
# CALL FETCH_EA_BYTE into r0
p 00 00000 00001 0A6D
p 01 00000 00001 1100
p 01 00000 00001 0790
#
# r1 <= r0 - Move results held in r0 to r1
p 00 00000 00001 0A6E
p 01 00000 00001 5AF9
p 01 00000 00001 0000
#
# CALL FETCH_REG into r0
p 00 00000 00001 0A6F
p 01 00000 00001 1100
p 01 00000 00001 07D4
#
#
# Perform the ALU
# ----------------
#
# CALL SUB_BYTE
p 00 00000 00001 0A70
p 01 00000 00001 1100
p 01 00000 00001 0A46
#
# Jump unconditional to common code
p 00 00000 00001 0A71
p 01 00000 00001 1000
p 01 00000 00001 092C
#
#
#
# -----------------------------------------------------
#
# 0x3B   CMP - REG16 , REG16/MEM16 
#
# -----------------------------------------------------
#
# CALL CALC_EA_WORD
p 00 00000 00001 0A72
p 01 00000 00001 1100
p 01 00000 00001 0762
#
# CALL FETCH_EA_WORD into r0
p 00 00000 00001 0A73
p 01 00000 00001 1100
p 01 00000 00001 0792
#
# r1 <= r0 - Move results held in r0 to r1
p 00 00000 00001 0A74
p 01 00000 00001 5AF9
p 01 00000 00001 0000
#
# CALL FETCH_REG into r0
p 00 00000 00001 0A75
p 01 00000 00001 1100
p 01 00000 00001 07D4
#
#
# Perform the ALU
# ----------------
#
# CALL SUB_WORD
p 00 00000 00001 0A76
p 01 00000 00001 1100
p 01 00000 00001 0A52
#
# Jump unconditional to common code
p 00 00000 00001 0A77
p 01 00000 00001 1000
p 01 00000 00001 093B
#
#
# -----------------------------------------------------
#
# 0x3C   CMP - AL,IMM8 
#
# -----------------------------------------------------
#
# CALL Fetch byte from prefetch queue with QS=Initial opcode byte into r3
p 00 00000 00001 0A78
p 01 00000 00001 1100
p 01 00000 00001 02A0
#
# r0 = AX
p 00 00000 00001 0A79
p 01 00000 00001 590F
p 01 00000 00001 0000
#
# r1 = r3
p 00 00000 00001 0A7A
p 01 00000 00001 5ACF
p 01 00000 00001 0000
#
# CALL SUB_BYTE
p 00 00000 00001 0A7B
p 01 00000 00001 1100
p 01 00000 00001 0A46
#
# Jump unconditional to common code
p 00 00000 00001 0A7C
p 01 00000 00001 1000
p 01 00000 00001 0944
#
#
#
# -----------------------------------------------------
#
# 0x3D   CMP - AX,IMM16 
#
# -----------------------------------------------------
#
# CALL Fetch word from prefetch queue with QS=Initial opcode byte into r3
p 00 00000 00001 0A7D
p 01 00000 00001 1100
p 01 00000 00001 02E0
#
# r0 = AX
p 00 00000 00001 0A7E
p 01 00000 00001 590F
p 01 00000 00001 0000
#
# r1 = r3
p 00 00000 00001 0A7F
p 01 00000 00001 5ACF
p 01 00000 00001 0000
#
# CALL SUB_WORD
p 00 00000 00001 0A80
p 01 00000 00001 1100
p 01 00000 00001 0A52
#
# Jump unconditional to common code
p 00 00000 00001 0A81
p 01 00000 00001 1000
p 01 00000 00001 0944
#
#
#
# -----------------------------------------------------
#
#  0x18   SBB - REG8/MEM8 , REG8
#
# -----------------------------------------------------
#
# CALL CALC_EA_BYTE
p 00 00000 00001 0A88
p 01 00000 00001 1100
p 01 00000 00001 0760
#
# CALL FETCH_REG into r0
p 00 00000 00001 0A89
p 01 00000 00001 1100
p 01 00000 00001 07D4
#
# r1 <= r0 - Move results held in r0 to r1
p 00 00000 00001 0A8A
p 01 00000 00001 5AF9
p 01 00000 00001 0000
#
# CALL FETCH_EA_BYTE into r0
p 00 00000 00001 0A8B
p 01 00000 00001 1100
p 01 00000 00001 0790
#
#
# Perform the ALU
# ----------------
#
# CALL SBB_BYTE
p 00 00000 00001 0A8C
p 01 00000 00001 1100
p 01 00000 00001 0AAE
#
# Jump unconditional to common code
p 00 00000 00001 0A8D
p 01 00000 00001 1000
p 01 00000 00001 090D
#
#
# -----------------------------------------------------
#
#  0x19   SBB - REG16/MEM16 , REG16 
#
# -----------------------------------------------------
#
# CALL CALC_EA_WORD
p 00 00000 00001 0A8E
p 01 00000 00001 1100
p 01 00000 00001 0762
#
# CALL FETCH_REG into r0
p 00 00000 00001 0A8F
p 01 00000 00001 1100
p 01 00000 00001 07D4
#
# r1 <= r0 - Move results held in r0 to r1
p 00 00000 00001 0A90
p 01 00000 00001 5AF9
p 01 00000 00001 0000
#
# CALL FETCH_EA_WORD into r0
p 00 00000 00001 0A91
p 01 00000 00001 1100
p 01 00000 00001 0792
#
#
# Perform the ALU
# ----------------
#
# CALL SBB_WORD
p 00 00000 00001 0A92
p 01 00000 00001 1100
p 01 00000 00001 0ABA
#
# Jump unconditional to common code
p 00 00000 00001 0A93
p 01 00000 00001 1000
p 01 00000 00001 091C
#
#
# -----------------------------------------------------
#
# 0x1A   SBB - REG8 , REG8/MEM8 
#
# -----------------------------------------------------
#
# CALL CALC_EA_BYTE
p 00 00000 00001 0A94
p 01 00000 00001 1100
p 01 00000 00001 0760
#
# CALL FETCH_EA_BYTE into r0
p 00 00000 00001 0A95
p 01 00000 00001 1100
p 01 00000 00001 0790
#
# r1 <= r0 - Move results held in r0 to r1
p 00 00000 00001 0A96
p 01 00000 00001 5AF9
p 01 00000 00001 0000
#
# CALL FETCH_REG into r0
p 00 00000 00001 0A97
p 01 00000 00001 1100
p 01 00000 00001 07D4
#
#
# Perform the ALU
# ----------------
#
# CALL SBB_BYTE
p 00 00000 00001 0A98
p 01 00000 00001 1100
p 01 00000 00001 0AAE
#
# Jump unconditional to common code
p 00 00000 00001 0A99
p 01 00000 00001 1000
p 01 00000 00001 092B
#
#
#
# -----------------------------------------------------
#
# 0x1B   SBB - REG16 , REG16/MEM16 
#
# -----------------------------------------------------
#
# CALL CALC_EA_WORD
p 00 00000 00001 0A9A
p 01 00000 00001 1100
p 01 00000 00001 0762
#
# CALL FETCH_EA_WORD into r0
p 00 00000 00001 0A9B
p 01 00000 00001 1100
p 01 00000 00001 0792
#
# r1 <= r0 - Move results held in r0 to r1
p 00 00000 00001 0A9C
p 01 00000 00001 5AF9
p 01 00000 00001 0000
#
# CALL FETCH_REG into r0
p 00 00000 00001 0A9D
p 01 00000 00001 1100
p 01 00000 00001 07D4
#
#
# Perform the ALU
# ----------------
#
# CALL SBB_WORD
p 00 00000 00001 0A9E
p 01 00000 00001 1100
p 01 00000 00001 0ABA
#
# Jump unconditional to common code
p 00 00000 00001 0A9F
p 01 00000 00001 1000
p 01 00000 00001 093A
#
#
# -----------------------------------------------------
#
# 0x1C   SBB - AL,IMM8 
#
# -----------------------------------------------------
#
# CALL Fetch byte from prefetch queue with QS=Initial opcode byte into r3
p 00 00000 00001 0AA0
p 01 00000 00001 1100
p 01 00000 00001 02A0
#
# r0 = AX
p 00 00000 00001 0AA1
p 01 00000 00001 590F
p 01 00000 00001 0000
#
# r1 = r3
p 00 00000 00001 0AA2
p 01 00000 00001 5ACF
p 01 00000 00001 0000
#
# CALL SBB_BYTE
p 00 00000 00001 0AA3
p 01 00000 00001 1100
p 01 00000 00001 0AAE
#
# Zero out upper byte of r0
p 00 00000 00001 0AA4
p 01 00000 00001 499F
p 01 00000 00001 00FF
#
# Zero out AL 
p 00 00000 00001 0AA5
p 01 00000 00001 400F
p 01 00000 00001 FF00
#
# AX = AH or r0 - Merge AH with r0 results
p 00 00000 00001 0AA6
p 01 00000 00001 5009
p 01 00000 00001 0000
#
# Jump unconditional to common code
p 00 00000 00001 0AA7
p 01 00000 00001 1000
p 01 00000 00001 0944
#
#
#
# -----------------------------------------------------
#
# 0x1D   SBB - AX,IMM16 
#
# -----------------------------------------------------
#
# CALL Fetch word from prefetch queue with QS=Initial opcode byte into r3
p 00 00000 00001 0AA8
p 01 00000 00001 1100
p 01 00000 00001 02E0
#
# r0 = AX
p 00 00000 00001 0AA9
p 01 00000 00001 590F
p 01 00000 00001 0000
#
# r1 = r3
p 00 00000 00001 0AAA
p 01 00000 00001 5ACF
p 01 00000 00001 0000
#
# CALL SBB_WORD
p 00 00000 00001 0AAB
p 01 00000 00001 1100
p 01 00000 00001 0ABA
#
# AX = r0
p 00 00000 00001 0AAC
p 01 00000 00001 50F9
p 01 00000 00001 0000
#
# Jump unconditional to common code
p 00 00000 00001 0AAD
p 01 00000 00001 1000
p 01 00000 00001 0944
#
#
#
# -----------------------------------------------------
#
# PROCEDURE - SBB for Bytes
#
# r0 = r0 - r1 - C  ((2's complement addition))
# All Byte Flags are then calculated
#
# -----------------------------------------------------
#

# One's complement r1: Invert r1  (r1 = r1 XOR FFFF)
p 00 00000 00001 0AAE
p 01 00000 00001 6AAF
p 01 00000 00001 FFFF
#
# r0 = r0 + r1
p 00 00000 00001 0AAF
p 01 00000 00001 299A
p 01 00000 00001 0000
#
# Isolate Carry flags bit[0] into r1
p 00 00000 00001 0AB0
p 01 00000 00001 4A8F
p 01 00000 00001 0001
#
# Dummy = r0 to re-establish last_result for flags calculation
p 00 00000 00001 0AB1
p 01 00000 00001 5EF9
p 01 00000 00001 0000
#
# CALL CALCULATE_FLAGS_BYTE
p 00 00000 00001 0AB2
p 01 00000 00001 1100
p 01 00000 00001 0990
#
# Dummy = r1
p 00 00000 00001 0AB3
p 01 00000 00001 5EFA
p 01 00000 00001 0000
#
# If last_alu is non zero, jump to end
p 00 00000 00001 0AB4
p 01 00000 00001 1001
p 01 00000 00001 0AC5
#
# No Carry, so finish the Two's complement r0: r0 = r0 + 1
p 00 00000 00001 0AB5
p 01 00000 00001 299F
p 01 00000 00001 0001
#
# r2 <= last_alu result - This is done to prepare for flag calculation
p 00 00000 00001 0AB6
p 01 00000 00001 5BFD
p 01 00000 00001 0000
#
# Zero out the P, Z, S bit fields in Flag register in case they were set by intermediate result
p 00 00000 00001 0AB7
p 01 00000 00001 488F
p 01 00000 00001 FF3B
#
# CALL CALCULATE_FLAGS_BYTE_NO_FLAGS_ZEROING
p 00 00000 00001 0AB8
p 01 00000 00001 1100
p 01 00000 00001 0992
#
# Jump unconditional to common code
p 00 00000 00001 0AB9
p 01 00000 00001 1000
p 01 00000 00001 0AC5
#
# -----------------------------------------------------
#
# PROCEDURE - SBB for Words
#
# r0 = r0 - r1 - C ((2's complement addition))
# All Word Flags are then calculated
#
# -----------------------------------------------------
#
#
# One's complement r1: Invert r1  (r1 = r1 XOR FFFF)
p 00 00000 00001 0ABA
p 01 00000 00001 6AAF
p 01 00000 00001 FFFF
#
# r0 = r0 + r1
p 00 00000 00001 0ABB
p 01 00000 00001 299A
p 01 00000 00001 0000
#
# Isolate Carry flags bit[0] into r1
p 00 00000 00001 0ABC
p 01 00000 00001 4A8F
p 01 00000 00001 0001
#
# Dummy = r0 to re-establish last_result for flags calculation
p 00 00000 00001 0ABD
p 01 00000 00001 5EF9
p 01 00000 00001 0000
#
# CALL CALCULATE_FLAGS_WORD
p 00 00000 00001 0ABE
p 01 00000 00001 1100
p 01 00000 00001 03D3
#
# Dummy = r1
p 00 00000 00001 0ABF
p 01 00000 00001 5EFA
p 01 00000 00001 0000
#
# If last_alu is non zero, jump to end
p 00 00000 00001 0AC0
p 01 00000 00001 1001
p 01 00000 00001 0AC5
#
# No Carry, so finish the Two's complement r0: r0 = r0 + 1
p 00 00000 00001 0AC1
p 01 00000 00001 299F
p 01 00000 00001 0001
#
# r2 <= last_alu result - This is done to prepare for flag calculation
p 00 00000 00001 0AC2
p 01 00000 00001 5BFD
p 01 00000 00001 0000
#
# Zero out the P, Z, S bit fields in Flag register in case they were set by intermediate result
p 00 00000 00001 0AC3
p 01 00000 00001 488F
p 01 00000 00001 FF3B
#
# CALL CALCULATE_FLAGS_WORD_NO_FLAGS_ZEROING
p 00 00000 00001 0AC4
p 01 00000 00001 1100
p 01 00000 00001 03D5
#
# Invert the Carry and Aux Carry bit - Flags[4,0] - since this is subtraction
p 00 00000 00001 0AC5
p 01 00000 00001 688F
p 01 00000 00001 0011
#
# Return to calling code
p 00 00000 00001 0AC6
p 01 00000 00001 1030
p 01 00000 00001 0000
#
#
# -----------------------------------------------------
#
# GROUP Opcode - 0x80
#
# Common microcode processed first. Then Jump Type 6 used
# to decode the REG Field to a Jump table where specific
# microcode is processed for that opcode type.
#
#
# -----------------------------------------------------
#
# CALL CALC_EA_BYTE
p 00 00000 00001 0AD0
p 01 00000 00001 1100
p 01 00000 00001 0760
#
# CALL FETCH_EA_BYTE into r0
p 00 00000 00001 0AD1
p 01 00000 00001 1100
p 01 00000 00001 0790
#
# CALL Fetch Opcode byte with QS=Subsequent opcode byte into r3 - Fetch IMM8
p 00 00000 00001 0AD2
p 01 00000 00001 1100
p 01 00000 00001 02A5 
#
# Copy r1 to the biu_dataout register - Store the Addressing Byte for the Jump-6
p 00 00000 00001 0AD3
p 01 00000 00001 5FFA
p 01 00000 00001 0000
#
# r1 <= r3
p 00 00000 00001 0AD4
p 01 00000 00001 5AFC
p 01 00000 00001 0000
#
# Jump-Type6 to Jump Table for 0x80 opcodes: Base address at 0x0AD8
p 00 00000 00001 0AD5
p 01 00000 00001 1060
p 01 00000 00001 0AD8
#
#
#
# Jump Table for 0x80 Opcodes decoded using the REG Field of the Addressing Byte
#
#
# ADD REG8/MEM8,IMM8
p 00 00000 00001 0AD8
p 01 00000 00001 1000
p 01 00000 00001 09AA
#
# OR REG8/MEM8,IMM8
p 00 00000 00001 0AD9
p 01 00000 00001 1000
p 01 00000 00001 090A
#
# ADC REG8/MEM8,IMM8
p 00 00000 00001 0ADA
p 01 00000 00001 1000
p 01 00000 00001 09D6
#
# SBB REG8/MEM8,IMM8
p 00 00000 00001 0ADB
p 01 00000 00001 1000
p 01 00000 00001 0A8C
#
# AND REG8/MEM8,IMM8
p 00 00000 00001 0ADC
p 01 00000 00001 1000
p 01 00000 00001 0974
#
# SUB REG8/MEM8,IMM8
p 00 00000 00001 0ADD
p 01 00000 00001 1000
p 01 00000 00001 0A24
#
# XOR REG8/MEM8,IMM8
p 00 00000 00001 0ADE
p 01 00000 00001 1000
p 01 00000 00001 0954
#
# CMP REG8/MEM8,IMM8
p 00 00000 00001 0ADF
p 01 00000 00001 1000
p 01 00000 00001 0A64
#
#
# -----------------------------------------------------
#
# GROUP Opcode - 0x81
#
# Common microcode processed first. Then Jump Type 6 used
# to decode the REG Field to a Jump table where specific
# microcode is processed for that opcode type.
#
#
# -----------------------------------------------------
#
# CALL CALC_EA_WORD
p 00 00000 00001 0AE0
p 01 00000 00001 1100
p 01 00000 00001 0762
#
# CALL FETCH_EA_WORD into r0
p 00 00000 00001 0AE1
p 01 00000 00001 1100
p 01 00000 00001 0792
#
# CALL Fetch Opcode word with QS=Subsequent opcode byte into r3 - Fetch IMM16
p 00 00000 00001 0AE2
p 01 00000 00001 1100
p 01 00000 00001 02E5 
#
# Copy r1 to the biu_dataout register - Store the Addressing Byte for the Jump-6
p 00 00000 00001 0AE3
p 01 00000 00001 5FFA
p 01 00000 00001 0000
#
# r1 <= r3
p 00 00000 00001 0AE4
p 01 00000 00001 5AFC
p 01 00000 00001 0000
#
# Jump-Type6 to Jump Table for 0x81 opcodes: Base address at 0x0AE8
p 00 00000 00001 0AE5
p 01 00000 00001 1060
p 01 00000 00001 0AE8
#
#
#
# Jump Table for 0x81 Opcodes decoded using the REG Field of the Addressing Byte
#
# ADD REG16/MEM16,IMM16
p 00 00000 00001 0AE8
p 01 00000 00001 1000
p 01 00000 00001 09B0
#
# OR REG16/MEM16,IMM16
p 00 00000 00001 0AE9
p 01 00000 00001 1000
p 01 00000 00001 0919
#
# ADC REG16/MEM16,IMM16
p 00 00000 00001 0AEA
p 01 00000 00001 1000
p 01 00000 00001 09DC
#
# SBB REG16/MEM16,IMM16
p 00 00000 00001 0AEB
p 01 00000 00001 1000
p 01 00000 00001 0A92
#
# AND REG16/MEM16,IMM16
p 00 00000 00001 0AEC
p 01 00000 00001 1000
p 01 00000 00001 097A
#
# SUB REG16/MEM16,IMM16
p 00 00000 00001 0AED
p 01 00000 00001 1000
p 01 00000 00001 0A2A
#
# XOR REG16/MEM16,IMM16
p 00 00000 00001 0AEE
p 01 00000 00001 1000
p 01 00000 00001 095A
#
# CMP REG16/MEM16,IMM16
p 00 00000 00001 0AEF
p 01 00000 00001 1000
p 01 00000 00001 0A6A
#
#
# -----------------------------------------------------
#
# GROUP Opcode - 0x83 
#
# Common microcode processed first. Then Jump Type 6 used
# to decode the REG Field to a Jump table where specific
# microcode is processed for that opcode type.
#
#
# -----------------------------------------------------
#
# CALL CALC_EA_WORD
p 00 00000 00001 0AF0
p 01 00000 00001 1100
p 01 00000 00001 0762
#
# CALL FETCH_EA_WORD into r0
p 00 00000 00001 0AF1
p 01 00000 00001 1100
p 01 00000 00001 0792
#
# CALL Fetch Opcode byte with QS=Subsequent opcode byte into r3 - Fetch IMM8
p 00 00000 00001 0AF2
p 01 00000 00001 1100
p 01 00000 00001 02A5 
#
# CALL Sign Extend r3
p 00 00000 00001 0AF3
p 01 00000 00001 1100
p 01 00000 00001 033A
#
# Jump unconditional to common code for 0x81 opcodes
p 00 00000 00001 0AF4
p 01 00000 00001 1000
p 01 00000 00001 0AE3
#
#
# -----------------------------------------------------
#
# GROUP Opcode - 0xD0
#
#
# Common microcode processed first. Then Jump Type 6 used
# to decode the REG Field to a Jump table where specific
# microcode is processed for that opcode type.
#
#
# -----------------------------------------------------
#
# CALL CALC_EA_BYTE
p 00 00000 00001 0AF7
p 01 00000 00001 1100
p 01 00000 00001 0760
#
# CALL FETCH_EA_BYTE into r0
p 00 00000 00001 0AF8
p 01 00000 00001 1100
p 01 00000 00001 0790
#
# Copy r1 to the biu_dataout register - Store the Addressing Byte for the Jump-6
p 00 00000 00001 0AF9
p 01 00000 00001 5FFA
p 01 00000 00001 0000
#
# Jump-Type6 to Jump Table for 0xD0 opcodes: Base address at 0x0B00
p 00 00000 00001 0AFA
p 01 00000 00001 1060
p 01 00000 00001 0B00
#
#
#
# -----------------------------------------------------
#
# GROUP Opcode - 0xD2 
#
#
# Common microcode processed first. Then Jump Type 6 used
# to decode the REG Field to a Jump table where specific
# microcode is processed for that opcode type.
#
#
# -----------------------------------------------------
#
# CALL CALC_EA_BYTE
p 00 00000 00001 0AFC
p 01 00000 00001 1100
p 01 00000 00001 0760
#
# CALL FETCH_EA_BYTE into r0
p 00 00000 00001 0AFD
p 01 00000 00001 1100
p 01 00000 00001 0790
#
# Copy r1 to the biu_dataout register - Store the Addressing Byte for the Jump-6
p 00 00000 00001 0AFE
p 01 00000 00001 5FFA
p 01 00000 00001 0000
#
# Jump-Type6 to Jump Table for 0xD2 opcodes: Base address at 0x0B08
p 00 00000 00001 0AFF
p 01 00000 00001 1060
p 01 00000 00001 0B08
#
#
#
# Jump Table for 0xD2 Opcodes decoded using the REG Field of the Addressing Byte
#
# ROL REG8/MEM8,1
p 00 00000 00001 0B00
p 01 00000 00001 1000
p 01 00000 00001 0B1E
#
# ROR REG8/MEM8,1
p 00 00000 00001 0B01
p 01 00000 00001 1000
p 01 00000 00001 0B3D
#
# RCL REG8/MEM8,1
p 00 00000 00001 0B02
p 01 00000 00001 1000
p 01 00000 00001 0B5B
#
# RCR REG8/MEM8,1
p 00 00000 00001 0B03
p 01 00000 00001 1000
p 01 00000 00001 0B79
#
# SAL REG8/MEM8,1
p 00 00000 00001 0B04
p 01 00000 00001 1000
p 01 00000 00001 0B94
#
# SHR REG8/MEM8,1
p 00 00000 00001 0B05
p 01 00000 00001 1000
p 01 00000 00001 0BB4
#
# SHR REG8/MEM8,1 - unused
p 00 00000 00001 0B06
p 01 00000 00001 1000
p 01 00000 00001 0BB4
#
# SAR REG8/MEM8,1
p 00 00000 00001 0B07
p 01 00000 00001 1000
p 01 00000 00001 0BD7
#
#
# Jump Table for 0xD2 Opcodes decoded using the REG Field of the Addressing Byte
#
# ROL REG8/MEM8,CL
p 00 00000 00001 0B08
p 01 00000 00001 1000
p 01 00000 00001 0B20
#
# ROR REG8/MEM8,CL
p 00 00000 00001 0B09
p 01 00000 00001 1000
p 01 00000 00001 0B3F
#
# RCL REG8/MEM8,CL
p 00 00000 00001 0B0A
p 01 00000 00001 1000
p 01 00000 00001 0B5D
#
# RCR REG8/MEM8,CL
p 00 00000 00001 0B0B
p 01 00000 00001 1000
p 01 00000 00001 0B7B
#
# SAL REG8/MEM8,CL
p 00 00000 00001 0B0C
p 01 00000 00001 1000
p 01 00000 00001 0B96
#
# SHR REG8/MEM8,CL
p 00 00000 00001 0B0D
p 01 00000 00001 1000
p 01 00000 00001 0BB6
#
# SHR REG8/MEM8,CL - unused
p 00 00000 00001 0B0E
p 01 00000 00001 1000
p 01 00000 00001 0BB6
#
# SAR REG8/MEM8,CL
p 00 00000 00001 0B0F
p 01 00000 00001 1000
p 01 00000 00001 0BD9
#
#
#
# -----------------------------------------------------
#
# Procedure ROL8,1 
#
# -----------------------------------------------------
#
# Zero the CF and OF Flags
p 00 00000 00001 0B10
p 01 00000 00001 488F
p 01 00000 00001 F7FE
#
# Set r1 to 0x0000
p 00 00000 00001 0B11
p 01 00000 00001 5AFF
p 01 00000 00001 0000
#
# Isolate r0[7] into Dummy
p 00 00000 00001 0B12
p 01 00000 00001 4E9F
p 01 00000 00001 0080
#
# Jump if zero over next instructions
p 00 00000 00001 0B13
p 01 00000 00001 1002
p 01 00000 00001 0B16
#
# Set the CF Flag to 1
p 00 00000 00001 0B14
p 01 00000 00001 588F
p 01 00000 00001 0001
#
# Set r1 to 0x0001
p 00 00000 00001 0B15
p 01 00000 00001 5AFF
p 01 00000 00001 0001
#
# Shift r0 to the left 1 bit
p 00 00000 00001 0B16
p 01 00000 00001 2999
p 01 00000 00001 0000
#
# r0 <= r0 OR r1 - OR in the CF stored in r1
p 00 00000 00001 0B17
p 01 00000 00001 599A
p 01 00000 00001 0000
#
# Isolate the Overflow8 flag from System Signals into Dummy
p 00 00000 00001 0B18
p 01 00000 00001 4EEF
p 01 00000 00001 0200
#
# if alu_last_result is zero then jump over next instruction
p 00 00000 00001 0B19
p 01 00000 00001 1002
p 01 00000 00001 0B1B
#
# Set the Overflow Flag bit to a 1
p 00 00000 00001 0B1A
p 01 00000 00001 588F
p 01 00000 00001 0800
#
# Return to calling code
p 00 00000 00001 0B1B
p 01 00000 00001 1030
p 01 00000 00001 0000
#
#
# -----------------------------------------------------
#
# ROL - REG8/MEM8 , 1
#
# -----------------------------------------------------
#
# CALL ROL8,1
p 00 00000 00001 0B1E
p 01 00000 00001 1100
p 01 00000 00001 0B10
#
# Jump unconditional to common code to writeback the EA Byte
p 00 00000 00001 0B1F
p 01 00000 00001 1000
p 01 00000 00001 090D
#
#
# -----------------------------------------------------
#
# ROL - REG8/MEM8 , CL
#
# -----------------------------------------------------
#
#
# Write to clock counter to equal 8 clocks for this instruction
p 00 00000 00001 0B20
p 01 00000 00001 5FFF
p 01 00000 00001 C040
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0B21
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# r3 <= CX AND 00FF - Isolate the iteration counter into r3
p 00 00000 00001 0B22
p 01 00000 00001 4C2F
p 01 00000 00001 00FF
#
# TOP: Jump if last_alu zero to common code to writeback the EA Byte
p 00 00000 00001 0B23
p 01 00000 00001 1002
p 01 00000 00001 090D
#
# CALL ROL8,1
p 00 00000 00001 0B24
p 01 00000 00001 1100
p 01 00000 00001 0B10
#
# Write to clock counter to equal 4 clocks for this instruction
p 00 00000 00001 0B25
p 01 00000 00001 5FFF
p 01 00000 00001 C020
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0B26
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# zero out r0[15:8] so it does not wrap around to bit 0
p 00 00000 00001 0B27
p 01 00000 00001 499F
p 01 00000 00001 00FF
#
# Subtract r3 = r3 - 1 (( Add FFFF ))
p 00 00000 00001 0B28
p 01 00000 00001 2CCF
p 01 00000 00001 FFFF
#
# Jump unconditional to TOP:
p 00 00000 00001 0B29
p 01 00000 00001 1000
p 01 00000 00001 0B23
#
# -----------------------------------------------------
#
# Procedure ROR8,1 
#
# -----------------------------------------------------
#
# Zero the CF and OF Flags
p 00 00000 00001 0B30
p 01 00000 00001 488F
p 01 00000 00001 F7FE
#
# Clear r1 to 0x0000
p 00 00000 00001 0B31
p 01 00000 00001 5AFF
p 01 00000 00001 0000
#
# Isolate r0[7] into r2
p 00 00000 00001 0B32
p 01 00000 00001 4B9F
p 01 00000 00001 0080
#
# Isolate r0[0] into Dummy
p 00 00000 00001 0B33
p 01 00000 00001 4E9F
p 01 00000 00001 0001
#
# Jump if zero over next instructions
p 00 00000 00001 0B34
p 01 00000 00001 1002
p 01 00000 00001 0B37
#
# Set the CF Flag to 1
p 00 00000 00001 0B35
p 01 00000 00001 588F
p 01 00000 00001 0001
#
# Set r1 to 0x0080
p 00 00000 00001 0B36
p 01 00000 00001 5AFF
p 01 00000 00001 0080
#
# Shift r0 to the right 1 bit
p 00 00000 00001 0B37
p 01 00000 00001 7999
p 01 00000 00001 0000
#
# r0 <= r0 OR r1 - OR in the CF stored in r1
p 00 00000 00001 0B38
p 01 00000 00001 599A
p 01 00000 00001 0000
#
# r1 XOR r2 into Dummy - See if final result[7] not equal to [6] for Overflow
p 00 00000 00001 0B39
p 01 00000 00001 6EAB
p 01 00000 00001 0200
#
# if alu_last_result is zero then jump over next instruction
p 00 00000 00001 0B3A
p 01 00000 00001 1002
p 01 00000 00001 0B3C
#
# Set the Overflow Flag bit to a 1
p 00 00000 00001 0B3B
p 01 00000 00001 588F
p 01 00000 00001 0800
#
# Return to calling code
p 00 00000 00001 0B3C
p 01 00000 00001 1030
p 01 00000 00001 0000
#
#
# -----------------------------------------------------
#
# ROR - REG8/MEM8 , 1
#
# -----------------------------------------------------
#
# CALL ROR8,1
p 00 00000 00001 0B3D
p 01 00000 00001 1100
p 01 00000 00001 0B30
#
# Jump unconditional to common code to writeback the EA Byte
p 00 00000 00001 0B3E
p 01 00000 00001 1000
p 01 00000 00001 090D
#
#
# -----------------------------------------------------
#
# ROR - REG8/MEM8 , CL
#
# -----------------------------------------------------
#
#
# Write to clock counter to equal 8 clocks for this instruction
p 00 00000 00001 0B3F
p 01 00000 00001 5FFF
p 01 00000 00001 C040
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0B40
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# r3 <= CX AND 00FF - Isolate the iteration counter into r3
p 00 00000 00001 0B41
p 01 00000 00001 4C2F
p 01 00000 00001 00FF
#
# TOP: Jump if last_alu zero to common code to writeback the EA Byte
p 00 00000 00001 0B42
p 01 00000 00001 1002
p 01 00000 00001 090D
#
# CALL ROR8,1
p 00 00000 00001 0B43
p 01 00000 00001 1100
p 01 00000 00001 0B30
#
# Write to clock counter to equal 4 clocks for this instruction
p 00 00000 00001 0B44
p 01 00000 00001 5FFF
p 01 00000 00001 C020
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0B45
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# zero out r0[15:8] so it does not wrap around to bit 0
p 00 00000 00001 0B46
p 01 00000 00001 499F
p 01 00000 00001 00FF
#
# Subtract r3 = r3 - 1 (( Add FFFF ))
p 00 00000 00001 0B47
p 01 00000 00001 2CCF
p 01 00000 00001 FFFF
#
# Jump unconditional to TOP:
p 00 00000 00001 0B48
p 01 00000 00001 1000
p 01 00000 00001 0B42
#
# -----------------------------------------------------
#
# Procedure RCL8,1 
#
# -----------------------------------------------------
#
# Isolate current Carry bit into r1
p 00 00000 00001 0B50
p 01 00000 00001 4A8F
p 01 00000 00001 0001
#
# Zero the CF and OF Flags
p 00 00000 00001 0B51
p 01 00000 00001 488F
p 01 00000 00001 F7FE
#
# Isolate r0[7] into Dummy
p 00 00000 00001 0B52
p 01 00000 00001 4E9F
p 01 00000 00001 0080
#
# Jump if zero over next instruction
p 00 00000 00001 0B53
p 01 00000 00001 1002
p 01 00000 00001 0B55
#
# Set the CF Flag to 1
p 00 00000 00001 0B54
p 01 00000 00001 588F
p 01 00000 00001 0001
#
# Shift r0 to the left 1 bit
p 00 00000 00001 0B55
p 01 00000 00001 2999
p 01 00000 00001 0000
#
# r0 <= r0 OR r1 - OR in the CF stored in r1
p 00 00000 00001 0B56
p 01 00000 00001 599A
p 01 00000 00001 0000
#
# Isolate the Overflow8 flag from System Signals into Dummy
p 00 00000 00001 0B57
p 01 00000 00001 4EEF
p 01 00000 00001 0200
#
# if alu_last_result is zero then jump over next instruction
p 00 00000 00001 0B58
p 01 00000 00001 1002
p 01 00000 00001 0B5A
#
# Set the Overflow Flag bit to a 1
p 00 00000 00001 0B59
p 01 00000 00001 588F
p 01 00000 00001 0800
#
# Return to calling code
p 00 00000 00001 0B5A
p 01 00000 00001 1030
p 01 00000 00001 0000
#
#
#
#
# -----------------------------------------------------
#
# RCL - REG8/MEM8 , 1
#
# -----------------------------------------------------
#
# CALL RCL8,1
p 00 00000 00001 0B5B
p 01 00000 00001 1100
p 01 00000 00001 0B50
#
# Jump unconditional to common code to writeback the EA Byte
p 00 00000 00001 0B5C
p 01 00000 00001 1000
p 01 00000 00001 090D
#
#
# -----------------------------------------------------
#
# RCL - REG8/MEM8 , CL
#
# -----------------------------------------------------
#
#
# Write to clock counter to equal 8 clocks for this instruction
p 00 00000 00001 0B5D
p 01 00000 00001 5FFF
p 01 00000 00001 C040
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0B5E
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# r3 <= CX AND 00FF - Isolate the iteration counter into r3
p 00 00000 00001 0B5F
p 01 00000 00001 4C2F
p 01 00000 00001 00FF
#
# TOP: Jump if last_alu zero to common code to writeback the EA Byte
p 00 00000 00001 0B60
p 01 00000 00001 1002
p 01 00000 00001 090D
#
# CALL RCL8,1
p 00 00000 00001 0B61
p 01 00000 00001 1100
p 01 00000 00001 0B50
#
# Write to clock counter to equal 4 clocks for this instruction
p 00 00000 00001 0B62
p 01 00000 00001 5FFF
p 01 00000 00001 C020
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0B63
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# zero out r0[15:8] so it does not wrap around to bit 0
p 00 00000 00001 0B64
p 01 00000 00001 499F
p 01 00000 00001 00FF
#
# Subtract r3 = r3 - 1 (( Add FFFF ))
p 00 00000 00001 0B65
p 01 00000 00001 2CCF
p 01 00000 00001 FFFF
#
# Jump unconditional to TOP:
p 00 00000 00001 0B66
p 01 00000 00001 1000
p 01 00000 00001 0B60
#
# -----------------------------------------------------
#
# Procedure RCR8,1 
#
# -----------------------------------------------------
#
# Clear r1 to 0x0000
p 00 00000 00001 0B6A
p 01 00000 00001 5AFF
p 01 00000 00001 0000
#
# Isolate current Carry bit into Dummy
p 00 00000 00001 0B6B
p 01 00000 00001 4E8F
p 01 00000 00001 0001
#
# Jump if zero over next instruction
p 00 00000 00001 0B6C
p 01 00000 00001 1002
p 01 00000 00001 0B6E
#
# Set r1 to 0x0080    - Store the final bit[7]
p 00 00000 00001 0B6D
p 01 00000 00001 5AFF
p 01 00000 00001 0080
#
# Zero the CF and OF Flags
p 00 00000 00001 0B6E
p 01 00000 00001 488F
p 01 00000 00001 F7FE
#
# Isolate r0[7] into r2 - Store the final bit[6]
p 00 00000 00001 0B6F
p 01 00000 00001 4B9F
p 01 00000 00001 0080
#
# Isolate r0[0] into Dummy
p 00 00000 00001 0B70
p 01 00000 00001 4E9F
p 01 00000 00001 0001
#
# Jump if zero over next instruction
p 00 00000 00001 0B71
p 01 00000 00001 1002
p 01 00000 00001 0B73
#
# Set the CF Flag to 1
p 00 00000 00001 0B72
p 01 00000 00001 588F
p 01 00000 00001 0001
#
# Shift r0 to the right 1 bit
p 00 00000 00001 0B73
p 01 00000 00001 7999
p 01 00000 00001 0000
#
# r0 <= r0 OR r1 - OR in the CF stored in r1
p 00 00000 00001 0B74
p 01 00000 00001 599A
p 01 00000 00001 0000
#
# r1 XOR r2 into Dummy - See if final result[7] not equal to [6] for Overflow
p 00 00000 00001 0B75
p 01 00000 00001 6EAB
p 01 00000 00001 0200
#
# if alu_last_result is zero then jump over next instruction
p 00 00000 00001 0B76
p 01 00000 00001 1002
p 01 00000 00001 0B78
#
# Set the Overflow Flag bit to a 1
p 00 00000 00001 0B77
p 01 00000 00001 588F
p 01 00000 00001 0800
#
# Return to calling code
p 00 00000 00001 0B78
p 01 00000 00001 1030
p 01 00000 00001 0000
#
#
#
# -----------------------------------------------------
#
# RCR - REG8/MEM8 , 1
#
# -----------------------------------------------------
#
# CALL RCR8,1
p 00 00000 00001 0B79
p 01 00000 00001 1100
p 01 00000 00001 0B6A
#
# Jump unconditional to common code to writeback the EA Byte
p 00 00000 00001 0B7A
p 01 00000 00001 1000
p 01 00000 00001 090D
#
#
# -----------------------------------------------------
#
# RCR - REG8/MEM8 , CL
#
# -----------------------------------------------------
#
#
# Write to clock counter to equal 8 clocks for this instruction
p 00 00000 00001 0B7B
p 01 00000 00001 5FFF
p 01 00000 00001 C040
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0B7C
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# r3 <= CX AND 00FF - Isolate the iteration counter into r3
p 00 00000 00001 0B7D
p 01 00000 00001 4C2F
p 01 00000 00001 00FF
#
# TOP: Jump if last_alu zero to common code to writeback the EA Byte
p 00 00000 00001 0B7E
p 01 00000 00001 1002
p 01 00000 00001 090D
#
# CALL RCR8,1
p 00 00000 00001 0B7F
p 01 00000 00001 1100
p 01 00000 00001 0B6A
#
# Write to clock counter to equal 4 clocks for this instruction
p 00 00000 00001 0B80
p 01 00000 00001 5FFF
p 01 00000 00001 C020
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0B81
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# zero out r0[15:8] so it does not wrap around to bit 0
p 00 00000 00001 0B82
p 01 00000 00001 499F
p 01 00000 00001 00FF
#
# Subtract r3 = r3 - 1 (( Add FFFF ))
p 00 00000 00001 0B83
p 01 00000 00001 2CCF
p 01 00000 00001 FFFF
#
# Jump unconditional to TOP:
p 00 00000 00001 0B84
p 01 00000 00001 1000
p 01 00000 00001 0B7E
#
#
# -----------------------------------------------------
#
# Procedure SAL8,1
#
# -----------------------------------------------------
#
# Set the eu_flag_temp Flag to 0
p 00 00000 00001 0B88
p 01 00000 00001 488F
p 01 00000 00001 FFFD
#
# Isolate r0[7] into Dummy 
p 00 00000 00001 0B89
p 01 00000 00001 4E9F
p 01 00000 00001 0080
#
# Jump if zero over next instructions
p 00 00000 00001 0B8A
p 01 00000 00001 1002
p 01 00000 00001 0B8C
#
# Set the eu_flag_temp Flag to 1 - To store the Carry Flag bit
p 00 00000 00001 0B8B
p 01 00000 00001 588F
p 01 00000 00001 0002
#
# Shift r0 to the left 1 bit
p 00 00000 00001 0B8C
p 01 00000 00001 2999
p 01 00000 00001 0000
#
# CALL CALCULATE_FLAGS_BYTE
p 00 00000 00001 0B8D
p 01 00000 00001 1100
p 01 00000 00001 0990
#
# Zero the CF Flag
p 00 00000 00001 0B8E
p 01 00000 00001 488F
p 01 00000 00001 FFFE
#
# Isolate Flags - eu_flag_temp Bit into Dummy 
p 00 00000 00001 0B8F
p 01 00000 00001 4E8F
p 01 00000 00001 0002
#
# Jump if zero over next instruction
p 00 00000 00001 0B90
p 01 00000 00001 1002
p 01 00000 00001 0B92
#
# Set the CF Flag to 1
p 00 00000 00001 0B91
p 01 00000 00001 588F
p 01 00000 00001 0001
#
# Set the eu_flag_temp Flag back to 0
p 00 00000 00001 0B92
p 01 00000 00001 488F
p 01 00000 00001 FFFD
#
# Return to calling code
p 00 00000 00001 0B93
p 01 00000 00001 1030
p 01 00000 00001 0000
#
#
#
# -----------------------------------------------------
#
# SAL - REG8/MEM8 , 1
#
# -----------------------------------------------------
#
# CALL SAL8,1
p 00 00000 00001 0B94
p 01 00000 00001 1100
p 01 00000 00001 0B88
#
# Jump unconditional to common code to writeback the EA Byte
p 00 00000 00001 0B95
p 01 00000 00001 1000
p 01 00000 00001 090D
#
#
# -----------------------------------------------------
#
# SAL - REG8/MEM8 , CL
#
# -----------------------------------------------------
#
#
# Write to clock counter to equal 8 clocks for this instruction
p 00 00000 00001 0B96
p 01 00000 00001 5FFF
p 01 00000 00001 C040
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0B97
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# r1 <= CX AND 00FF - Isolate the iteration counter into r1
p 00 00000 00001 0B98
p 01 00000 00001 4A2F
p 01 00000 00001 00FF
#
# TOP: Jump if last_alu zero to common code to writeback the EA Byte
p 00 00000 00001 0B99
p 01 00000 00001 1002
p 01 00000 00001 090D
#
# CALL SAL8,1
p 00 00000 00001 0B9A
p 01 00000 00001 1100
p 01 00000 00001 0B88
#
# Write to clock counter to equal 4 clocks for this instruction
p 00 00000 00001 0B9B
p 01 00000 00001 5FFF
p 01 00000 00001 C020
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0B9C
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# zero out r0[15:8] so it does not wrap around to bit 0
p 00 00000 00001 0B9D
p 01 00000 00001 499F
p 01 00000 00001 00FF
#
# Subtract r1 = r1 - 1 (( Add FFFF ))
p 00 00000 00001 0B9E
p 01 00000 00001 2AAF
p 01 00000 00001 FFFF
#
# Jump unconditional to TOP:
p 00 00000 00001 0B9F
p 01 00000 00001 1000
p 01 00000 00001 0B99
#
#
#
# -----------------------------------------------------
#
# Procedure SHR8,1
#
# -----------------------------------------------------
#
# Set the eu_flag_temp Flag to 0
p 00 00000 00001 0BA4
p 01 00000 00001 488F
p 01 00000 00001 FFFD
#
# Isolate r0[0] into Dummy 
p 00 00000 00001 0BA5
p 01 00000 00001 4E9F
p 01 00000 00001 0001
#
# Jump if zero over next instructions
p 00 00000 00001 0BA6
p 01 00000 00001 1002
p 01 00000 00001 0BA8
#
# Set the eu_flag_temp Flag to 1 - To store the Carry Flag bit
p 00 00000 00001 0BA7
p 01 00000 00001 588F
p 01 00000 00001 0002
#
# Shift r0 to the right 1 bit
p 00 00000 00001 0BA8
p 01 00000 00001 7999
p 01 00000 00001 0000
#
# CALL CALCULATE_FLAGS_BYTE
p 00 00000 00001 0BA9
p 01 00000 00001 1100
p 01 00000 00001 0990
#
# Zero the CF and OF Flags
p 00 00000 00001 0BAA
p 01 00000 00001 488F
p 01 00000 00001 F7FE
#
# Isolate Flags - eu_flag_temp Bit into Dummy 
p 00 00000 00001 0BAB
p 01 00000 00001 4E8F
p 01 00000 00001 0002
#
# Jump if zero over next instructions
p 00 00000 00001 0BAC
p 01 00000 00001 1002
p 01 00000 00001 0BAE
#
# Set the CF Flag to 1
p 00 00000 00001 0BAD
p 01 00000 00001 588F
p 01 00000 00001 0001
#
# Set the eu_flag_temp Flag back to 0
p 00 00000 00001 0BAE
p 01 00000 00001 488F
p 01 00000 00001 FFFD
#
#
# Isolate r0[7:6] into Dummy for OV Calculation
p 00 00000 00001 0BAF
p 01 00000 00001 4E9F
p 01 00000 00001 00C0
#
# Isolate System Signals Parity Flag into Dummy
p 00 00000 00001 0BB0
p 01 00000 00001 4EEF
p 01 00000 00001 0004
#
# Jump if non-zero over next instructions
p 00 00000 00001 0BB1
p 01 00000 00001 1001
p 01 00000 00001 0BB3
#
# Set the Overflow Flag to 1
p 00 00000 00001 0BB2
p 01 00000 00001 588F
p 01 00000 00001 0800
#
# Return to calling code
p 00 00000 00001 0BB3
p 01 00000 00001 1030
p 01 00000 00001 0000
#
#
#
# -----------------------------------------------------
#
# SHR - REG8/MEM8 , 1
#
# -----------------------------------------------------
#
# CALL SHR8,1
p 00 00000 00001 0BB4
p 01 00000 00001 1100
p 01 00000 00001 0BA4
#
# Jump unconditional to common code to writeback the EA Byte
p 00 00000 00001 0BB5
p 01 00000 00001 1000
p 01 00000 00001 090D
#
#
# -----------------------------------------------------
#
# SHR - REG8/MEM8 , CL
#
# -----------------------------------------------------
#
#
# Write to clock counter to equal 8 clocks for this instruction
p 00 00000 00001 0BB6
p 01 00000 00001 5FFF
p 01 00000 00001 C040
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0BB7
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# r1 <= CX AND 00FF - Isolate the iteration counter into r1
p 00 00000 00001 0BB8
p 01 00000 00001 4A2F
p 01 00000 00001 00FF
#
# TOP: Jump if last_alu zero to common code to writeback the EA Byte
p 00 00000 00001 0BB9
p 01 00000 00001 1002
p 01 00000 00001 090D
#
# CALL SHR8,1
p 00 00000 00001 0BBA
p 01 00000 00001 1100
p 01 00000 00001 0BA4
#
# Write to clock counter to equal 4 clocks for this instruction
p 00 00000 00001 0BBB
p 01 00000 00001 5FFF
p 01 00000 00001 C020
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0BBC
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# zero out r0[15:8] so it does not wrap around to bit 0
p 00 00000 00001 0BBD
p 01 00000 00001 499F
p 01 00000 00001 00FF
#
# Subtract r1 = r1 - 1 (( Add FFFF ))
p 00 00000 00001 0BBE
p 01 00000 00001 2AAF
p 01 00000 00001 FFFF
#
# Jump unconditional to TOP:
p 00 00000 00001 0BBF
p 01 00000 00001 1000
p 01 00000 00001 0BB9
#
# -----------------------------------------------------
#
# Procedure SAR8,1 
#
# -----------------------------------------------------
#
# Set the eu_flag_temp Flag to 0
p 00 00000 00001 0BC4
p 01 00000 00001 488F
p 01 00000 00001 FFFD
#
# Isolate r0[0] into Dummy 
p 00 00000 00001 0BC5
p 01 00000 00001 4E9F
p 01 00000 00001 0001
#
# Jump if zero over next instruction
p 00 00000 00001 0BC6
p 01 00000 00001 1002
p 01 00000 00001 0BC8
#
# Set the eu_flag_temp Flag to 1 - To store the Carry Flag bit
p 00 00000 00001 0BC7
p 01 00000 00001 588F
p 01 00000 00001 0002
#
# Shift r0 to the right 1 bit
p 00 00000 00001 0BC8
p 01 00000 00001 7999
p 01 00000 00001 0000
#
# Isolate r0[6] into Dummy 
p 00 00000 00001 0BC9
p 01 00000 00001 4E9F
p 01 00000 00001 0040
#
# Jump if zero over next instruction
p 00 00000 00001 0BCA
p 01 00000 00001 1002
p 01 00000 00001 0BCC
#
# Set r0[7] to a 1
p 00 00000 00001 0BCB
p 01 00000 00001 599F
p 01 00000 00001 0080
#
# r0 <= r0 or 0000 - Set last_alu for Flags setting
p 00 00000 00001 0BCC
p 01 00000 00001 59F9
p 01 00000 00001 0000
#
# CALL CALCULATE_FLAGS_BYTE
p 00 00000 00001 0BCD
p 01 00000 00001 1100
p 01 00000 00001 0990
#
# Zero the CF and OF Flags
p 00 00000 00001 0BCE
p 01 00000 00001 488F
p 01 00000 00001 F7FE
#
# Isolate Flags - eu_flag_temp Bit into Dummy 
p 00 00000 00001 0BCF
p 01 00000 00001 4E8F
p 01 00000 00001 0002
#
# Jump if zero over next instruction
p 00 00000 00001 0BD0
p 01 00000 00001 1002
p 01 00000 00001 0BD2
#
# Set the CF Flag to 1
p 00 00000 00001 0BD1
p 01 00000 00001 588F
p 01 00000 00001 0001
#
# Set the eu_flag_temp Flag back to 0
p 00 00000 00001 0BD2
p 01 00000 00001 488F
p 01 00000 00001 FFFD
#
# Return to calling code
p 00 00000 00001 0BD3
p 01 00000 00001 1030
p 01 00000 00001 0000
#
#
#
# -----------------------------------------------------
#
# SAR - REG8/MEM8 , 1
#
# -----------------------------------------------------
#
# CALL SAR8,1
p 00 00000 00001 0BD7
p 01 00000 00001 1100
p 01 00000 00001 0BC4
#
# Jump unconditional to common code to writeback the EA Byte
p 00 00000 00001 0BD8
p 01 00000 00001 1000
p 01 00000 00001 090D
#
#
# -----------------------------------------------------
#
# SAR - REG8/MEM8 , CL
#
# -----------------------------------------------------
#
#
# Write to clock counter to equal 8 clocks for this instruction
p 00 00000 00001 0BD9
p 01 00000 00001 5FFF
p 01 00000 00001 C040
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0BDA
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# r1 <= CX AND 00FF - Isolate the iteration counter into r1
p 00 00000 00001 0BDB
p 01 00000 00001 4A2F
p 01 00000 00001 00FF
#
# TOP: Jump if last_alu zero to common code to writeback the EA Byte
p 00 00000 00001 0BDC
p 01 00000 00001 1002
p 01 00000 00001 090D
#
# CALL SAR8,1
p 00 00000 00001 0BDD
p 01 00000 00001 1100
p 01 00000 00001 0BC4
#
# Write to clock counter to equal 4 clocks for this instruction
p 00 00000 00001 0BDE
p 01 00000 00001 5FFF
p 01 00000 00001 C020
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0BDF
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# zero out r0[15:8] so it does not wrap around to bit 0
p 00 00000 00001 0BE0
p 01 00000 00001 499F
p 01 00000 00001 00FF
#
# Subtract r1 = r1 - 1 (( Add FFFF ))
p 00 00000 00001 0BE1
p 01 00000 00001 2AAF
p 01 00000 00001 FFFF
#
# Jump unconditional to TOP:
p 00 00000 00001 0BE2
p 01 00000 00001 1000
p 01 00000 00001 0BDC
#
# -----------------------------------------------------
#
# GROUP Opcode - 0xD1
#
#
# Common microcode processed first. Then Jump Type 6 used
# to decode the REG Field to a Jump table where specific
# microcode is processed for that opcode type.
#
#
# -----------------------------------------------------
#
# CALL CALC_EA_WORD
p 00 00000 00001 0BE6
p 01 00000 00001 1100
p 01 00000 00001 0762
#
# CALL FETCH_EA_WORD into r0
p 00 00000 00001 0BE7
p 01 00000 00001 1100
p 01 00000 00001 0792
#
# Copy r1 to the biu_dataout register - Store the Addressing Byte for the Jump-6
p 00 00000 00001 0BE8
p 01 00000 00001 5FFA
p 01 00000 00001 0000
#
# Jump-Type6 to Jump Table for 0xD1 opcodes: Base address at 0x0BF0
p 00 00000 00001 0BE9
p 01 00000 00001 1060
p 01 00000 00001 0BF0
#
#
#
# -----------------------------------------------------
#
# GROUP Opcode - 0xD3 
#
#
# Common microcode processed first. Then Jump Type 6 used
# to decode the REG Field to a Jump table where specific
# microcode is processed for that opcode type.
#
#
# -----------------------------------------------------
#
# CALL CALC_EA_WORD
p 00 00000 00001 0BEA
p 01 00000 00001 1100
p 01 00000 00001 0762
#
# CALL FETCH_EA_WORD into r0
p 00 00000 00001 0BEB
p 01 00000 00001 1100
p 01 00000 00001 0792
#
# Copy r1 to the biu_dataout register - Store the Addressing Byte for the Jump-6
p 00 00000 00001 0BEC
p 01 00000 00001 5FFA
p 01 00000 00001 0000
#
# Jump-Type6 to Jump Table for 0xD3 opcodes: Base address at 0x0BF8
p 00 00000 00001 0BED
p 01 00000 00001 1060
p 01 00000 00001 0BF8
#
#
#
# Jump Table for 0xD1 Opcodes decoded using the REG Field of the Addressing Byte
#
# ROL REG16/MEM16,1
p 00 00000 00001 0BF0
p 01 00000 00001 1000
p 01 00000 00001 0C0C
#
# ROR REG16/MEM16,1
p 00 00000 00001 0BF1
p 01 00000 00001 1000
p 01 00000 00001 0C18
#
# RCL REG16/MEM16,1
p 00 00000 00001 0BF2
p 01 00000 00001 1000
p 01 00000 00001 0C32
#
# RCR REG16/MEM16,1
p 00 00000 00001 0BF3
p 01 00000 00001 1000
p 01 00000 00001 0C4F
#
# SAL REG16/MEM16,1
p 00 00000 00001 0BF4
p 01 00000 00001 1000
p 01 00000 00001 0C6C
#
# SHR REG16/MEM16,1
p 00 00000 00001 0BF5
p 01 00000 00001 1000
p 01 00000 00001 0C8D
#
# SHR REG16/MEM16,1 - unused
p 00 00000 00001 0BF6
p 01 00000 00001 1000
p 01 00000 00001 0C8D
#
# SAR REG16/MEM16,1
p 00 00000 00001 0BF7
p 01 00000 00001 1000
p 01 00000 00001 0CAA
#
#
# Jump Table for 0xD3 Opcodes decoded using the REG Field of the Addressing Byte
#
# ROL REG16/MEM16,CL
p 00 00000 00001 0BF8
p 01 00000 00001 1000
p 01 00000 00001 0C0E
#
# ROR REG16/MEM16,CL
p 00 00000 00001 0BF9
p 01 00000 00001 1000
p 01 00000 00001 0C1A
#
# RCL REG16/MEM16,CL
p 00 00000 00001 0BFA
p 01 00000 00001 1000
p 01 00000 00001 0C34
#
# RCR REG16/MEM16,CL
p 00 00000 00001 0BFB
p 01 00000 00001 1000
p 01 00000 00001 0C51
#
# SAL REG16/MEM16,CL
p 00 00000 00001 0BFC
p 01 00000 00001 1000
p 01 00000 00001 0C6E
#
# SHR REG16/MEM16,CL
p 00 00000 00001 0BFD
p 01 00000 00001 1000
p 01 00000 00001 0C8F
#
# SHR REG16/MEM16,CL - unused
p 00 00000 00001 0BFE
p 01 00000 00001 1000
p 01 00000 00001 0C8F
#
# SAR REG16/MEM16,CL
p 00 00000 00001 0BFF
p 01 00000 00001 1000
p 01 00000 00001 0CAC
#
#
# -----------------------------------------------------
#
# Procedure ROL16,1 
#
# -----------------------------------------------------
#
# Zero the CF and OF Flags
p 00 00000 00001 0C00
p 01 00000 00001 488F
p 01 00000 00001 F7FE
#
# Set r1 to 0x0000
p 00 00000 00001 0C01
p 01 00000 00001 5AFF
p 01 00000 00001 0000
#
# Isolate r0[15] into Dummy
p 00 00000 00001 0C02
p 01 00000 00001 4E9F
p 01 00000 00001 8000
#
# Jump if zero over next instructions
p 00 00000 00001 0C03
p 01 00000 00001 1002
p 01 00000 00001 0C06
#
# Set the CF Flag to 1
p 00 00000 00001 0C04
p 01 00000 00001 588F
p 01 00000 00001 0001
#
# Set r1 to 0x0001
p 00 00000 00001 0C05
p 01 00000 00001 5AFF
p 01 00000 00001 0001
#
# Shift r0 to the left 1 bit
p 00 00000 00001 0C06
p 01 00000 00001 2999
p 01 00000 00001 0000
#
# r0 <= r0 OR r1 - OR in the CF stored in r1
p 00 00000 00001 0C07
p 01 00000 00001 599A
p 01 00000 00001 0000
#
# Isolate the Overflow16 flag from System Signals into Dummy
p 00 00000 00001 0C08
p 01 00000 00001 4EEF
p 01 00000 00001 0800
#
# if alu_last_result is zero then jump over next instruction
p 00 00000 00001 0C09
p 01 00000 00001 1002
p 01 00000 00001 0C0B
#
# Set the Overflow Flag bit to a 1
p 00 00000 00001 0C0A
p 01 00000 00001 588F
p 01 00000 00001 0800
#
# Return to calling code
p 00 00000 00001 0C0B
p 01 00000 00001 1030
p 01 00000 00001 0000
#
#
# -----------------------------------------------------
#
# ROL - REG8/MEM16 , 1
#
# -----------------------------------------------------
#
# CALL ROL16,1
p 00 00000 00001 0C0C
p 01 00000 00001 1100
p 01 00000 00001 0C00
#
# Jump unconditional to common code to writeback the EA Word
p 00 00000 00001 0C0D
p 01 00000 00001 1000
p 01 00000 00001 091C
#
#
# -----------------------------------------------------
#
# ROL - REG8/MEM16 , CL
#
# -----------------------------------------------------
#
#
# Write to clock counter to equal 8 clocks for this instruction
p 00 00000 00001 0C0E
p 01 00000 00001 5FFF
p 01 00000 00001 C040
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0C0F
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# r3 <= CX AND 00FF - Isolate the iteration counter into r3
p 00 00000 00001 0C10
p 01 00000 00001 4C2F
p 01 00000 00001 00FF
#
# TOP: Jump if last_alu zero to common code to writeback the EA Word
p 00 00000 00001 0C11
p 01 00000 00001 1002
p 01 00000 00001 091C
#
# CALL ROL16,1
p 00 00000 00001 0C12
p 01 00000 00001 1100
p 01 00000 00001 0C00
#
# Write to clock counter to equal 4 clocks for this instruction
p 00 00000 00001 0C13
p 01 00000 00001 5FFF
p 01 00000 00001 C020
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0C14
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Subtract r3 = r3 - 1 (( Add FFFF ))
p 00 00000 00001 0C15
p 01 00000 00001 2CCF
p 01 00000 00001 FFFF
#
# Jump unconditional to TOP:
p 00 00000 00001 0C16
p 01 00000 00001 1000
p 01 00000 00001 0C11
#
#
#
# -----------------------------------------------------
#
# ROR - REG16/MEM16 , 1
#
# -----------------------------------------------------
#
# CALL ROR16,1
p 00 00000 00001 0C18
p 01 00000 00001 1100
p 01 00000 00001 0F46
#
# Jump unconditional to common code to writeback the EA Word
p 00 00000 00001 0C19
p 01 00000 00001 1000
p 01 00000 00001 091C
#
#
# -----------------------------------------------------
#
# ROR - REG16/MEM16 , CL
#
# -----------------------------------------------------
#
#
# Write to clock counter to equal 8 clocks for this instruction
p 00 00000 00001 0C1A
p 01 00000 00001 5FFF
p 01 00000 00001 C040
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0C1B
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# r3 <= CX AND 00FF - Isolate the iteration counter into r3
p 00 00000 00001 0C1C
p 01 00000 00001 4C2F
p 01 00000 00001 00FF
#
# TOP: Jump if last_alu zero to common code to writeback the EA Word
p 00 00000 00001 0C1D
p 01 00000 00001 1002
p 01 00000 00001 091C
#
# CALL ROR16,1
p 00 00000 00001 0C1E
p 01 00000 00001 1100
p 01 00000 00001 0F46
#
# Write to clock counter to equal 4 clocks for this instruction
p 00 00000 00001 0C1F
p 01 00000 00001 5FFF
p 01 00000 00001 C020
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0C20
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Subtract r3 = r3 - 1 (( Add FFFF ))
p 00 00000 00001 0C21
p 01 00000 00001 2CCF
p 01 00000 00001 FFFF
#
# Jump unconditional to TOP:
p 00 00000 00001 0C22
p 01 00000 00001 1000
p 01 00000 00001 0C1D
#
# -----------------------------------------------------
#
# Procedure RCL16,1 
#
# -----------------------------------------------------
#

# Isolate current Carry bit into r1
p 00 00000 00001 0C27
p 01 00000 00001 4A8F
p 01 00000 00001 0001
#
# Zero the CF and OF Flags
p 00 00000 00001 0C28
p 01 00000 00001 488F
p 01 00000 00001 F7FE
#
# Isolate r0[15] into Dummy
p 00 00000 00001 0C29
p 01 00000 00001 4E9F
p 01 00000 00001 8000
#
# Jump if zero over next instruction
p 00 00000 00001 0C2A
p 01 00000 00001 1002
p 01 00000 00001 0C2C
#
# Set the CF Flag to 1
p 00 00000 00001 0C2B
p 01 00000 00001 588F
p 01 00000 00001 0001
#
# Shift r0 to the left 1 bit
p 00 00000 00001 0C2C
p 01 00000 00001 2999
p 01 00000 00001 0000
#
# r0 <= r0 OR r1 - OR in the CF stored in r1
p 00 00000 00001 0C2D
p 01 00000 00001 599A
p 01 00000 00001 0000
#
# Isolate the Overflow16 flag from System Signals into Dummy
p 00 00000 00001 0C2E
p 01 00000 00001 4EEF
p 01 00000 00001 0800
#
# if alu_last_result is zero then jump over next instruction
p 00 00000 00001 0C2F
p 01 00000 00001 1002
p 01 00000 00001 0C31
#
# Set the Overflow Flag bit to a 1
p 00 00000 00001 0C30
p 01 00000 00001 588F
p 01 00000 00001 0800
#
# Return to calling code
p 00 00000 00001 0C31
p 01 00000 00001 1030
p 01 00000 00001 0000
#
#
#
# -----------------------------------------------------
#
# RCL - REG16/MEM16 , 1
#
# -----------------------------------------------------
#
# CALL RCL16,1
p 00 00000 00001 0C32
p 01 00000 00001 1100
p 01 00000 00001 0C27
#
# Jump unconditional to common code to writeback the EA Word
p 00 00000 00001 0C33
p 01 00000 00001 1000
p 01 00000 00001 091C
#
#
# -----------------------------------------------------
#
# RCL - REG16/MEM16 , CL
#
# -----------------------------------------------------
#
#
# Write to clock counter to equal 8 clocks for this instruction
p 00 00000 00001 0C34
p 01 00000 00001 5FFF
p 01 00000 00001 C040
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0C35
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# r3 <= CX AND 00FF - Isolate the iteration counter into r3
p 00 00000 00001 0C36
p 01 00000 00001 4C2F
p 01 00000 00001 00FF
#
# TOP: Jump if last_alu zero to common code to writeback the EA Word
p 00 00000 00001 0C37
p 01 00000 00001 1002
p 01 00000 00001 091C
#
# CALL RCL16,1
p 00 00000 00001 0C38
p 01 00000 00001 1100
p 01 00000 00001 0C27
#
# Write to clock counter to equal 4 clocks for this instruction
p 00 00000 00001 0C39
p 01 00000 00001 5FFF
p 01 00000 00001 C020
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0C3A
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Subtract r3 = r3 - 1 (( Add FFFF ))
p 00 00000 00001 0C3B
p 01 00000 00001 2CCF
p 01 00000 00001 FFFF
#
# Jump unconditional to TOP:
p 00 00000 00001 0C3C
p 01 00000 00001 1000
p 01 00000 00001 0C37
#
# -----------------------------------------------------
#
# Procedure RCR16,1 
#
# -----------------------------------------------------
#
# Clear r1 to 0x0000
p 00 00000 00001 0C40
p 01 00000 00001 5AFF
p 01 00000 00001 0000
#
# Isolate current Carry bit into Dummy
p 00 00000 00001 0C41
p 01 00000 00001 4E8F
p 01 00000 00001 0001
#
# Jump if zero over next instruction
p 00 00000 00001 0C42
p 01 00000 00001 1002
p 01 00000 00001 0C44
#
# Set r1 to 0x0080    - Store the final bit[15]
p 00 00000 00001 0C43
p 01 00000 00001 5AFF
p 01 00000 00001 8000
#
# Zero the CF and OF Flags
p 00 00000 00001 0C44
p 01 00000 00001 488F
p 01 00000 00001 F7FE
#
# Isolate r0[15] into r2 - Store the final bit[14]
p 00 00000 00001 0C45
p 01 00000 00001 4B9F
p 01 00000 00001 8000
#
# Isolate r0[0] into Dummy
p 00 00000 00001 0C46
p 01 00000 00001 4E9F
p 01 00000 00001 0001
#
# Jump if zero over next instruction
p 00 00000 00001 0C47
p 01 00000 00001 1002
p 01 00000 00001 0C49
#
# Set the CF Flag to 1
p 00 00000 00001 0C48
p 01 00000 00001 588F
p 01 00000 00001 0001
#
# Shift r0 to the right 1 bit
p 00 00000 00001 0C49
p 01 00000 00001 7999
p 01 00000 00001 0000
#
# r0 <= r0 OR r1 - OR in the CF stored in r1
p 00 00000 00001 0C4A
p 01 00000 00001 599A
p 01 00000 00001 0000
#
# r1 XOR r2 into Dummy - See if final result[15] not equal to [14] for Overflow
p 00 00000 00001 0C4B
p 01 00000 00001 6EAB
p 01 00000 00001 0200
#
# if alu_last_result is zero then jump over next instruction
p 00 00000 00001 0C4C
p 01 00000 00001 1002
p 01 00000 00001 0C4E
#
# Set the Overflow Flag bit to a 1
p 00 00000 00001 0C4D
p 01 00000 00001 588F
p 01 00000 00001 0800
#
# Return to calling code
p 00 00000 00001 0C4E
p 01 00000 00001 1030
p 01 00000 00001 0000
#
#
#
# -----------------------------------------------------
#
# RCR - REG16/MEM16 , 1
#
# -----------------------------------------------------
#
# CALL RCR16,1
p 00 00000 00001 0C4F
p 01 00000 00001 1100
p 01 00000 00001 0C40
#
# Jump unconditional to common code to writeback the EA Word
p 00 00000 00001 0C50
p 01 00000 00001 1000
p 01 00000 00001 091C
#
#
# -----------------------------------------------------
#
# RCR - REG16/MEM16 , CL
#
# -----------------------------------------------------
#
#
# Write to clock counter to equal 8 clocks for this instruction
p 00 00000 00001 0C51
p 01 00000 00001 5FFF
p 01 00000 00001 C040
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0C52
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# r3 <= CX AND 00FF - Isolate the iteration counter into r3
p 00 00000 00001 0C53
p 01 00000 00001 4C2F
p 01 00000 00001 00FF
#
# TOP: Jump if last_alu zero to common code to writeback the EA Word
p 00 00000 00001 0C54
p 01 00000 00001 1002
p 01 00000 00001 091C
#
# CALL RCR16,1
p 00 00000 00001 0C55
p 01 00000 00001 1100
p 01 00000 00001 0C40
#
# Write to clock counter to equal 4 clocks for this instruction
p 00 00000 00001 0C56
p 01 00000 00001 5FFF
p 01 00000 00001 C020
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0C57
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Subtract r3 = r3 - 1 (( Add FFFF ))
p 00 00000 00001 0C58
p 01 00000 00001 2CCF
p 01 00000 00001 FFFF
#
# Jump unconditional to TOP:
p 00 00000 00001 0C59
p 01 00000 00001 1000
p 01 00000 00001 0C54
#
#
# -----------------------------------------------------
#
# Procedure SAL16,1
#
# -----------------------------------------------------
#
# Set the eu_flag_temp Flag to 0
p 00 00000 00001 0C60
p 01 00000 00001 488F
p 01 00000 00001 FFFD
#
# Isolate r0[15] into Dummy 
p 00 00000 00001 0C61
p 01 00000 00001 4E9F
p 01 00000 00001 8000
#
# Jump if zero over next instruction
p 00 00000 00001 0C62
p 01 00000 00001 1002
p 01 00000 00001 0C64
#
# Set the eu_flag_temp Flag to 1 - To store the Carry Flag bit
p 00 00000 00001 0C63
p 01 00000 00001 588F
p 01 00000 00001 0002
#
# Shift r0 to the left 1 bit
p 00 00000 00001 0C64
p 01 00000 00001 2999
p 01 00000 00001 0000
#
# CALL CALCULATE_FLAGS_WORD
p 00 00000 00001 0C65
p 01 00000 00001 1100
p 01 00000 00001 03D3
#
# Zero the CF Flag
p 00 00000 00001 0C66
p 01 00000 00001 488F
p 01 00000 00001 FFFE
#
# Isolate Flags - eu_flag_temp Bit into Dummy 
p 00 00000 00001 0C67
p 01 00000 00001 4E8F
p 01 00000 00001 0002
#
# Jump if zero over next instruction
p 00 00000 00001 0C68
p 01 00000 00001 1002
p 01 00000 00001 0C6A
#
# Set the CF Flag to 1
p 00 00000 00001 0C69
p 01 00000 00001 588F
p 01 00000 00001 0001
#
# Set the eu_flag_temp Flag back to 0
p 00 00000 00001 0C6A
p 01 00000 00001 488F
p 01 00000 00001 FFFD
#
# Return to calling code
p 00 00000 00001 0C6B
p 01 00000 00001 1030
p 01 00000 00001 0000
#
#
#
# -----------------------------------------------------
#
# SAL - REG16/MEM16 , 1
#
# -----------------------------------------------------
#
# CALL SAL16,1
p 00 00000 00001 0C6C
p 01 00000 00001 1100
p 01 00000 00001 0C60
#
# Jump unconditional to common code to writeback the EA Word
p 00 00000 00001 0C6D
p 01 00000 00001 1000
p 01 00000 00001 091C
#
#
# -----------------------------------------------------
#
# SAL - REG16/MEM16 , CL
#
# -----------------------------------------------------
#
#
# Write to clock counter to equal 8 clocks for this instruction
p 00 00000 00001 0C6E
p 01 00000 00001 5FFF
p 01 00000 00001 C040
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0C6F
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# r1 <= CX AND 00FF - Isolate the iteration counter into r1
p 00 00000 00001 0C70
p 01 00000 00001 4A2F
p 01 00000 00001 00FF
#
# TOP: Jump if last_alu zero to common code to writeback the EA Word
p 00 00000 00001 0C71
p 01 00000 00001 1002
p 01 00000 00001 091C
#
# CALL SAL16,1
p 00 00000 00001 0C72
p 01 00000 00001 1100
p 01 00000 00001 0C60
#
# Write to clock counter to equal 4 clocks for this instruction
p 00 00000 00001 0C73
p 01 00000 00001 5FFF
p 01 00000 00001 C020
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0C74
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Subtract r1 = r1 - 1 (( Add FFFF ))
p 00 00000 00001 0C75
p 01 00000 00001 2AAF
p 01 00000 00001 FFFF
#
# Jump unconditional to TOP:
p 00 00000 00001 0C76
p 01 00000 00001 1000
p 01 00000 00001 0C71
#
#


#
#
# -----------------------------------------------------
#
# Procedure SHR16,1
#
# -----------------------------------------------------
#
# Set the eu_flag_temp Flag to 0
p 00 00000 00001 0C7B
p 01 00000 00001 488F
p 01 00000 00001 FFFD
#
# Isolate r0[0] into Dummy 
p 00 00000 00001 0C7C
p 01 00000 00001 4E9F
p 01 00000 00001 0001
#
# Jump if zero over next instructions
p 00 00000 00001 0C7D
p 01 00000 00001 1002
p 01 00000 00001 0C7F
#
# Set the eu_flag_temp Flag to 1 - To store the Carry Flag bit
p 00 00000 00001 0C7E
p 01 00000 00001 588F
p 01 00000 00001 0002
#
# Shift r0 to the right 1 bit
p 00 00000 00001 0C7F
p 01 00000 00001 7999
p 01 00000 00001 0000
#
# CALL CALCULATE_FLAGS_WORD
p 00 00000 00001 0C80
p 01 00000 00001 1100
p 01 00000 00001 03D3
#
# Zero the CF and OF Flags
p 00 00000 00001 0C81
p 01 00000 00001 488F
p 01 00000 00001 F7FE
#
# Isolate Flags - eu_flag_temp Bit into Dummy 
p 00 00000 00001 0C82
p 01 00000 00001 4E8F
p 01 00000 00001 0002
#
# Jump if zero over next instructions
p 00 00000 00001 0C83
p 01 00000 00001 1002
p 01 00000 00001 0C85
#
# Set the CF Flag to 1
p 00 00000 00001 0C84
p 01 00000 00001 588F
p 01 00000 00001 0001
#
# Set the eu_flag_temp Flag back to 0
p 00 00000 00001 0C85
p 01 00000 00001 488F
p 01 00000 00001 FFFD
#
# r0 <= r0 swapped bytes
p 00 00000 00001 0C86
p 01 00000 00001 3999
p 01 00000 00001 0000
#
# Isolate r0[7:6] into Dummy for OV Calculation
p 00 00000 00001 0C87
p 01 00000 00001 4E9F
p 01 00000 00001 00C0
#
# Isolate System Signals Parity Flag from last_alu into Dummy
p 00 00000 00001 0C88
p 01 00000 00001 4EEF
p 01 00000 00001 0004
#
# Jump if non-zero over next instructions
p 00 00000 00001 0C89
p 01 00000 00001 1001
p 01 00000 00001 0C8B
#
# Set the Overflow Flag to 1
p 00 00000 00001 0C8A
p 01 00000 00001 588F
p 01 00000 00001 0800
#
# r0 <= r0 swapped bytes - Put r0 back
p 00 00000 00001 0C8B
p 01 00000 00001 3999
p 01 00000 00001 0000
#
# Return to calling code
p 00 00000 00001 0C8C
p 01 00000 00001 1030
p 01 00000 00001 0000
#
#
#
# -----------------------------------------------------
#
# SHR - REG16/MEM16 , 1
#
# -----------------------------------------------------
#
# CALL SHR16,1
p 00 00000 00001 0C8D
p 01 00000 00001 1100
p 01 00000 00001 0C7B
#
# Jump unconditional to common code to writeback the EA Word
p 00 00000 00001 0C8E
p 01 00000 00001 1000
p 01 00000 00001 091C
#
#
# -----------------------------------------------------
#
# SHR - REG16/MEM16 , CL
#
# -----------------------------------------------------
#
#
# Write to clock counter to equal 8 clocks for this instruction
p 00 00000 00001 0C8F
p 01 00000 00001 5FFF
p 01 00000 00001 C040
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0C90
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# r1 <= CX AND 00FF - Isolate the iteration counter into r1
p 00 00000 00001 0C91
p 01 00000 00001 4A2F
p 01 00000 00001 00FF
#
# TOP: Jump if last_alu zero to common code to writeback the EA Word
p 00 00000 00001 0C92
p 01 00000 00001 1002
p 01 00000 00001 091C
#
# CALL SHR16,1
p 00 00000 00001 0C93
p 01 00000 00001 1100
p 01 00000 00001 0C7B
#
# Write to clock counter to equal 4 clocks for this instruction
p 00 00000 00001 0C94
p 01 00000 00001 5FFF
p 01 00000 00001 C020
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0C95
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Subtract r1 = r1 - 1 (( Add FFFF ))
p 00 00000 00001 0C96
p 01 00000 00001 2AAF
p 01 00000 00001 FFFF
#
# Jump unconditional to TOP:
p 00 00000 00001 0C97
p 01 00000 00001 1000
p 01 00000 00001 0C92
#
# -----------------------------------------------------
#
# Procedure SAR16,1 
#
# -----------------------------------------------------
#
# Set the eu_flag_temp Flag to 0
p 00 00000 00001 0C9A
p 01 00000 00001 488F
p 01 00000 00001 FFFD
#
# Isolate r0[0] into Dummy 
p 00 00000 00001 0C9B
p 01 00000 00001 4E9F
p 01 00000 00001 0001
#
# Jump if zero over next instruction
p 00 00000 00001 0C9C
p 01 00000 00001 1002
p 01 00000 00001 0C9E
#
# Set the eu_flag_temp Flag to 1 - To store the Carry Flag bit
p 00 00000 00001 0C9D
p 01 00000 00001 588F
p 01 00000 00001 0002
#
# Shift r0 to the right 1 bit
p 00 00000 00001 0C9E
p 01 00000 00001 7999
p 01 00000 00001 0000
#
# Isolate r0[14] into Dummy 
p 00 00000 00001 0C9F
p 01 00000 00001 4E9F
p 01 00000 00001 4000
#
# Jump if zero over next instruction
p 00 00000 00001 0CA0
p 01 00000 00001 1002
p 01 00000 00001 0CA2
#
# Set r0[15] to a 1
p 00 00000 00001 0CA1
p 01 00000 00001 599F
p 01 00000 00001 8000
#
# r0 <= r0 or 0000 - Set last_alu for Flags setting
p 00 00000 00001 0CA2
p 01 00000 00001 59F9
p 01 00000 00001 0000
#
# CALL CALCULATE_FLAGS_WORD
p 00 00000 00001 0CA3
p 01 00000 00001 1100
p 01 00000 00001 03D3
#
# Zero the CF and OF Flags
p 00 00000 00001 0CA4
p 01 00000 00001 488F
p 01 00000 00001 F7FE
#
# Isolate Flags - eu_flag_temp Bit into Dummy 
p 00 00000 00001 0CA5
p 01 00000 00001 4E8F
p 01 00000 00001 0002
#
# Jump if zero over next instruction
p 00 00000 00001 0CA6
p 01 00000 00001 1002
p 01 00000 00001 0CA8
#
# Set the CF Flag to 1
p 00 00000 00001 0CA7
p 01 00000 00001 588F
p 01 00000 00001 0001
#
# Set the eu_flag_temp Flag back to 0
p 00 00000 00001 0CA8
p 01 00000 00001 488F
p 01 00000 00001 FFFD
#
# Return to calling code
p 00 00000 00001 0CA9
p 01 00000 00001 1030
p 01 00000 00001 0000
#
#
#
# -----------------------------------------------------
#
# SAR - REG16/MEM16 , 1
#
# -----------------------------------------------------
#
# CALL SAR16,1
p 00 00000 00001 0CAA
p 01 00000 00001 1100
p 01 00000 00001 0C9A
#
# Jump unconditional to common code to writeback the EA Word
p 00 00000 00001 0CAB
p 01 00000 00001 1000
p 01 00000 00001 091C
#
#
# -----------------------------------------------------
#
# SAR - REG16/MEM16 , CL
#
# -----------------------------------------------------
#
#
# Write to clock counter to equal 8 clocks for this instruction
p 00 00000 00001 0CAC
p 01 00000 00001 5FFF
p 01 00000 00001 C040
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0CAD
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# r1 <= CX AND 00FF - Isolate the iteration counter into r1
p 00 00000 00001 0CAE
p 01 00000 00001 4A2F
p 01 00000 00001 00FF
#
# TOP: Jump if last_alu zero to common code to writeback the EA Word
p 00 00000 00001 0CAF
p 01 00000 00001 1002
p 01 00000 00001 091C
#
# CALL SAR16,1
p 00 00000 00001 0CB0
p 01 00000 00001 1100
p 01 00000 00001 0C9A
#
# Write to clock counter to equal 4 clocks for this instruction
p 00 00000 00001 0CB1
p 01 00000 00001 5FFF
p 01 00000 00001 C020
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0CB2
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Subtract r1 = r1 - 1 (( Add FFFF ))
p 00 00000 00001 0CB3
p 01 00000 00001 2AAF
p 01 00000 00001 FFFF
#
# Jump unconditional to TOP:
p 00 00000 00001 0CB4
p 01 00000 00001 1000
p 01 00000 00001 0CAF
#


# -----------------------------------------------------
#
# 0xD8 - 0xDF   ESC
#
# -----------------------------------------------------
#
# CALL CALC_EA_WORD
p 00 00000 00001 0CB9
p 01 00000 00001 1100
p 01 00000 00001 0762
#
# CALL FETCH_EA_WORD into r0
p 00 00000 00001 0CBA
p 01 00000 00001 1100
p 01 00000 00001 0792
#
# Jump unconditional to common code
p 00 00000 00001 0CBB
p 01 00000 00001 1000
p 01 00000 00001 093B
#

# -----------------------------------------------------
#
# 0xD6 - SETALC
#
# -----------------------------------------------------
#
# Zero out AL 
p 00 00000 00001 0CBE
p 01 00000 00001 400F
p 01 00000 00001 FF00
#
# Isolate current Carry bit into Dummy
p 00 00000 00001 0CBF
p 01 00000 00001 4E8F
p 01 00000 00001 0001
#
# Jump if zero over next instruction
p 00 00000 00001 0CC0
p 01 00000 00001 1002
p 01 00000 00001 0CC2
#
# Set AL to FF
p 00 00000 00001 0CC1
p 01 00000 00001 500F
p 01 00000 00001 00FF
#
# Jump unconditional to common code
p 00 00000 00001 0CC2
p 01 00000 00001 1000
p 01 00000 00001 005C
#
# -----------------------------------------------------
#
# 0xC4 - LES REG16,MEM16
#
# -----------------------------------------------------
#
# CALL CALC_EA_WORD
p 00 00000 00001 0CC6
p 01 00000 00001 1100
p 01 00000 00001 0762
#
# CALL FETCH_EA_WORD into r0
p 00 00000 00001 0CC7
p 01 00000 00001 1100
p 01 00000 00001 0792
#
# CALL WRITEBACK_REG_WORD
p 00 00000 00001 0CC8
p 01 00000 00001 1100
p 01 00000 00001 0901
#
# r0 = biu_register_rm
p 00 00000 00001 0CC9
p 01 00000 00001 59F5
p 01 00000 00001 0000
# 
# biu_dataout = r0 + 2
p 00 00000 00001 0CCA
p 01 00000 00001 2F9F
p 01 00000 00001 0002
#
# Strobe the biu to update the biu_register_rm value
p 00 00000 00001 0CCB
p 01 00000 00001 5DDF
p 01 00000 00001 3040
#
# Debounce BIU Strobe
p 00 00000 00001 0CCC
p 01 00000 00001 4DDF
p 01 00000 00001 CC0F
#
# CALL FETCH_EA_WORD into r0
p 00 00000 00001 0CCD
p 01 00000 00001 1100
p 01 00000 00001 0792
#
# Copy r0 to the BIU Data Out register to update the segment register in the BIU
p 00 00000 00001 0CCE
p 01 00000 00001 5FF9
p 01 00000 00001 0000
#
# Strobe BIU - Set new ES Segment Register
p 00 00000 00001 0CCF
p 01 00000 00001 5DDF
p 01 00000 00001 3000
#
# Debounce BIU Strobe
p 00 00000 00001 0CD0
p 01 00000 00001 4DDF
p 01 00000 00001 CFF3
#
# Strobe BIU - Fetch Opcode and set QS[1:0] to Subsequent Byte of Opcode 
p 00 00000 00001 0CD1
p 01 00000 00001 5DDF
p 01 00000 00001 100C
#
# Debounce BIU Strobe
p 00 00000 00001 0CD2
p 01 00000 00001 4DDF
p 01 00000 00001 CFF3
#
# Jump unconditional to main microcode loop
p 00 00000 00001 0CD3
p 01 00000 00001 1000
p 01 00000 00001 0004
#
#
# -----------------------------------------------------
#
# 0xC5 - LDS REG16,MEM16
#
# -----------------------------------------------------
#
# CALL CALC_EA_WORD
p 00 00000 00001 0CD6
p 01 00000 00001 1100
p 01 00000 00001 0762
#
# CALL FETCH_EA_WORD into r0
p 00 00000 00001 0CD7
p 01 00000 00001 1100
p 01 00000 00001 0792
#
# CALL WRITEBACK_REG_WORD
p 00 00000 00001 0CD8
p 01 00000 00001 1100
p 01 00000 00001 0901
#
# r0 = biu_register_rm
p 00 00000 00001 0CD9
p 01 00000 00001 59F5
p 01 00000 00001 0000
# 
# biu_dataout = r0 + 2
p 00 00000 00001 0CDA
p 01 00000 00001 2F9F
p 01 00000 00001 0002
#
# Strobe the biu to update the biu_register_rm value
p 00 00000 00001 0CDB
p 01 00000 00001 5DDF
p 01 00000 00001 3040
#
# Debounce BIU Strobe
p 00 00000 00001 0CDC
p 01 00000 00001 4DDF
p 01 00000 00001 CC0F
#
# CALL FETCH_EA_WORD into r0
p 00 00000 00001 0CDD
p 01 00000 00001 1100
p 01 00000 00001 0792
#
# Copy r0 to the BIU Data Out register to update the segment register in the BIU
p 00 00000 00001 0CDE
p 01 00000 00001 5FF9
p 01 00000 00001 0000
#
# Strobe BIU - Set new DS Segment Register
p 00 00000 00001 0CDF
p 01 00000 00001 5DDF
p 01 00000 00001 3030
#
# Debounce BIU Strobe
p 00 00000 00001 0CE0
p 01 00000 00001 4DDF
p 01 00000 00001 CFC3
#
# Strobe BIU - Fetch Opcode and set QS[1:0] to Subsequent Byte of Opcode 
p 00 00000 00001 0CE1
p 01 00000 00001 5DDF
p 01 00000 00001 100C
#
# Debounce BIU Strobe
p 00 00000 00001 0CE2
p 01 00000 00001 4DDF
p 01 00000 00001 CFF3
#
# Jump unconditional to main microcode loop
p 00 00000 00001 0CE3
p 01 00000 00001 1000
p 01 00000 00001 0004
#
#
# -----------------------------------------------------
#
# 0xC6 - MOV REG8/MEM8, IMM8
#
# -----------------------------------------------------
#
# CALL CALC_EA_BYTE
p 00 00000 00001 0CE7
p 01 00000 00001 1100
p 01 00000 00001 0760
#
# CALL Fetch Opcode byte with QS=Subsequent opcode byte into r3 - Fetch IMM8
p 00 00000 00001 0CE8
p 01 00000 00001 1100
p 01 00000 00001 02A5 
#
# Copy r3 to r0 
p 00 00000 00001 0CE9
p 01 00000 00001 59CF
p 01 00000 00001 0000
#
# Jump unconditional to common code
p 00 00000 00001 0CEA
p 01 00000 00001 1000
p 01 00000 00001 090D
#

# -----------------------------------------------------
#
# 0xC7 - MOV REG16/MEM16, IMM16
#
# -----------------------------------------------------
#
# CALL CALC_EA_WORD
p 00 00000 00001 0CEB
p 01 00000 00001 1100
p 01 00000 00001 0762
#
# CALL Fetch Opcode word with QS=Subsequent opcode word into r3 - Fetch IMM16
p 00 00000 00001 0CEC
p 01 00000 00001 1100
p 01 00000 00001 02E5 
#
# Copy r3 to r0 
p 00 00000 00001 0CED
p 01 00000 00001 59CF
p 01 00000 00001 0000
#
# Jump unconditional to common code
p 00 00000 00001 0CEE
p 01 00000 00001 1000
p 01 00000 00001 091C
#
# -----------------------------------------------------
#
#  0x88   MOV - REG8/MEM8 , REG8 
#
# -----------------------------------------------------
#
# CALL CALC_EA_BYTE
p 00 00000 00001 0CF0
p 01 00000 00001 1100
p 01 00000 00001 0760
#
# CALL FETCH_REG into r0
p 00 00000 00001 0CF1
p 01 00000 00001 1100
p 01 00000 00001 07D4
#
# Jump unconditional to common code
p 00 00000 00001 0CF2
p 01 00000 00001 1000
p 01 00000 00001 090D
#
#
# -----------------------------------------------------
#
#  0x89   MOV - REG16/MEM16 , REG16 
#
# -----------------------------------------------------
#
# CALL CALC_EA_WORD
p 00 00000 00001 0CF3
p 01 00000 00001 1100
p 01 00000 00001 0762
#
# CALL FETCH_REG into r0
p 00 00000 00001 0CF4
p 01 00000 00001 1100
p 01 00000 00001 07D4
#
# Jump unconditional to common code
p 00 00000 00001 0CF5
p 01 00000 00001 1000
p 01 00000 00001 091C
#
#
# -----------------------------------------------------
#
# 0x8A   MOV - REG8 , REG8/MEM8 
#
# -----------------------------------------------------
#
# CALL CALC_EA_BYTE
p 00 00000 00001 0CF6
p 01 00000 00001 1100
p 01 00000 00001 0760
#
# CALL FETCH_EA_BYTE into r0
p 00 00000 00001 0CF7
p 01 00000 00001 1100
p 01 00000 00001 0790
#
# Jump unconditional to common code
p 00 00000 00001 0CF8
p 01 00000 00001 1000
p 01 00000 00001 092B
#
#
#
# -----------------------------------------------------
#
# 0x8B   MOV - REG16 , REG16/MEM16 
#
# -----------------------------------------------------
#
# CALL CALC_EA_WORD
p 00 00000 00001 0CF9
p 01 00000 00001 1100
p 01 00000 00001 0762
#
# CALL FETCH_EA_WORD into r0
p 00 00000 00001 0CFA
p 01 00000 00001 1100
p 01 00000 00001 0792
#
# Jump unconditional to common code
p 00 00000 00001 0CFB
p 01 00000 00001 1000
p 01 00000 00001 093A
#
#
#
# -----------------------------------------------------
#
# 0x8D   LEA - REG16 , MEM16 
#
# -----------------------------------------------------
#
# CALL CALC_EA_WORD
p 00 00000 00001 0CFD
p 01 00000 00001 1100
p 01 00000 00001 0762
#
# Copy biu_register_rm value to r0
p 00 00000 00001 0CFE
p 01 00000 00001 59F5
p 01 00000 00001 0000
#
# Jump unconditional to common code
p 00 00000 00001 0CFF
p 01 00000 00001 1000
p 01 00000 00001 093A
#
#
#
# -----------------------------------------------------
#
# 0xA8   TEST - AL,IMM8 
#
# -----------------------------------------------------
#
# CALL Fetch byte from prefetch queue with QS=Initial opcode byte into r3
p 00 00000 00001 0D02
p 01 00000 00001 1100
p 01 00000 00001 02A0
#
# NOP
p 00 00000 00001 0D03
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# Dummy <= AX AND r3
p 00 00000 00001 0D04
p 01 00000 00001 4E0C
p 01 00000 00001 0000
#
# Jump unconditional to common code
p 00 00000 00001 0D05
p 01 00000 00001 1000
p 01 00000 00001 0942
#
#
# -----------------------------------------------------
#
# 0xA9   TEST - AX,IMM16 
#
# -----------------------------------------------------
#
# CALL Fetch word from prefetch queue with QS=Initial opcode byte into r3
p 00 00000 00001 0D06
p 01 00000 00001 1100
p 01 00000 00001 02E0
#
# Dummy <= AX AND r3
p 00 00000 00001 0D07
p 01 00000 00001 4E0C
p 01 00000 00001 0000
#
# Jump unconditional to common code
p 00 00000 00001 0D08
p 01 00000 00001 1000
p 01 00000 00001 0949
#
# -----------------------------------------------------
#
#  0x84   TEST - REG8/MEM8 , REG8 
#
# -----------------------------------------------------
#
# CALL CALC_EA_BYTE
p 00 00000 00001 0D0A
p 01 00000 00001 1100
p 01 00000 00001 0760
#
# CALL FETCH_EA_BYTE into r0
p 00 00000 00001 0D0B
p 01 00000 00001 1100
p 01 00000 00001 0790
#
# r1 <= r0 - Move results held in r0 to r1
p 00 00000 00001 0D0C
p 01 00000 00001 5AF9
p 01 00000 00001 0000
#
# CALL FETCH_REG into r0
p 00 00000 00001 0D0D
p 01 00000 00001 1100
p 01 00000 00001 07D4
#
#
# Perform the ALU
# ----------------
#
# r0 = r0 AND r1
p 00 00000 00001 0D0E
p 01 00000 00001 499A
p 01 00000 00001 0000
#
# Jump unconditional to common code
p 00 00000 00001 0D0F
p 01 00000 00001 1000
p 01 00000 00001 0942
#
#
# -----------------------------------------------------
#
#  0x85   TEST - REG16/MEM16 , REG16 
#
# -----------------------------------------------------
#
# CALL CALC_EA_WORD
p 00 00000 00001 0D10
p 01 00000 00001 1100
p 01 00000 00001 0762
#
# CALL FETCH_EA_WORD into r0
p 00 00000 00001 0D11
p 01 00000 00001 1100
p 01 00000 00001 0792
#
# r1 <= r0 - Move results held in r0 to r1
p 00 00000 00001 0D12
p 01 00000 00001 5AF9
p 01 00000 00001 0000
#
# CALL FETCH_REG into r0
p 00 00000 00001 0D13
p 01 00000 00001 1100
p 01 00000 00001 07D4
#
#
# Perform the ALU
# ----------------
#
# r0 = r0 AND r1
p 00 00000 00001 0D14
p 01 00000 00001 499A
p 01 00000 00001 0000
#
# Jump unconditional to common code
p 00 00000 00001 0D15
p 01 00000 00001 1000
p 01 00000 00001 0949
#
#
# -----------------------------------------------------
#
#  0x86   XCHG - REG8 , REG8/MEM8
#
# -----------------------------------------------------
#
# CALL CALC_EA_BYTE
p 00 00000 00001 0D18
p 01 00000 00001 1100
p 01 00000 00001 0760
#
# CALL FETCH_EA_BYTE into r0
p 00 00000 00001 0D19
p 01 00000 00001 1100
p 01 00000 00001 0790
#
# r1 <= r0 - Move results held in r0 to r1
p 00 00000 00001 0D1A
p 01 00000 00001 5AF9
p 01 00000 00001 0000
#
# CALL FETCH_REG into r0
p 00 00000 00001 0D1B
p 01 00000 00001 1100
p 01 00000 00001 07D4
#
# CALL WRITEBACK_EA_BYTE
p 00 00000 00001 0D1C
p 01 00000 00001 1100
p 01 00000 00001 07E0
#
# r0 <= r1 - Move results held in r1 to r0
p 00 00000 00001 0D1D
p 01 00000 00001 59FA
p 01 00000 00001 0000
#
# Jump unconditional to common code to WRITEBACK_REG_BYTE
p 00 00000 00001 0D1E
p 01 00000 00001 1000
p 01 00000 00001 092B
#
#
# -----------------------------------------------------
#
#  0x87   XCHG - REG16 , REG16/MEM16
#
# -----------------------------------------------------
#
# CALL CALC_EA_WORD
p 00 00000 00001 0D1F
p 01 00000 00001 1100
p 01 00000 00001 0762
#
# CALL FETCH_EA_WORD into r0
p 00 00000 00001 0D20
p 01 00000 00001 1100
p 01 00000 00001 0792
#
# r1 <= r0 - Move results held in r0 to r1
p 00 00000 00001 0D21
p 01 00000 00001 5AF9
p 01 00000 00001 0000
#
# CALL FETCH_REG into r0
p 00 00000 00001 0D22
p 01 00000 00001 1100
p 01 00000 00001 07D4
#
# CALL WRITEBACK_EA_WORD
p 00 00000 00001 0D23
p 01 00000 00001 1100
p 01 00000 00001 07E2
#
# r0 <= r1 - Move results held in r1 to r0
p 00 00000 00001 0D24
p 01 00000 00001 59FA
p 01 00000 00001 0000
#
# Jump unconditional to common code to WRITEBACK_REG_WORD
p 00 00000 00001 0D25
p 01 00000 00001 1000
p 01 00000 00001 093A
#
#
# -----------------------------------------------------
#
# 0xA0 - MOV AL , MEM8
#   
# -----------------------------------------------------
#
# CALL Fetch Opcode word with QS=First opcode byte  - into r3
p 00 00000 00001 0D28
p 01 00000 00001 1100
p 01 00000 00001 02E0
#
# Set the segment to DS  (Can be overridden)
p 00 00000 00001 0D29
p 01 00000 00001 5DDF
p 01 00000 00001 0C00
#
# CALL MEM_READ_BYTE into biu_return_data
p 00 00000 00001 0D2A
p 01 00000 00001 1100
p 01 00000 00001 0580
#
# r3 = bui_return_data
p 00 00000 00001 0D2B
p 01 00000 00001 5CF7
p 01 00000 00001 0000
#
# r3 = r3 AND 00FF - isolate lower byte just to be safe
p 00 00000 00001 0D2C
p 01 00000 00001 4CCF
p 01 00000 00001 00FF
#
# AL = AX AND FF00 - zero out AL
p 00 00000 00001 0D2D
p 01 00000 00001 400F
p 01 00000 00001 FF00
#
# AX = AX + r3
p 00 00000 00001 0D2E
p 01 00000 00001 200C
p 01 00000 00001 0000
#
# Write 9 clocks to clock counter
p 00 00000 00001 0D2F
p 01 00000 00001 5FFF
p 01 00000 00001 C04F
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0D30
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Jump unconditional to common code
p 00 00000 00001 0D31
p 01 00000 00001 1000
p 01 00000 00001 093B
#
#
# -----------------------------------------------------
#
# 0xA1 - MOV AX , MEM16
#   
# -----------------------------------------------------
#
# CALL Fetch Opcode word with QS=First opcode byte  - into r3
p 00 00000 00001 0D32
p 01 00000 00001 1100
p 01 00000 00001 02E0
#
# Set the segment to DS  (Can be overridden)
p 00 00000 00001 0D33
p 01 00000 00001 5DDF
p 01 00000 00001 0C00
#
# CALL MEM_READ_WORD into biu_return_data
p 00 00000 00001 0D34
p 01 00000 00001 1100
p 01 00000 00001 0585
#
# AX = bui_return_data
p 00 00000 00001 0D35
p 01 00000 00001 50F7
p 01 00000 00001 0000
#
# Jump unconditional to common code
p 00 00000 00001 0D36
p 01 00000 00001 1000
p 01 00000 00001 0D2F
#
#
# -----------------------------------------------------
#
# 0xA2 - MOV MEM8, AL
#   
# -----------------------------------------------------
#
# CALL Fetch Opcode word with QS=First opcode byte  - into r3
p 00 00000 00001 0D38
p 01 00000 00001 1100
p 01 00000 00001 02E0
#
# Set the segment to DS  (Can be overridden)
p 00 00000 00001 0D39
p 01 00000 00001 5DDF
p 01 00000 00001 0C00
#
# biu_dataout = AX
p 00 00000 00001 0D3A
p 01 00000 00001 5F0F
p 01 00000 00001 0000
#
# CALL MEM_WRITE_BYTE
p 00 00000 00001 0D3B
p 01 00000 00001 1100
p 01 00000 00001 0587
#
# Jump unconditional to common code
p 00 00000 00001 0D3C
p 01 00000 00001 1000
p 01 00000 00001 0D2F
#
#
# -----------------------------------------------------
#
# 0xA3 - MOV MEM16, AX
#   
# -----------------------------------------------------
#
# CALL Fetch Opcode word with QS=First opcode byte  - into r3
p 00 00000 00001 0D3D
p 01 00000 00001 1100
p 01 00000 00001 02E0
#
# Set the segment to DS  (Can be overridden)
p 00 00000 00001 0D3E
p 01 00000 00001 5DDF
p 01 00000 00001 0C00
#
# biu_dataout = AX
p 00 00000 00001 0D3F
p 01 00000 00001 5F0F
p 01 00000 00001 0000
#
# CALL MEM_WRITE_WORD
p 00 00000 00001 0D40
p 01 00000 00001 1100
p 01 00000 00001 0589
#
# Jump unconditional to common code
p 00 00000 00001 0D41
p 01 00000 00001 1000
p 01 00000 00001 0D2F
#
#
# -----------------------------------------------------
#
# 0x8F - POP REG16/MEM16
#
# -----------------------------------------------------
#
# Write 5 clocks to clock counter
p 00 00000 00001 0D44
p 01 00000 00001 5FFF
p 01 00000 00001 C064
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0D45
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# CALL CALC_EA_WORD
p 00 00000 00001 0D46
p 01 00000 00001 1100
p 01 00000 00001 0762
#
# CALL POP Procedure
p 00 00000 00001 0D47
p 01 00000 00001 1100
p 01 00000 00001 0450
#
# Copy BIU Return Data to r0
p 00 00000 00001 0D48
p 01 00000 00001 59F7
p 01 00000 00001 0000
#
# Set the segment to DS  (Can be overridden)
p 00 00000 00001 0D49
p 01 00000 00001 5DDF
p 01 00000 00001 0C00
#
# Jump unconditional to common code to writeback_ea
p 00 00000 00001 0D4A
p 01 00000 00001 1000
p 01 00000 00001 091C
#
#
# -----------------------------------------------------
#
# GROUP Opcode - 0x8E
#
# Common microcode processed first. Then Jump Type 6 used
# to decode the REG Field to a Jump table where specific
# microcode is processed for that opcode type.
#
#
# -----------------------------------------------------
#
# CALL CALC_EA_WORD
p 00 00000 00001 0D50
p 01 00000 00001 1100
p 01 00000 00001 0762
#
# CALL FETCH_EA_WORD into r0
p 00 00000 00001 0D51
p 01 00000 00001 1100
p 01 00000 00001 0792
#
# Strobe BIU - Fetch Opcode and set QS[1:0] to Subsequent Byte of Opcode 
p 00 00000 00001 0D52
p 01 00000 00001 5DDF
p 01 00000 00001 100C
#
# Debounce BIU Strobe
p 00 00000 00001 0D53
p 01 00000 00001 4DDF
p 01 00000 00001 CFF3
#
# Copy r1 to the biu_dataout register - Store the Addressing Byte for the Jump-6
p 00 00000 00001 0D54
p 01 00000 00001 5FFA
p 01 00000 00001 0000
#
# Jump-Type6 to Jump Table for 0x8E opcodes: Base address at 0x0D58
p 00 00000 00001 0D55
p 01 00000 00001 1060
p 01 00000 00001 0D58
#
#
#
# Jump Table for 0x8E Opcodes decoded using the REG Field of the Addressing Byte
#
# MOV ES,REG16/MEM16
p 00 00000 00001 0D58
p 01 00000 00001 1000
p 01 00000 00001 0D60
#
# MOV CS,REG16/MEM16
p 00 00000 00001 0D59
p 01 00000 00001 1000
p 01 00000 00001 0D66
#
# MOV SS,REG16/MEM16
p 00 00000 00001 0D5A
p 01 00000 00001 1000
p 01 00000 00001 0D69
#
# MOV DS,REG16/MEM16
p 00 00000 00001 0D5B
p 01 00000 00001 1000
p 01 00000 00001 0D6C
#
# MOV ES,REG16/MEM16
p 00 00000 00001 0D5C
p 01 00000 00001 1000
p 01 00000 00001 0D60
#
# MOV CS,REG16/MEM16
p 00 00000 00001 0D5D
p 01 00000 00001 1000
p 01 00000 00001 0D66
#
# MOV SS,REG16/MEM16
p 00 00000 00001 0D5E
p 01 00000 00001 1000
p 01 00000 00001 0D69
#
# MOV DS,REG16/MEM16
p 00 00000 00001 0D5F
p 01 00000 00001 1000
p 01 00000 00001 0D6C
#
# Update the ES Segment Register
# ------------------------------
#
# biu_dataout <= r0    - Copy segment value to the biu_dataout
p 00 00000 00001 0D60
p 01 00000 00001 5FF9
p 01 00000 00001 0000
#
# Send command to BIU to update the ES Segment Register
# Write to BIU Command register:
p 00 00000 00001 0D61
p 01 00000 00001 5DFF
p 01 00000 00001 3000
#
# Debounce BIU Strobe
p 00 00000 00001 0D62
p 01 00000 00001 4DDF
p 01 00000 00001 0000
#
# Jump unconditional to common code that waits for prefetch queue, then returns to main loop skipping polling all interrupts
p 00 00000 00001 0D63
p 01 00000 00001 1000
p 01 00000 00001 0474
#
# Update the CS Segment Register
# ------------------------------
#
# biu_dataout <= r0    - Copy segment value to the biu_dataout
p 00 00000 00001 0D66
p 01 00000 00001 5FF9
p 01 00000 00001 0000
#
# Send command to BIU to update the CS Segment Register
# Write to BIU Command register:
p 00 00000 00001 0D67
p 01 00000 00001 5DFF
p 01 00000 00001 3020
#
# Jump unconditional to common code
p 00 00000 00001 0D68
p 01 00000 00001 1000
p 01 00000 00001 0D62
#
# Update the SS Segment Register
# ------------------------------
#
# biu_dataout <= r0    - Copy segment value to the biu_dataout
p 00 00000 00001 0D69
p 01 00000 00001 5FF9
p 01 00000 00001 0000
#
# Send command to BIU to update the SS Segment Register
# Write to BIU Command register:
p 00 00000 00001 0D6A
p 01 00000 00001 5DFF
p 01 00000 00001 3010
#
# Jump unconditional to common code
p 00 00000 00001 0D6B
p 01 00000 00001 1000
p 01 00000 00001 0D62
#
# Update the DS Segment Register
# ------------------------------
#
# biu_dataout <= r0    - Copy segment value to the biu_dataout
p 00 00000 00001 0D6C
p 01 00000 00001 5FF9
p 01 00000 00001 0000
#
# Send command to BIU to update the DS Segment Register
# Write to BIU Command register:
p 00 00000 00001 0D6D
p 01 00000 00001 5DFF
p 01 00000 00001 3030
#
# Jump unconditional to common code
p 00 00000 00001 0D6E
p 01 00000 00001 1000
p 01 00000 00001 0D62
#
#
# -----------------------------------------------------
#
# GROUP Opcode - 0x8C
#
# Common microcode processed first. Then Jump Type 6 used
# to decode the REG Field to a Jump table where specific
# microcode is processed for that opcode type.
#
#
# -----------------------------------------------------
#
# CALL CALC_EA_WORD
p 00 00000 00001 0D70
p 01 00000 00001 1100
p 01 00000 00001 0762
#
# Copy r1 to the biu_dataout register - Store the Addressing Byte for the Jump-6
p 00 00000 00001 0D71
p 01 00000 00001 5FFA
p 01 00000 00001 0000
#
# Jump-Type6 to Jump Table for 0x8C opcodes: Base address at 0x0D78
p 00 00000 00001 0D72
p 01 00000 00001 1060
p 01 00000 00001 0D78
#
# CALL WRITEBACK_EA_WORD
p 00 00000 00001 0D73
p 01 00000 00001 1100
p 01 00000 00001 07E2
#
# Strobe BIU - Fetch Opcode and set QS[1:0] to Subsequent Byte of Opcode 
p 00 00000 00001 0D74
p 01 00000 00001 5DDF
p 01 00000 00001 100C
#
# Debounce BIU Strobe
p 00 00000 00001 0D75
p 01 00000 00001 4DDF
p 01 00000 00001 CFF3
#
# Jump unconditional to main microcode loop
p 00 00000 00001 0D76
p 01 00000 00001 1000
p 01 00000 00001 0004
#
#
#
# Jump Table for 0x8C Opcodes decoded using the REG Field of the Addressing Byte
#
# MOV REG16/MEM16,ES
p 00 00000 00001 0D78
p 01 00000 00001 1000
p 01 00000 00001 0D80
#
# MOV REG16/MEM16,CS
p 00 00000 00001 0D79
p 01 00000 00001 1000
p 01 00000 00001 0D82
#
# MOV REG16/MEM16,SS
p 00 00000 00001 0D7A
p 01 00000 00001 1000
p 01 00000 00001 0D84
#
# MOV REG16/MEM16,DS
p 00 00000 00001 0D7B
p 01 00000 00001 1000
p 01 00000 00001 0D86
#
# MOV REG16/MEM16,ES
p 00 00000 00001 0D7C
p 01 00000 00001 1000
p 01 00000 00001 0D80
#
# MOV REG16/MEM16,CS
p 00 00000 00001 0D7D
p 01 00000 00001 1000
p 01 00000 00001 0D82
#
# MOV REG16/MEM16,SS
p 00 00000 00001 0D7E
p 01 00000 00001 1000
p 01 00000 00001 0D84
#
# MOV REG16/MEM16,DS
p 00 00000 00001 0D7F
p 01 00000 00001 1000
p 01 00000 00001 0D86
#
# Copy ES Segment Register to r0
# ------------------------------
#
# r0 <= ES
p 00 00000 00001 0D80
p 01 00000 00001 59F0
p 01 00000 00001 0000
#
# Jump unconditional to common code to write back to the ea
p 00 00000 00001 0D81
p 01 00000 00001 1000
p 01 00000 00001 0D73
#
# Copy CS Segment Register to r0
# ------------------------------
#
# r0 <= CS
p 00 00000 00001 0D82
p 01 00000 00001 59F2
p 01 00000 00001 0000
#
# Jump unconditional to common code to write back to the ea
p 00 00000 00001 0D83
p 01 00000 00001 1000
p 01 00000 00001 0D73
#
# Copy SS Segment Register to r0
# ------------------------------
#
# r0 <= SS
p 00 00000 00001 0D84
p 01 00000 00001 59F1
p 01 00000 00001 0000
#
# Jump unconditional to common code to write back to the ea
p 00 00000 00001 0D85
p 01 00000 00001 1000
p 01 00000 00001 0D73
#
# Copy DS Segment Register to r0
# ------------------------------
#
# r0 <= DS
p 00 00000 00001 0D86
p 01 00000 00001 59F3
p 01 00000 00001 0000
#
# Jump unconditional to common code to write back to the ea
p 00 00000 00001 0D87
p 01 00000 00001 1000
p 01 00000 00001 0D73
#
#
# -----------------------------------------------------
#
# GROUP Opcode - 0xFF
#
# Common microcode processed first. Then Jump Type 6 used
# to decode the REG Field to a Jump table where specific
# microcode is processed for that opcode type.
#
#
# -----------------------------------------------------
#
# CALL CALC_EA_WORD
p 00 00000 00001 0D8B
p 01 00000 00001 1100
p 01 00000 00001 0762
#
# CALL FETCH_EA_WORD into r0
p 00 00000 00001 0D8C
p 01 00000 00001 1100
p 01 00000 00001 0792
#
# Copy r1 to the biu_dataout register - Store the Addressing Byte for the Jump-6
p 00 00000 00001 0D8D
p 01 00000 00001 5FFA
p 01 00000 00001 0000
#
# Jump-Type6 to Jump Table for 0xFF opcodes: Base address at 0x0D98
p 00 00000 00001 0D8E
p 01 00000 00001 1060
p 01 00000 00001 0D98
#
#
# CALL WRITEBACK_EA_WORD
p 00 00000 00001 0D8F
p 01 00000 00001 1100
p 01 00000 00001 07E2
#
# Strobe BIU - Fetch Opcode and set QS[1:0] to Subsequent Byte of Opcode 
p 00 00000 00001 0D90
p 01 00000 00001 5DDF
p 01 00000 00001 100C
#
# Debounce BIU Strobe
p 00 00000 00001 0D91
p 01 00000 00001 4DDF
p 01 00000 00001 CFF3
#
# Jump unconditional to main microcode loop
p 00 00000 00001 0D92
p 01 00000 00001 1000
p 01 00000 00001 0004
#
#
#
# Jump Table for 0x8C Opcodes decoded using the REG Field of the Addressing Byte
#
# INC REG16/MEM16
p 00 00000 00001 0D98
p 01 00000 00001 1000
p 01 00000 00001 0DA0
#
# DEC REG16/MEM16
p 00 00000 00001 0D99
p 01 00000 00001 1000
p 01 00000 00001 0DA6
#
# CALL REG16/MEM16 (intrasegment)
p 00 00000 00001 0D9A
p 01 00000 00001 1000
p 01 00000 00001 0DD8
#
# CALL REG16/MEM16 (intersegment)
p 00 00000 00001 0D9B
p 01 00000 00001 1000
p 01 00000 00001 0DBB
#
# JMP REG16/MEM16 (intrasegment)
p 00 00000 00001 0D9C
p 01 00000 00001 1000
p 01 00000 00001 0DDB
#
# JMP REG16/MEM16 (intersegment)
p 00 00000 00001 0D9D
p 01 00000 00001 1000
p 01 00000 00001 0DC2
#
# PUSH REG16/MEM16
p 00 00000 00001 0D9E
p 01 00000 00001 1000
p 01 00000 00001 0DE6
#
# PUSH REG16/MEM16
p 00 00000 00001 0D9F
p 01 00000 00001 1000
p 01 00000 00001 0DE6
#
# INC REG16/MEM16
# ----------------
#
# Isolate Carry flags bit[0] into r1
p 00 00000 00001 0DA0
p 01 00000 00001 4A8F
p 01 00000 00001 0001
#
# r0 <= r0 + 1
p 00 00000 00001 0DA1
p 01 00000 00001 299F
p 01 00000 00001 0001
#
# CALL CALCULATE_FLAGS_WORD
p 00 00000 00001 0DA2
p 01 00000 00001 1100
p 01 00000 00001 03D3
#
# Clear the Carry flags bit[0] in the Flags register
p 00 00000 00001 0DA3
p 01 00000 00001 488F
p 01 00000 00001 FFFE
#
# OR the stored CF flag in r1 into the Flags register - Restore CF
p 00 00000 00001 0DA4
p 01 00000 00001 588A
p 01 00000 00001 0000
#
# Jump unconditional to common code to write back to the ea
p 00 00000 00001 0DA5
p 01 00000 00001 1000
p 01 00000 00001 0D8F
#
# DEC REG16/MEM16
# ----------------
#
# Isolate Carry flags bit[0] into r1
p 00 00000 00001 0DA6
p 01 00000 00001 4A8F
p 01 00000 00001 0001
#
# r0 <= r0 - 1  (Add FFFF)
p 00 00000 00001 0DA7
p 01 00000 00001 299F
p 01 00000 00001 FFFF
#
# CALL CALCULATE_FLAGS_WORD
p 00 00000 00001 0DA8
p 01 00000 00001 1100
p 01 00000 00001 03D3
#
# Clear the Carry flags bit[0] in the Flags register
p 00 00000 00001 0DA9
p 01 00000 00001 488F
p 01 00000 00001 FFFE
#
# OR the stored CF flag in r1 into the Flags register - Restore CF
p 00 00000 00001 0DAA
p 01 00000 00001 588A
p 01 00000 00001 0000
#
# Invert the Aux Carry bit - Flags[4] - since this is subtraction
p 00 00000 00001 0DAB
p 01 00000 00001 688F
p 01 00000 00001 0010
#
# Jump unconditional to common code to write back to the ea
p 00 00000 00001 0DAC
p 01 00000 00001 1000
p 01 00000 00001 0D8F
#
#
# DEC16 Flags processing - Inverts the Aux Carry bit.
#
# Calculate the O, A, P flags
#
# Save ALU last result into r0
p 00 00000 00001 0DB0
p 01 00000 00001 59FD
p 01 00000 00001 0000
#
# Zero out the O, A, P, Z, S bit fields in Flag register
p 00 00000 00001 0DB1
p 01 00000 00001 488F
p 01 00000 00001 F72B
#
# Store r0 to r0 to make r0 the last_alu result
p 00 00000 00001 0DB2
p 01 00000 00001 59F9
p 01 00000 00001 0000
#
# Isolate the O, A, and P flags from System Signals into r1 using AND
p 00 00000 00001 0DB3
p 01 00000 00001 4AEF
p 01 00000 00001 0814
#
# Merge r1 into the Flags register using OR
p 00 00000 00001 0DB4
p 01 00000 00001 588A
p 01 00000 00001 0000
#
# Invert the Aux Carry bit - Flags[4] - since this is subtraction
p 00 00000 00001 0DB5
p 01 00000 00001 688F
p 01 00000 00001 0010
#
# Jump unconditional to common flag processing code
p 00 00000 00001 0DB6
p 01 00000 00001 1000
p 01 00000 00001 00AD
#
#
# -----------------------------------------------------
#
# 0xFF - CALL MEM16 Inter-segment 
#
# -----------------------------------------------------
#
# Copy the current CS into biu_dataout for the address to push to the stack
p 00 00000 00001 0DBB
p 01 00000 00001 5FF2
p 01 00000 00001 0000
#
# CALL PUSH Procedure
p 00 00000 00001 0DBC
p 01 00000 00001 1100
p 01 00000 00001 0400
#
# Load r3 with 0x1
p 00 00000 00001 0DBD
p 01 00000 00001 5CFF
p 01 00000 00001 0001
#
# Add r3 to the current IP into biu_dataout for the address to push to the stack
p 00 00000 00001 0DBE
p 01 00000 00001 2FC8
p 01 00000 00001 0000
#
# CALL PUSH Procedure
p 00 00000 00001 0DBF
p 01 00000 00001 1100
p 01 00000 00001 0400
#
# Temporary store fetched EA word from r0 into r1 - Store the next IP
p 00 00000 00001 0DC2
p 01 00000 00001 5AF9
p 01 00000 00001 0000
#
# r0 = biu_register_rm
p 00 00000 00001 0DC3
p 01 00000 00001 59F5
p 01 00000 00001 0000
# 
# biu_dataout = r0 + 2
p 00 00000 00001 0DC4
p 01 00000 00001 2F9F
p 01 00000 00001 0002
#
# Strobe the biu to update the biu_register_rm value
p 00 00000 00001 0DC5
p 01 00000 00001 5DDF
p 01 00000 00001 3040
#
# Debounce BIU Strobe
p 00 00000 00001 0DC6
p 01 00000 00001 4DDF
p 01 00000 00001 C003
#
# CALL FETCH_EA_WORD into r0 - Fetch the CS
p 00 00000 00001 0DC7
p 01 00000 00001 1100
p 01 00000 00001 0792
#
# biu_dataout <= r0    - Copy new CS segment value to the biu_dataout
p 00 00000 00001 0DC8
p 01 00000 00001 5FF9
p 01 00000 00001 0000
#
# Send command to BIU to update the CS Segment Register
# Write to BIU Commad register:
p 00 00000 00001 0DC9
p 01 00000 00001 5DFF
p 01 00000 00001 3020
#
# Debounce BIU Strobe
p 00 00000 00001 0DCA
p 01 00000 00001 4DDF
p 01 00000 00001 C003
#
# Strobe BIU - Fetch Opcode and set QS[1:0] to Subsequent Byte of Opcode 
p 00 00000 00001 0DCB
p 01 00000 00001 5DDF
p 01 00000 00001 100C
#
# Debounce BIU Strobe
p 00 00000 00001 0DCC
p 01 00000 00001 4DDF
p 01 00000 00001 C003
#
# r3 <= r1
p 00 00000 00001 0DCD
p 01 00000 00001 5CFA
p 01 00000 00001 0000
# 
# Set the BIU Command fields - Jump Request - r3 holds the jump address
p 00 00000 00001 0DCE
p 01 00000 00001 5DDF
p 01 00000 00001 0398
#
# Isolate the System Signals BIU_Done bit into Dummy
p 00 00000 00001 0DCF
p 01 00000 00001 4EEF
p 01 00000 00001 0040
#
# If last_alu is zero, then Jump to restest the bit
p 00 00000 00001 0DD0
p 01 00000 00001 1002
p 01 00000 00001 0DCF
#
# Debounce the BIU Command fields
p 00 00000 00001 0DD1
p 01 00000 00001 4DDF
p 01 00000 00001 4003
#
# Jump unconditional to main microcode loop
p 00 00000 00001 0DD2
p 01 00000 00001 1000
p 01 00000 00001 0004
#
#
# -----------------------------------------------------
#
# 0xFF - CALL MEM16 Intra-segment 
#
# -----------------------------------------------------
#
# Load r3 with 0x1
p 00 00000 00001 0DD8
p 01 00000 00001 5CFF
p 01 00000 00001 0001
#
# Add r3 to the current IP into biu_dataout for the address to push to the stack
p 00 00000 00001 0DD9
p 01 00000 00001 2FC8
p 01 00000 00001 0000
#
# CALL PUSH Procedure
p 00 00000 00001 0DDA
p 01 00000 00001 1100
p 01 00000 00001 0400
#
#
# Temporary store fetched EA word from r0 into r1 - Store the next IP
p 00 00000 00001 0DDB
p 01 00000 00001 5AF9
p 01 00000 00001 0000
#
# Strobe BIU - Fetch Opcode and set QS[1:0] to Subsequent Byte of Opcode 
p 00 00000 00001 0DDC
p 01 00000 00001 5DDF
p 01 00000 00001 100C
#
# Debounce BIU Strobe
p 00 00000 00001 0DDD
p 01 00000 00001 4DDF
p 01 00000 00001 C003
#
# r3 <= r1
p 00 00000 00001 0DDE
p 01 00000 00001 5CFA
p 01 00000 00001 0000
# 
# Set the BIU Command fields - Jump Request - r3 holds the jump address
p 00 00000 00001 0DDF
p 01 00000 00001 5DDF
p 01 00000 00001 0398
#
# Isolate the System Signals BIU_Done bit into Dummy
p 00 00000 00001 0DE0
p 01 00000 00001 4EEF
p 01 00000 00001 0040
#
# If last_alu is zero, then Jump to restest the bit
p 00 00000 00001 0DE1
p 01 00000 00001 1002
p 01 00000 00001 0DE0
#
# Debounce the BIU Command fields
p 00 00000 00001 0DE2
p 01 00000 00001 4DDF
p 01 00000 00001 4003
#
# Jump unconditional to main microcode loop
p 00 00000 00001 0DE3
p 01 00000 00001 1000
p 01 00000 00001 0004
#
# -----------------------------------------------------
#
# 0xFF - PUSH MEM16
#
# -----------------------------------------------------
#
# Write clock count=3 to the BIU Dataout register
p 00 00000 00001 0DE6
p 01 00000 00001 5FFF
p 01 00000 00001 C03C
#
# CALL WAIT_CLOCKS
p 00 00000 00001 0DE7
p 01 00000 00001 1100
p 01 00000 00001 03F2
#
# Copy r0 into biu_dataout to be pushed to the stack
p 00 00000 00001 0DE8
p 01 00000 00001 5FF9
p 01 00000 00001 0000
#
# CALL PUSH Procedure
p 00 00000 00001 0DE9
p 01 00000 00001 1100
p 01 00000 00001 0400
#
# Jump unconditional to common code
p 00 00000 00001 0DEA
p 01 00000 00001 1000
p 01 00000 00001 0D90
#
# -----------------------------------------------------
#
# GROUP Opcode - 0xFE
#
# Common microcode processed first. Then Jump Type 6 used
# to decode the REG Field to a Jump table where specific
# microcode is processed for that opcode type.
#
#
# -----------------------------------------------------
#
# CALL CALC_EA_BYTE
p 00 00000 00001 0DF0
p 01 00000 00001 1100
p 01 00000 00001 0760
#
# CALL FETCH_EA_BYTE into r0
p 00 00000 00001 0DF1
p 01 00000 00001 1100
p 01 00000 00001 0790
#
# Copy r1 to the biu_dataout register - Store the Addressing Byte for the Jump-6
p 00 00000 00001 0DF2
p 01 00000 00001 5FFA
p 01 00000 00001 0000
#
# Jump-Type6 to Jump Table for 0xFE opcodes: Base address at 0x0DF8
p 00 00000 00001 0DF3
p 01 00000 00001 1060
p 01 00000 00001 0DF8
#
#
# CALL WRITEBACK_EA_BYTE
p 00 00000 00001 0DF4
p 01 00000 00001 1100
p 01 00000 00001 07E0
#
# Strobe BIU - Fetch Opcode and set QS[1:0] to Subsequent Byte of Opcode 
p 00 00000 00001 0DF5
p 01 00000 00001 5DDF
p 01 00000 00001 100C
#
# Debounce BIU Strobe
p 00 00000 00001 0DF6
p 01 00000 00001 4DDF
p 01 00000 00001 CFF3
#
# Jump unconditional to main microcode loop
p 00 00000 00001 0DF7
p 01 00000 00001 1000
p 01 00000 00001 0004
#
#
# Jump Table for 0xFE Opcodes decoded using the REG Field of the Addressing Byte
#
# INC REG8/MEM8
p 00 00000 00001 0DF8
p 01 00000 00001 1000
p 01 00000 00001 0E00
#
# DEC REG8/MEM8
p 00 00000 00001 0DF9
p 01 00000 00001 1000
p 01 00000 00001 0E09
#
# CALL REG16/MEM16 (intrasegment) - Duplicate of 0xFF opcode - Infinite loop for now
p 00 00000 00001 0DFA
p 01 00000 00001 1000
p 01 00000 00001 0DFA
#
# CALL REG16/MEM16 (intersegment) - Duplicate of 0xFF opcode - Infinite loop for now
p 00 00000 00001 0DFB
p 01 00000 00001 1000
p 01 00000 00001 0DFB
#
# JMP REG16/MEM16 (intrasegment) - Duplicate of 0xFF opcode - Infinite loop for now
p 00 00000 00001 0DFC
p 01 00000 00001 1000
p 01 00000 00001 0DFC
#
# JMP REG16/MEM16 (intersegment) - Duplicate of 0xFF opcode - Infinite loop for now
p 00 00000 00001 0DFD
p 01 00000 00001 1000
p 01 00000 00001 0DFD
#
# PUSH REG16/MEM16 - Duplicate of 0xFF opcode - Infinite loop for now
p 00 00000 00001 0DFE
p 01 00000 00001 1000
p 01 00000 00001 0DFE
#
# PUSH REG16/MEM16 - Duplicate of 0xFF opcode - Infinite loop for now
p 00 00000 00001 0DFF
p 01 00000 00001 1000
p 01 00000 00001 0DFF
#
#
# INC REG8/MEM8
# ----------------
#
# Isolate Carry flags bit[0] into r1
p 00 00000 00001 0E00
p 01 00000 00001 4A8F
p 01 00000 00001 0001
#
# r0 <= r0 + 1
p 00 00000 00001 0E01
p 01 00000 00001 299F
p 01 00000 00001 0001
#
# CALL CALCULATE_FLAGS_BYTE
p 00 00000 00001 0E02
p 01 00000 00001 1100
p 01 00000 00001 0990
#
# Clear the Carry flags bit[0] in the Flags register
p 00 00000 00001 0E03
p 01 00000 00001 488F
p 01 00000 00001 FFFE
#
# OR the stored CF flag in r1 into the Flags register - Restore CF
p 00 00000 00001 0E04
p 01 00000 00001 588A
p 01 00000 00001 0000
#
# Jump unconditional to common code to write back to the ea
p 00 00000 00001 0E05
p 01 00000 00001 1000
p 01 00000 00001 0DF4
#
# DEC REG8/MEM8
# ----------------
#
# Isolate Carry flags bit[0] into r1
p 00 00000 00001 0E09
p 01 00000 00001 4A8F
p 01 00000 00001 0001
#
# r0 <= r0 - 1  (Add FFFF)
p 00 00000 00001 0E0A
p 01 00000 00001 299F
p 01 00000 00001 FFFF
#
# CALL CALCULATE_FLAGS_BYTE
p 00 00000 00001 0E0B
p 01 00000 00001 1100
p 01 00000 00001 0990
#
# Clear the Carry flags bit[0] in the Flags register
p 00 00000 00001 0E0C
p 01 00000 00001 488F
p 01 00000 00001 FFFE
#
# OR the stored CF flag in r1 into the Flags register - Restore CF
p 00 00000 00001 0E0D
p 01 00000 00001 588A
p 01 00000 00001 0000
#
# Invert the Aux Carry bit - Flags[4] - since this is subtraction
p 00 00000 00001 0E0E
p 01 00000 00001 688F
p 01 00000 00001 0010
#
# Jump unconditional to common code to write back to the ea
p 00 00000 00001 0E0F
p 01 00000 00001 1000
p 01 00000 00001 0DF4
#
#
# -----------------------------------------------------
#
# GROUP Opcode - 0xF6
#
# Common microcode processed first. Then Jump Type 6 used
# to decode the REG Field to a Jump table where specific
# microcode is processed for that opcode type.
#
#
# -----------------------------------------------------
#
# NOP
p 00 00000 00001 0E12
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# CALL CALC_EA_BYTE
p 00 00000 00001 0E13
p 01 00000 00001 1100
p 01 00000 00001 0760
#
# CALL FETCH_EA_BYTE into r0
p 00 00000 00001 0E14
p 01 00000 00001 1100
p 01 00000 00001 0790
#
# r3 = 0x0000
p 00 00000 00001 0E15
p 01 00000 00001 4CFF
p 01 00000 00001 0000
#
# Copy r1 to the biu_dataout register - Store the Addressing Byte for the Jump-6
p 00 00000 00001 0E16
p 01 00000 00001 5FFA
p 01 00000 00001 0000
#
# Jump-Type6 to Jump Table for 0xF6 opcodes: Base address at 0x0E18
p 00 00000 00001 0E17
p 01 00000 00001 1060
p 01 00000 00001 0E18
#
#
#
# Jump Table for 0xF6 Opcodes decoded using the REG Field of the Addressing Byte
#
# TEST REG8/MEM8,IMM8
p 00 00000 00001 0E18
p 01 00000 00001 1000
p 01 00000 00001 0E20
#
# TEST REG8/MEM8,IMM8 - Duplicate
p 00 00000 00001 0E19
p 01 00000 00001 1000
p 01 00000 00001 0E20
#
# NOT REG8/MEM8
p 00 00000 00001 0E1A
p 01 00000 00001 1000
p 01 00000 00001 0E26
#
# NEG REG8/MEM8
p 00 00000 00001 0E1B
p 01 00000 00001 1000
p 01 00000 00001 0E28
#
# MUL REG8/MEM8
p 00 00000 00001 0E1C
p 01 00000 00001 1000
p 01 00000 00001 0E40
#
# IMUL REG8/MEM8
p 00 00000 00001 0E1D
p 01 00000 00001 1000
p 01 00000 00001 0E30
#
# DIV REG8/MEM8
p 00 00000 00001 0E1E
p 01 00000 00001 1000
p 01 00000 00001 0E52
#
# IDIV REG8/MEM8
p 00 00000 00001 0E1F
p 01 00000 00001 1000
p 01 00000 00001 0E54
#
#
# -----------------------------------------------------
#
# 0xF6   TEST - REG8/MEM8,IMMED8 
#
# -----------------------------------------------------
#
# CALL Fetch Opcode byte with QS=Subsequent opcode byte into r3 - Fetch IMM8
p 00 00000 00001 0E20
p 01 00000 00001 1100
p 01 00000 00001 02A5 
#
# NOP
p 00 00000 00001 0E21
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# NOP
p 00 00000 00001 0E22
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# Dummy <= r0 AND r3
p 00 00000 00001 0E23
p 01 00000 00001 4E9C
p 01 00000 00001 0000
#
# Jump unconditional to common code
p 00 00000 00001 0E24
p 01 00000 00001 1000
p 01 00000 00001 0942
#
#
# -----------------------------------------------------
#
# 0xF6   NOT - REG8/MEM8 
#
# -----------------------------------------------------
#
# r0 <= r0 XOR FFFF
p 00 00000 00001 0E26
p 01 00000 00001 699F
p 01 00000 00001 FFFF
#
# Jump unconditional to common code to writeback the EA Byte
p 00 00000 00001 0E27
p 01 00000 00001 1000
p 01 00000 00001 090D
#
#
# -----------------------------------------------------
#
# 0xF6   NEG - REG8/MEM8 
#
# -----------------------------------------------------
#
# r1 = r0
p 00 00000 00001 0E28
p 01 00000 00001 5A9F
p 01 00000 00001 0000
#
# r0 = 0x0000
p 00 00000 00001 0E29
p 01 00000 00001 49FF
p 01 00000 00001 0000
#
# CALL SUB_BYTE
p 00 00000 00001 0E2A
p 01 00000 00001 1100
p 01 00000 00001 0A46
#
# Jump unconditional to common code to writeback the EA Byte
p 00 00000 00001 0E2B
p 01 00000 00001 1000
p 01 00000 00001 090D
#
#
# -----------------------------------------------------
#
# 0xF6   IMUL - REG8/MEM8 
#
# -----------------------------------------------------
#
# Kick off clock cycle counter here. Check for it to be zero at the end of the routine.
# Write clock count=89 to the BIU Dataout register. - Minimum of 89 clocks for IMUL8
p 00 00000 00001 0E30
p 01 00000 00001 5FFF
p 01 00000 00001 C6F4
#
# Strobe BIU - Set clock counter
p 00 00000 00001 0E31
p 01 00000 00001 5DDF
p 01 00000 00001 2000
#
# Debounce BIU Strobe
p 00 00000 00001 0E32
p 01 00000 00001 4DDF
p 01 00000 00001 CFFF
#
#
# Test for negative numbers. r3=0x0001 indicates that final answer needs to be 2's complimented.
#
# Isolate r0[7] into Dummy 
p 00 00000 00001 0E33
p 01 00000 00001 4E9F
p 01 00000 00001 0080
#
# Jump if zero over next instructions
p 00 00000 00001 0E34
p 01 00000 00001 1002
p 01 00000 00001 0E38
#
# Set the r3=0x0001  - Final answer is negative and needs to be 2's complimented.
p 00 00000 00001 0E35
p 01 00000 00001 5CFF
p 01 00000 00001 0001
#
# XOR invert lower 8 bits of r0 - 1's Complement
p 00 00000 00001 0E36
p 01 00000 00001 699F
p 01 00000 00001 00FF
#
# Add 1 to r0 -  2's Complement
p 00 00000 00001 0E37
p 01 00000 00001 299F
p 01 00000 00001 0001
#
#
# Isolate AX[7] into Dummy 
p 00 00000 00001 0E38
p 01 00000 00001 4E0F
p 01 00000 00001 0080
#
# Jump if zero over next instructions
p 00 00000 00001 0E39
p 01 00000 00001 1002
p 01 00000 00001 0E43
#
# Toggle r3[0] - If previous final answer is negative, then new final answer should be positive.
p 00 00000 00001 0E3A
p 01 00000 00001 6CCF
p 01 00000 00001 0001
#
# XOR invert lower 8 bits of AX - 1's Complement
p 00 00000 00001 0E3B
p 01 00000 00001 600F
p 01 00000 00001 FFFF
#
# Add 1 to AX -  2's Complement
p 00 00000 00001 0E3C
p 01 00000 00001 200F
p 01 00000 00001 0001
#
# Jump Unconditional to MUL opcode
p 00 00000 00001 0E3D
p 01 00000 00001 1000
p 01 00000 00001 0E43
#
#
# -----------------------------------------------------
#
# 0xF6   MUL - REG8/MEM8 
#
# -----------------------------------------------------
#
# Kick off clock cycle counter here. Check for it to be zero at the end of the routine.
# Write clock count=74 to the BIU Dataout register. - Minimum of 74 clocks for MUL8
p 00 00000 00001 0E40
p 01 00000 00001 5FFF
p 01 00000 00001 C5C8
#
# Strobe BIU - Set clock counter
p 00 00000 00001 0E41
p 01 00000 00001 5DDF
p 01 00000 00001 2000
#
# Debounce BIU Strobe
p 00 00000 00001 0E42
p 01 00000 00001 4DDF
p 01 00000 00001 CFFF
#
# Clear the CF, and OF Flags
p 00 00000 00001 0E43
p 01 00000 00001 488F
p 01 00000 00001 F7FE
#
# Byte Swap r0 to put multiplier in upper byte
p 00 00000 00001 0E44
p 01 00000 00001 399F
p 01 00000 00001 0000
#
# r1 <= 0x0008  - Bit Counter
p 00 00000 00001 0E45
p 01 00000 00001 5AFF
p 01 00000 00001 0008
#
# r2 <= 0x0000  - Overflow counter
p 00 00000 00001 0E46
p 01 00000 00001 5BFF
p 01 00000 00001 0000
#
# Zero out AH
p 00 00000 00001 0E47
p 01 00000 00001 400F
p 01 00000 00001 00FF
#
#
# LOOP_TOP:
# Isolate AX[0] into Dummy
p 00 00000 00001 0E48
p 01 00000 00001 4E0F
p 01 00000 00001 0001
#
# Jump if zero directly to SHIFT:
p 00 00000 00001 0E49
p 01 00000 00001 1002
p 01 00000 00001 0E4E
#
# AX = AX + r0  - Actually AH=AH+r0[15:8]
p 00 00000 00001 0E4A
p 01 00000 00001 2009
p 01 00000 00001 0000
#
# Isolate CARRY16 from System Signals into Dummy 
p 00 00000 00001 0E4B
p 01 00000 00001 4EEF
p 01 00000 00001 0001
#
# Jump over next code if last ALU is zero
p 00 00000 00001 0E4C
p 01 00000 00001 1002
p 01 00000 00001 0E4E
#
# r2=r2+1
p 00 00000 00001 0E4D
p 01 00000 00001 2BBF
p 01 00000 00001 0001
#
#
# SHIFT: CALL MUL8_SHIFT 
p 00 00000 00001 0E4E
p 01 00000 00001 1100
p 01 00000 00001 0F6A
#
# r1=r1-1  - Decrement the bit counter
p 00 00000 00001 0E4F
p 01 00000 00001 2AAF
p 01 00000 00001 FFFF
#
# Jump if last alu non zero to LOOP_TOP:
p 00 00000 00001 0E50
p 01 00000 00001 1001
p 01 00000 00001 0E48
#
#
# Jump unconditional to MUL8_ENDING:
p 00 00000 00001 0E51
p 01 00000 00001 1000
p 01 00000 00001 0F70
#
#
# Clear the CF, and OF Flags
p 00 00000 00001 0E52
p 01 00000 00001 488F
p 01 00000 00001 F7FE
#
#
# Jump unconditional to DIV opcode:
p 00 00000 00001 0E53
p 01 00000 00001 1000
p 01 00000 00001 0E63
#
#
# -----------------------------------------------------
#
# 0xF6   IDIV - REG8/MEM8 
#
# -----------------------------------------------------
#
#
# Clear the CF, and OF Flags
p 00 00000 00001 0E54
p 01 00000 00001 488F
p 01 00000 00001 F7FE
#
# Kick off clock cycle counter here. Check for it to be zero at the end of the routine.
# Write clock count=106 to the BIU Dataout register. - Minimum of 106 clocks for IDIV8
p 00 00000 00001 0E55
p 01 00000 00001 5FFF
p 01 00000 00001 C848
#
# Strobe BIU - Set clock counter
p 00 00000 00001 0E56
p 01 00000 00001 5DDF
p 01 00000 00001 2000
#
# Debounce BIU Strobe
p 00 00000 00001 0E57
p 01 00000 00001 4DDF
p 01 00000 00001 CFFF
#
#
# Test for negative numbers. CF=1 indicates that final answer needs to be 2's complimented.
#
# Isolate r0[7] into Dummy 
p 00 00000 00001 0E58
p 01 00000 00001 4E9F
p 01 00000 00001 0080
#
# Jump if zero over next instructions
p 00 00000 00001 0E59
p 01 00000 00001 1002
p 01 00000 00001 0E5D
#
# Set the CF=1  - Final answer is negative and needs to be 2's complimented.
p 00 00000 00001 0E5A
p 01 00000 00001 588F
p 01 00000 00001 0001
#
# XOR invert lower bits of r0 - 1's Complement
p 00 00000 00001 0E5B
p 01 00000 00001 699F
p 01 00000 00001 00FF
#
# Add 1 to r0 -  2's Complement
p 00 00000 00001 0E5C
p 01 00000 00001 299F
p 01 00000 00001 0001
#
#
# Isolate AX[15] into Dummy 
p 00 00000 00001 0E5D
p 01 00000 00001 4E0F
p 01 00000 00001 8000
#
# Jump if zero over next instructions
p 00 00000 00001 0E5E
p 01 00000 00001 1002
p 01 00000 00001 0E66
#
# Toggle CF - If previous final answer is negative, then new final answer should be positive.
# Also toggle OV bit to store that AX is a negative number
p 00 00000 00001 0E5F
p 01 00000 00001 688F
p 01 00000 00001 0801
#
# XOR invert all bits of AX - 1's Complement
p 00 00000 00001 0E60
p 01 00000 00001 600F
p 01 00000 00001 FFFF
#
# Add 1 to AX -  2's Complement
p 00 00000 00001 0E61
p 01 00000 00001 200F
p 01 00000 00001 0001
#
# Jump Unconditional to DIV opcode
p 00 00000 00001 0E62
p 01 00000 00001 1000
p 01 00000 00001 0E66
#
# -----------------------------------------------------
#
# 0xF6   DIV - REG8/MEM8 
#
#
# AX - Numerator
# r0 - Denominator
# r1 - Bit counter
# r2 - Quotient
# r3 - 2's Complemented version of r0
# CF - 1= Final Quotient should be made negative
# OV - 1= AX is negative, so the remainder should be represented negative
# AH - Remainder AL=Quotient
#
# Note:
# If AX is negative, then remainder in AH will also be negative. Even if both operators are negative and the quotient is positive.
#
# -----------------------------------------------------
#
# Kick off clock cycle counter here. Check for it to be zero at the end of the routine.
# Write clock count=85 to the BIU Dataout register. - Minimum of 85 clocks for DIV8
p 00 00000 00001 0E63
p 01 00000 00001 5FFF
p 01 00000 00001 C6A4
#
# Strobe BIU - Set clock counter
p 00 00000 00001 0E64
p 01 00000 00001 5DDF
p 01 00000 00001 2000
#
# Debounce BIU Strobe
p 00 00000 00001 0E65
p 01 00000 00001 4DDF
p 01 00000 00001 CFFF
#
#
# r1=16   Load the bitcount
p 00 00000 00001 0E66
p 01 00000 00001 5AFF
p 01 00000 00001 0010
#
# Zero out r2 - Quotient
p 00 00000 00001 0E67
p 01 00000 00001 4BBF
p 01 00000 00001 0000
#
# r3= Two's complement r0: Invert r0  (r0 = r0 XOR FFFF)
p 00 00000 00001 0E68
p 01 00000 00001 6C9F
p 01 00000 00001 FFFF
#
# r3= Two's complement r0: r0 = r0 + 1 - Denominator
p 00 00000 00001 0E69
p 01 00000 00001 2CCF
p 01 00000 00001 0001
#
# Test for division by zero
# Jump if zero to INT0 processing code
p 00 00000 00001 0E6A
p 01 00000 00001 1002
p 01 00000 00001 0F10
#
#
# START: fuck
# CALL SHIFT_32
p 00 00000 00001 0E6B
p 01 00000 00001 1100
p 01 00000 00001 0F56
#
# Subtraction Test
# r2=r2-r3
p 00 00000 00001 0E6C
p 01 00000 00001 2BBC
p 01 00000 00001 0000
#
# Isolate CARRY16 from System Signals into Dummy 
p 00 00000 00001 0E6D
p 01 00000 00001 4EEF
p 01 00000 00001 0001
#
# Jump to RESTORE: code if last ALU is zero
p 00 00000 00001 0E6E
p 01 00000 00001 1002
p 01 00000 00001 0E71
#
# Set AX[0] to 1
p 00 00000 00001 0E6F
p 01 00000 00001 500F
p 01 00000 00001 0001
#
# Jump unconditional to BIT_COUNT_TEST  
p 00 00000 00001 0E70
p 01 00000 00001 1000
p 01 00000 00001 0E72
#
# RESTORE:
# r2=r2+r0
p 00 00000 00001 0E71
p 01 00000 00001 2BB9
p 01 00000 00001 0000
#
# BIT_COUNT_TEST:
# r1=r1-1
p 00 00000 00001 0E72
p 01 00000 00001 2AAF
p 01 00000 00001 FFFF
#
# Jump back to START: if last ALU is non zero
p 00 00000 00001 0E73
p 01 00000 00001 1001
p 01 00000 00001 0E6B
#
#
# DONE:
# Overflow Check: AH should be zero. Otherwise it has overflow
#  OR AH into Dummy
p 00 00000 00001 0E74
p 01 00000 00001 4E0F
p 01 00000 00001 FF00
#
# Jump if non zero to INT0 processing code
p 00 00000 00001 0E75
p 01 00000 00001 1001
p 01 00000 00001 0F10
#
# DONE:
# Remainder SIGN UPDATE:
# If AX was negative, represent the remainder as a negative number
# Isolate OV into Dummy 
p 00 00000 00001 0E76
p 01 00000 00001 4E8F
p 01 00000 00001 0800
#
# Jump if zero over next instructions
p 00 00000 00001 0E77
p 01 00000 00001 1002
p 01 00000 00001 0E7A
#
# XOR invert all bits in r2 - 1's Complement
p 00 00000 00001 0E78
p 01 00000 00001 6BBF
p 01 00000 00001 FFFF
#
# Add 1 to r2 -  2's Complement
p 00 00000 00001 0E79
p 01 00000 00001 2BBF
p 01 00000 00001 0001
#
#
# QUOTIENT SIGN UPDATE:
# Isolate CF into Dummy 
p 00 00000 00001 0E7A
p 01 00000 00001 4E8F
p 01 00000 00001 0001
#
# Jump if zero over next instructions
p 00 00000 00001 0E7B
p 01 00000 00001 1002
p 01 00000 00001 0E7E
#
# XOR invert all bits in AX - 1's Complement
p 00 00000 00001 0E7C
p 01 00000 00001 600F
p 01 00000 00001 FFFF
#
# Add 1 to AX -  2's Complement
p 00 00000 00001 0E7D
p 01 00000 00001 200F
p 01 00000 00001 0001
#
#
# Clear AH
p 00 00000 00001 0E7E
p 01 00000 00001 400F
p 01 00000 00001 00FF
#
# Byte swap r2
p 00 00000 00001 0E7F
p 01 00000 00001 3BB0
p 01 00000 00001 0000
#
# Clear r2[7:0]
p 00 00000 00001 0E80
p 01 00000 00001 4BBF
p 01 00000 00001 FF00
#
#
# AX = AX OR r2   - Merge sign corrected quotient and remainder into AX
p 00 00000 00001 0E81
p 01 00000 00001 500B
p 01 00000 00001 0000
#
# Jump Unconditional to common code
p 00 00000 00001 0E82
p 01 00000 00001 1000
p 01 00000 00001 0F77
#
#
# -----------------------------------------------------
#
# GROUP Opcode - 0xF7
#
# Common microcode processed first. Then Jump Type 6 used
# to decode the REG Field to a Jump table where specific
# microcode is processed for that opcode type.
#
#
# -----------------------------------------------------
#
# CALL CALC_EA_WORD
p 00 00000 00001 0E83
p 01 00000 00001 1100
p 01 00000 00001 0762
#
# CALL FETCH_EA_WORD into r0
p 00 00000 00001 0E84
p 01 00000 00001 1100
p 01 00000 00001 0792
#
# r3 = 0x0000
p 00 00000 00001 0E85
p 01 00000 00001 4CFF
p 01 00000 00001 0000
#
# Copy r1 to the biu_dataout register - Store the Addressing Byte for the Jump-6
p 00 00000 00001 0E86
p 01 00000 00001 5FFA
p 01 00000 00001 0000
#
# Jump-Type6 to Jump Table for 0xF7 opcodes: Base address at 0x0E88
p 00 00000 00001 0E87
p 01 00000 00001 1060
p 01 00000 00001 0E88
#
#
#
# Jump Table for 0xF7 Opcodes decoded using the REG Field of the Addressing Byte
#
# TEST REG16/MEM16,IMM16
p 00 00000 00001 0E88
p 01 00000 00001 1000
p 01 00000 00001 0E90
#
# TEST REG16/MEM16,IMM16 - Duplicate
p 00 00000 00001 0E89
p 01 00000 00001 1000
p 01 00000 00001 0E90
#
# NOT REG16/MEM16
p 00 00000 00001 0E8A
p 01 00000 00001 1000
p 01 00000 00001 0E94
#
# NEG REG16/MEM16
p 00 00000 00001 0E8B
p 01 00000 00001 1000
p 01 00000 00001 0E96
#
# MUL REG16/MEM16
p 00 00000 00001 0E8C
p 01 00000 00001 1000
p 01 00000 00001 0EAE
#
# IMUL REG16/MEM16
p 00 00000 00001 0E8D
p 01 00000 00001 1000
p 01 00000 00001 0E9E
#
# DIV REG16/MEM16
p 00 00000 00001 0E8E
p 01 00000 00001 1000
p 01 00000 00001 0EE4
#
# IDIV REG16/MEM16
p 00 00000 00001 0E8F
p 01 00000 00001 1000
p 01 00000 00001 0ED0
#
#
# -----------------------------------------------------
#
# 0xF7   TEST - REG16/MEM16,IMMED8
#
# -----------------------------------------------------
#
# Clear the CF, and OF Flags
p 00 00000 00001 0E90
p 01 00000 00001 488F
p 01 00000 00001 F7FE
#
# CALL Fetch Opcode word with QS=Subsequent opcode byte into r3 - Fetch IMM16
p 00 00000 00001 0E91
p 01 00000 00001 1100
p 01 00000 00001 02E5 
#
# Dummy <= r0 AND r3
p 00 00000 00001 0E92
p 01 00000 00001 4E9C
p 01 00000 00001 0000
#
# Jump unconditional to common code
p 00 00000 00001 0E93
p 01 00000 00001 1000
p 01 00000 00001 0949
#
#
# -----------------------------------------------------
#
# 0xF7   NOT - REG16/MEM16 
#
# -----------------------------------------------------
#
# r0 <= r0 XOR FFFF
p 00 00000 00001 0E94
p 01 00000 00001 699F
p 01 00000 00001 FFFF
#
# Jump unconditional to common code to writeback the EA Word
p 00 00000 00001 0E95
p 01 00000 00001 1000
p 01 00000 00001 091C
#
#
# -----------------------------------------------------
#
# 0xF7   NEG - REG16/MEM16 
#
# -----------------------------------------------------
#
# r1 = r0
p 00 00000 00001 0E96
p 01 00000 00001 5A9F
p 01 00000 00001 0000
#
# r0 = 0x0000
p 00 00000 00001 0E97
p 01 00000 00001 49FF
p 01 00000 00001 0000
#
# CALL SUB_WORD
p 00 00000 00001 0E98
p 01 00000 00001 1100
p 01 00000 00001 0A52
#
# Jump unconditional to common code to writeback the EA Word
p 00 00000 00001 0E99
p 01 00000 00001 1000
p 01 00000 00001 091C
#
#
# -----------------------------------------------------
#
# 0xF7   IMUL - REG16/MEM16
#
# -----------------------------------------------------
#
# Clear the CF, and OF Flags
p 00 00000 00001 0E9E
p 01 00000 00001 488F
p 01 00000 00001 F7FE
#
# Kick off clock cycle counter here. Check for it to be zero at the end of the routine.
# Write clock count=141 to the BIU Dataout register. - Minimum of 141 clocks for IMUL16
p 00 00000 00001 0E9F
p 01 00000 00001 5FFF
p 01 00000 00001 CB04
#
# Strobe BIU - Set clock counter
p 00 00000 00001 0EA0
p 01 00000 00001 5DDF
p 01 00000 00001 2000
#
# Debounce BIU Strobe
p 00 00000 00001 0EA1
p 01 00000 00001 4DDF
p 01 00000 00001 CFFF
#
#
# Test for negative numbers. r3=0x0001 indicates that final answer needs to be 2's complimented.
#
# Isolate r0[15] into Dummy 
p 00 00000 00001 0EA2
p 01 00000 00001 4E9F
p 01 00000 00001 8000
#
# Jump if zero over next instructions
p 00 00000 00001 0EA3
p 01 00000 00001 1002
p 01 00000 00001 0EA7
#
# Set the r3=0x0001  - Final answer is negative and needs to be 2's complimented.
p 00 00000 00001 0EA4
p 01 00000 00001 5CFF
p 01 00000 00001 0001
#
# XOR invert r0 - 1's Complement
p 00 00000 00001 0EA5
p 01 00000 00001 699F
p 01 00000 00001 FFFF
#
# Add 1 to r0 -  2's Complement
p 00 00000 00001 0EA6
p 01 00000 00001 299F
p 01 00000 00001 0001
#
#
# Isolate AX[15] into Dummy 
p 00 00000 00001 0EA7
p 01 00000 00001 4E0F
p 01 00000 00001 8000
#
# Jump if zero over next instructions
p 00 00000 00001 0EA8
p 01 00000 00001 1002
p 01 00000 00001 0EB2
#
# Toggle r3[0] - If previous final answer is negative, then new final answer should be positive.
p 00 00000 00001 0EA9
p 01 00000 00001 6CCF
p 01 00000 00001 0001
#
# XOR invert AX - 1's Complement
p 00 00000 00001 0EAA
p 01 00000 00001 600F
p 01 00000 00001 FFFF
#
# Add 1 to AX -  2's Complement
p 00 00000 00001 0EAB
p 01 00000 00001 200F
p 01 00000 00001 0001
#
# Jump Unconditional to MUL opcode
p 00 00000 00001 0EAC
p 01 00000 00001 1000
p 01 00000 00001 0EB2
#
#
# -----------------------------------------------------
#
# 0xF7   MUL - REG16/MEM16
#
# -----------------------------------------------------
#
# Clear the CF, and OF Flags
p 00 00000 00001 0EAE
p 01 00000 00001 488F
p 01 00000 00001 F7FE
#
# Kick off clock cycle counter here. Check for it to be zero at the end of the routine.
# Write clock count=125 to the BIU Dataout register. - Minimum of 125 clocks for MUL16
p 00 00000 00001 0EAF
p 01 00000 00001 5FFF
p 01 00000 00001 C9C4
#
# Strobe BIU - Set clock counter
p 00 00000 00001 0EB0
p 01 00000 00001 5DDF
p 01 00000 00001 2000
#
# Debounce BIU Strobe
p 00 00000 00001 0EB1
p 01 00000 00001 4DDF
p 01 00000 00001 CFFF
#
# r1 <= 0x0010  - Bit Counter
p 00 00000 00001 0EB2
p 01 00000 00001 5AFF
p 01 00000 00001 0010
#
# r2 <= 0x0000  - Overflow counter
p 00 00000 00001 0EB3
p 01 00000 00001 5BFF
p 01 00000 00001 0000
#
# DX <= 0x0000
p 00 00000 00001 0EB4
p 01 00000 00001 53FF
p 01 00000 00001 0000
#

# LOOP_TOP:
# Isolate AX[0] into Dummy
p 00 00000 00001 0EB5
p 01 00000 00001 4E0F
p 01 00000 00001 0001
#
# Jump if zero directly to SHIFT:
p 00 00000 00001 0EB6
p 01 00000 00001 1002
p 01 00000 00001 0EBB
#
# DX = DX + r0
p 00 00000 00001 0EB7
p 01 00000 00001 2339
p 01 00000 00001 0000
#
# Isolate CARRY16 from System Signals into Dummy 
p 00 00000 00001 0EB8
p 01 00000 00001 4EEF
p 01 00000 00001 0001
#
# Jump over next code if last ALU is zero
p 00 00000 00001 0EB9
p 01 00000 00001 1002
p 01 00000 00001 0EBB
#
# r2=r2+1
p 00 00000 00001 0EBA
p 01 00000 00001 2BBF
p 01 00000 00001 0001
#
# SHIFT: CALL MUL16_SHIFT
p 00 00000 00001 0EBB
p 01 00000 00001 1100
p 01 00000 00001 0F60
#
# r1=r1-1  - Decrement the bit counter
p 00 00000 00001 0EBC
p 01 00000 00001 2AAF
p 01 00000 00001 FFFF
#
# Jump if last alu non zero to LOOP_TOP:
p 00 00000 00001 0EBD
p 01 00000 00001 1001
p 01 00000 00001 0EB5
#
#
# Dummy <= DX
p 00 00000 00001 0EBE
p 01 00000 00001 4E3F
p 01 00000 00001 FFFF
#
# Jump if zero to SIGN_UPDATE:
p 00 00000 00001 0EBF
p 01 00000 00001 1002
p 01 00000 00001 0EC1
#
# Set the CF, and OF Flags to indicate part of the answer is in DX
p 00 00000 00001 0EC0
p 01 00000 00001 588F
p 01 00000 00001 0801
#
#
# SIGN_UPDATE:
# Isolate r3[0] into Dummy 
p 00 00000 00001 0EC1
p 01 00000 00001 4ECF
p 01 00000 00001 0001
#
# Jump if zero over next instructions
p 00 00000 00001 0EC2
p 01 00000 00001 1002
p 01 00000 00001 0EC9
#
# XOR invert all bits in DX - 1's Complement
p 00 00000 00001 0EC3
p 01 00000 00001 633F
p 01 00000 00001 FFFF
#
# XOR invert all bits in AX - 1's Complement
p 00 00000 00001 0EC4
p 01 00000 00001 600F
p 01 00000 00001 FFFF
#
# Add 1 to AX -  2's Complement
p 00 00000 00001 0EC5
p 01 00000 00001 200F
p 01 00000 00001 0001
#
# if AX overflows (carry16=1) then add 1 to DX
# Isolate System Signals Carry16 into Dummy
p 00 00000 00001 0EC6
p 01 00000 00001 4EEF
p 01 00000 00001 0001
#
# Jump over next code if last ALU is non zero
p 00 00000 00001 0EC7
p 01 00000 00001 1002
p 01 00000 00001 0EC9
#
# DX <= DX + 1
p 00 00000 00001 0EC8
p 01 00000 00001 233F
p 01 00000 00001 0001
#
# Isolate System Signals clock counter zero bit into Dummy
p 00 00000 00001 0EC9
p 01 00000 00001 4EEF
p 01 00000 00001 1000
#
# Jump to retest if last ALU is zero
p 00 00000 00001 0ECA
p 01 00000 00001 1002
p 01 00000 00001 0EC9
#
# Jump Unconditional to common code
p 00 00000 00001 0ECB
p 01 00000 00001 1000
p 01 00000 00001 00C0
#
# -----------------------------------------------------
#
# 0xF7   IDIV - REG16/MEM16
#
# -----------------------------------------------------
#
#
# Clear the CF, and OF Flags
p 00 00000 00001 0ED0
p 01 00000 00001 488F
p 01 00000 00001 F7FE
#
# NOP
p 00 00000 00001 0ED1
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# Kick off clock cycle counter here. Check for it to be zero at the end of the routine.
# Write clock count=175 to the BIU Dataout register. - Minimum of 175 clocks for IDIV16
p 00 00000 00001 0ED2
p 01 00000 00001 5FFF
p 01 00000 00001 CDAC
#
# Strobe BIU - Set clock counter
p 00 00000 00001 0ED3
p 01 00000 00001 5DDF
p 01 00000 00001 2000
#
# Debounce BIU Strobe
p 00 00000 00001 0ED4
p 01 00000 00001 4DDF
p 01 00000 00001 CFFF
#
#
# Test for negative numbers. CF=1 indicates that final answer needs to be 2's complimented.
#
# Isolate r0[15] into Dummy 
p 00 00000 00001 0ED5
p 01 00000 00001 4E9F
p 01 00000 00001 8000
#
# Jump if zero over next instructions
p 00 00000 00001 0ED6
p 01 00000 00001 1002
p 01 00000 00001 0EDA
#
# Set the CF=1  - Final answer is negative and needs to be 2's complimented.
p 00 00000 00001 0ED7
p 01 00000 00001 588F
p 01 00000 00001 0001
#
# XOR all bits of r0 - 1's Complement
p 00 00000 00001 0ED8
p 01 00000 00001 699F
p 01 00000 00001 FFFF
#
# Add 1 to r0 -  2's Complement
p 00 00000 00001 0ED9
p 01 00000 00001 299F
p 01 00000 00001 0001
#
#
# Isolate DX[15] into Dummy 
p 00 00000 00001 0EDA
p 01 00000 00001 4E3F
p 01 00000 00001 8000
#
# Jump if zero over next instructions
p 00 00000 00001 0EDB
p 01 00000 00001 1002
p 01 00000 00001 0EE9
#
# Toggle CF - If previous final answer is negative, then new final answer should be positive.
# Also toggle OV bit to store that DX:AX is a negative number
p 00 00000 00001 0EDC
p 01 00000 00001 688F
p 01 00000 00001 0801
#
# XOR invert all bits in DX - 1's Complement
p 00 00000 00001 0EDD
p 01 00000 00001 633F
p 01 00000 00001 FFFF
#
# XOR invert all bits in AX - 1's Complement
p 00 00000 00001 0EDE
p 01 00000 00001 600F
p 01 00000 00001 FFFF
#
# Add 1 to AX -  2's Complement
p 00 00000 00001 0EDF
p 01 00000 00001 200F
p 01 00000 00001 0001
#
# if AX overflows (carry16=1) then add 1 to DX
# Isolate System Signals Carry16 into Dummy
p 00 00000 00001 0EE0
p 01 00000 00001 4EEF
p 01 00000 00001 0001
#
# Jump over next code if last ALU is non zero
p 00 00000 00001 0EE1
p 01 00000 00001 1002
p 01 00000 00001 0EE9
#
# DX <= DX + 1
p 00 00000 00001 0EE2
p 01 00000 00001 233F
p 01 00000 00001 0001
#
# Jump Unconditional to DIV opcode
p 00 00000 00001 0EE3
p 01 00000 00001 1000
p 01 00000 00001 0EE9
#
# -----------------------------------------------------
#
# 0xF7   DIV - REG16/MEM16
#
#
# DX:AX - Numerator
# r0 - Denominator
# r1 - Bit Counter
# r2 - Intermediate remainder
# r3 - Intermediate remainder
# CF - 1= Final Quotient should be made negative
# OV - 1= DX:AX is negative, so the remainder should be represented negative
# DX - Remainder AX=Quotient
#
# Note:
# If DX:AX is negative, then remainder in DX will also be negative. Even if both operators are negative and the quotient is positive.
#
# -----------------------------------------------------
#
# Clear the CF, and OF Flags
p 00 00000 00001 0EE4
p 01 00000 00001 488F
p 01 00000 00001 F7FE
#
# NOP
p 00 00000 00001 0EE5
p 01 00000 00001 0000
p 01 00000 00001 0000
#
# Kick off clock cycle counter here. Check for it to be zero at the end of the routine.
# Write clock count=153 to the BIU Dataout register. - Minimum of 153 clocks for DIV16
p 00 00000 00001 0EE6
p 01 00000 00001 5FFF
p 01 00000 00001 CBF4
#
# Strobe BIU - Set clock counter
p 00 00000 00001 0EE7
p 01 00000 00001 5DDF
p 01 00000 00001 2000
#
# Debounce BIU Strobe
p 00 00000 00001 0EE8
p 01 00000 00001 4DDF
p 01 00000 00001 CFFF
#
# r1=31   Load the bitcount
p 00 00000 00001 0EE9
p 01 00000 00001 5AFF
p 01 00000 00001 0020
#
# Zero out r2
p 00 00000 00001 0EEA
p 01 00000 00001 5BFF
p 01 00000 00001 0000
#
# Zero out r3 
p 00 00000 00001 0EEB
p 01 00000 00001 5CFF
p 01 00000 00001 0000
#

# START: fuck
# CALL SHIFT_64
p 00 00000 00001 0EEC
p 01 00000 00001 1100
p 01 00000 00001 0F30
#
# Subtraction Test

# Two's complement r0: Invert r0  (r0 = r0 XOR FFFF)
p 00 00000 00001 0EED
p 01 00000 00001 699F
p 01 00000 00001 FFFF
#
# Two's complement r0: r0 = r0 + 1 (Denominator)
p 00 00000 00001 0EEE
p 01 00000 00001 299F
p 01 00000 00001 0001
#
# Test for division by zero
# Jump if zero to INT0 processing code
p 00 00000 00001 0EEF
p 01 00000 00001 1002
p 01 00000 00001 0F10
#
# r2=r2-0
p 00 00000 00001 0EF0
p 01 00000 00001 2BB9
p 01 00000 00001 0000
#
# Isolate CARRY16 from System Signals into Dummy 
p 00 00000 00001 0EF1
p 01 00000 00001 4EEF
p 01 00000 00001 0001
#
# Jump over next code if last ALU is non zero
p 00 00000 00001 0EF2
p 01 00000 00001 1001
p 01 00000 00001 0EF4
#
# r3=r3-1
p 00 00000 00001 0EF3
p 01 00000 00001 2CCF
p 01 00000 00001 FFFF
#
# Isolate CARRY16 from System Signals into Dummy 
p 00 00000 00001 0EF4
p 01 00000 00001 4EEF
p 01 00000 00001 0001
#
# Jump to RESTORE: code if last ALU is zero
p 00 00000 00001 0EF5
p 01 00000 00001 1002
p 01 00000 00001 0EFA
#
# Set AX[0] to 1
p 00 00000 00001 0EF6
p 01 00000 00001 500F
p 01 00000 00001 0001
#
# Two's complement r0: Invert r0  (r0 = r0 XOR FFFF)
p 00 00000 00001 0EF7
p 01 00000 00001 699F
p 01 00000 00001 FFFF
#
# Two's complement r0: r0 = r0 + 1 (Denominator)
p 00 00000 00001 0EF8
p 01 00000 00001 299F
p 01 00000 00001 0001
#
# Jump unconditional to BIT_COUNT_TEST  
p 00 00000 00001 0EF9
p 01 00000 00001 1000
p 01 00000 00001 0EFE
#

# RESTORE:
# Two's complement r0: Invert r0  (r0 = r0 XOR FFFF)
p 00 00000 00001 0EFA
p 01 00000 00001 699F
p 01 00000 00001 FFFF
#
# Two's complement r0: r0 = r0 + 1 (Denominator)
p 00 00000 00001 0EFB
p 01 00000 00001 299F
p 01 00000 00001 0001
#
# r2=r2+r0
p 00 00000 00001 0EFC
p 01 00000 00001 2BB9
p 01 00000 00001 0000
#
# r3=r3+1
p 00 00000 00001 0EFD
p 01 00000 00001 2CCF
p 01 00000 00001 0001
#

# BIT_COUNT_TEST
# r1=r1-1
p 00 00000 00001 0EFE
p 01 00000 00001 2AAF
p 01 00000 00001 FFFF
#
# Jump back to START: if last ALU is non zero
p 00 00000 00001 0EFF
p 01 00000 00001 1001
p 01 00000 00001 0EEC
#
#
# DONE:
# Overflow Check: DX should be zero. Otherwise it has overflow
#  OR DX into Dummy
p 00 00000 00001 0F00
p 01 00000 00001 5E3F
p 01 00000 00001 0000
#
# Jump if non zero to INT0 processing code
p 00 00000 00001 0F01
p 01 00000 00001 1001
p 01 00000 00001 0F10
#
# Copy remainder from r2 into DX 
p 00 00000 00001 0F02
p 01 00000 00001 53FB
p 01 00000 00001 0000
#
# REMAINDER SIGN UPDATE:
# If DX was negative, represent the remainder as a negative number
# Isolate OV into Dummy 
p 00 00000 00001 0F03
p 01 00000 00001 4E8F
p 01 00000 00001 0800
#
# Jump if zero over next instructions
p 00 00000 00001 0F04
p 01 00000 00001 1002
p 01 00000 00001 0F07
#
# XOR invert all bits in DX - 1's Complement
p 00 00000 00001 0F05
p 01 00000 00001 633F
p 01 00000 00001 FFFF
#
# Add 1 to DX -  2's Complement
p 00 00000 00001 0F06
p 01 00000 00001 233F
p 01 00000 00001 0001
#
#
# QUOTIENT SIGN UPDATE:
# Isolate CF into Dummy 
p 00 00000 00001 0F07
p 01 00000 00001 4E8F
p 01 00000 00001 0001
#
# Jump if zero over next instructions
p 00 00000 00001 0F08
p 01 00000 00001 1002
p 01 00000 00001 0F0B
#
# XOR invert all bits in AX - 1's Complement
p 00 00000 00001 0F09
p 01 00000 00001 600F
p 01 00000 00001 FFFF
#
# Add 1 to AX -  2's Complement
p 00 00000 00001 0F0A
p 01 00000 00001 200F
p 01 00000 00001 0001
#
# Jump Unconditional to common code
p 00 00000 00001 0F0B
p 01 00000 00001 1000
p 01 00000 00001 00BE
#
#
#
# -----------------------------------------------------
#
# INT0 Processing
#
# -----------------------------------------------------
#
# Set r0 to 0
p 00 00000 00001 0F10
p 01 00000 00001 59FF
p 01 00000 00001 0000
#
# Jump Unconditional to Interrupt processing code
p 00 00000 00001 0F11
p 01 00000 00001 1000
p 01 00000 00001 055C
#
#
#
# -----------------------------------------------------
#
# Calculate Flags for DAA and DAS code
#
# -----------------------------------------------------
#
# Zero out the P, Z, S bit fields in Flag register
p 00 00000 00001 0F20
p 01 00000 00001 488F
p 01 00000 00001 FF3B
#
# Calculate the P flag
#
# Isolate AL into r2
p 00 00000 00001 0F21
p 01 00000 00001 4B0F
p 01 00000 00001 00FF
#
# Isolate the P flag from System Signals into r3 using AND
p 00 00000 00001 0F22
p 01 00000 00001 4CEF
p 01 00000 00001 0004
#
# Merge r3 into the Flags register using OR
p 00 00000 00001 0F23
p 01 00000 00001 588C
p 01 00000 00001 0000
#
# Calculate the S flag
#
# Isolate Bit[7] from r2 into Dummy
p 00 00000 00001 0F24
p 01 00000 00001 4EBF
p 01 00000 00001 0080
#
# if alu_last_result is zero then jump over next instruction
p 00 00000 00001 0F25
p 01 00000 00001 1002
p 01 00000 00001 0F27
#
# Set the Sign Flag bit to a 1
p 00 00000 00001 0F26
p 01 00000 00001 588F
p 01 00000 00001 0080
#
# Calculate the Z Flag
#
# r2 <= r2 AND 00FF to zero out the upper byte
p 00 00000 00001 0F27
p 01 00000 00001 4BBF
p 01 00000 00001 00FF
#
# if alu_last_result is not zero then jump to end
p 00 00000 00001 0F28
p 01 00000 00001 1001
p 01 00000 00001 0F2A
#
# Set the Zero Flag bit to a 1
p 00 00000 00001 0F29
p 01 00000 00001 588F
p 01 00000 00001 0040
#
# Jump unconditional to NOP Microcode since it is identical 
p 00 00000 00001 0F2A
p 01 00000 00001 1000
p 01 00000 00001 0041


# -----------------------------------------------------
#
# SHIFT_64 for DIV16 
#
# -----------------------------------------------------
#
# r3=r3+r3 -SHL r3
p 00 00000 00001 0F30
p 01 00000 00001 2CCC
p 01 00000 00001 0000
#
# r2=r2+r2 -SHL r2
p 00 00000 00001 0F31
p 01 00000 00001 2BBB
p 01 00000 00001 0000
#
# Isolate CARRY16 from System Signals into Dummy 
p 00 00000 00001 0F32
p 01 00000 00001 4EEF
p 01 00000 00001 0001
#
# Jump over next code if last ALU is zero
p 00 00000 00001 0F33
p 01 00000 00001 1002
p 01 00000 00001 0F35
#
# Set r3[0] to a 1
p 00 00000 00001 0F34
p 01 00000 00001 5CCF
p 01 00000 00001 0001
#
# Dummy <= DX or 0000
p 00 00000 00001 0F35
p 01 00000 00001 5E3F
p 01 00000 00001 0000
#
# DX=DX+ALU_LAST_RESULT -SHL DX
p 00 00000 00001 0F36
p 01 00000 00001 233D
p 01 00000 00001 0000
#
# Isolate CARRY16 from System Signals into Dummy 
p 00 00000 00001 0F37
p 01 00000 00001 4EEF
p 01 00000 00001 0001
#
# Jump over next code if last ALU is zero
p 00 00000 00001 0F38
p 01 00000 00001 1002
p 01 00000 00001 0F3A
#
# Set r2[0] to a 1
p 00 00000 00001 0F39
p 01 00000 00001 5BBF
p 01 00000 00001 0001
#
# Dummy <= AX or 0000
p 00 00000 00001 0F3A
p 01 00000 00001 5E0F
p 01 00000 00001 0000
#
# AX=AX+ALU_LAST_RESULT -SHL AX
p 00 00000 00001 0F3B
p 01 00000 00001 200D
p 01 00000 00001 0000
#
# Isolate CARRY16 from System Signals into Dummy 
p 00 00000 00001 0F3C
p 01 00000 00001 4EEF
p 01 00000 00001 0001
#
# Jump over next code if last ALU is zero
p 00 00000 00001 0F3D
p 01 00000 00001 1002
p 01 00000 00001 0F3F
#
# Set DX[0] to a 1
p 00 00000 00001 0F3E
p 01 00000 00001 533F
p 01 00000 00001 0001
#
# Unconditional Jump to return address
p 00 00000 00001 0F3F
p 01 00000 00001 1030
p 01 00000 00001 0000


# -----------------------------------------------------
#
# Procedure ROR16,1 
#
# -----------------------------------------------------
#
# Zero the CF and OF Flags
p 00 00000 00001 0F46
p 01 00000 00001 488F
p 01 00000 00001 F7FE
#
# Clear r1 to 0x0000
p 00 00000 00001 0F47
p 01 00000 00001 5AFF
p 01 00000 00001 0000
#
# Isolate r0[15] into r2
p 00 00000 00001 0F48
p 01 00000 00001 4B9F
p 01 00000 00001 8000
#
# Isolate r0[0] into Dummy
p 00 00000 00001 0F49
p 01 00000 00001 4E9F
p 01 00000 00001 0001
#
# Jump if zero over next instructions
p 00 00000 00001 0F4A
p 01 00000 00001 1002
p 01 00000 00001 0F4D
#
# Set the CF Flag to 1
p 00 00000 00001 0F4B
p 01 00000 00001 588F
p 01 00000 00001 0001
#
# Set r1 to 0x8000
p 00 00000 00001 0F4C
p 01 00000 00001 5AFF
p 01 00000 00001 8000
#
# Shift r0 to the right 1 bit
p 00 00000 00001 0F4D
p 01 00000 00001 7999
p 01 00000 00001 0000
#
# r0 <= r0 OR r1 - OR in the CF stored in r1
p 00 00000 00001 0F4E
p 01 00000 00001 599A
p 01 00000 00001 0000
#
# r1 XOR r2 into Dummy - See if final result[15] not equal to [14] for Overflow
p 00 00000 00001 0F4F
p 01 00000 00001 6EAB
p 01 00000 00001 0200
#
# if alu_last_result is zero then jump over next instruction
p 00 00000 00001 0F50
p 01 00000 00001 1002
p 01 00000 00001 0F52
#
# Set the Overflow Flag bit to a 1
p 00 00000 00001 0F51
p 01 00000 00001 588F
p 01 00000 00001 0800
#
# Return to calling code
p 00 00000 00001 0F52
p 01 00000 00001 1030
p 01 00000 00001 0000
#
#


# -----------------------------------------------------
#
# SHIFT_32 for DIV8
#
# -----------------------------------------------------
#
# r2=r2+r2 -SHL r2
p 00 00000 00001 0F56
p 01 00000 00001 2BBB
p 01 00000 00001 0000
#
# Dummy <= AX or 0000
p 00 00000 00001 0F57
p 01 00000 00001 5E0F
p 01 00000 00001 0000
#
# AX=AX+ALU_LAST_RESULT -SHL AX
p 00 00000 00001 0F58
p 01 00000 00001 200D
p 01 00000 00001 0000
#
# Isolate CARRY16 from System Signals into Dummy 
p 00 00000 00001 0F59
p 01 00000 00001 4EEF
p 01 00000 00001 0001
#
# Jump over next code if last ALU is zero
p 00 00000 00001 0F5A
p 01 00000 00001 1002
p 01 00000 00001 0F5C
#
# Set r2[0] to a 1
p 00 00000 00001 0F5B
p 01 00000 00001 5BBF
p 01 00000 00001 0001
#
# Unconditional Jump to return address
p 00 00000 00001 0F5C
p 01 00000 00001 1030
p 01 00000 00001 0000



# -----------------------------------------------------
#
# MUL16_SHIFT
#
# -----------------------------------------------------
#
# SHIFT: AX to the right
p 00 00000 00001 0F60
p 01 00000 00001 700F
p 01 00000 00001 0000
#
# Isolate DX[0] into Dummy
p 00 00000 00001 0F61
p 01 00000 00001 4E3F
p 01 00000 00001 0001
#
# Jump if zero over next instruction
p 00 00000 00001 0F62
p 01 00000 00001 1002
p 01 00000 00001 0F64
#
# Set AX[15] to 1
p 00 00000 00001 0F63
p 01 00000 00001 500F
p 01 00000 00001 8000
#
# Shift DX to the right
p 00 00000 00001 0F64
p 01 00000 00001 733F
p 01 00000 00001 0000
#
# Isolate r2[0] into Dummy
p 00 00000 00001 0F65
p 01 00000 00001 4EBF
p 01 00000 00001 0001
#
# Jump if zero over next instruction
p 00 00000 00001 0F66
p 01 00000 00001 1002
p 01 00000 00001 0F68
#
# Set DX[15] to 1
p 00 00000 00001 0F67
p 01 00000 00001 533F
p 01 00000 00001 8000
#
# Shift r2 to the right
p 00 00000 00001 0F68
p 01 00000 00001 7BBF
p 01 00000 00001 0000
#
# Unconditional Jump to return address
p 00 00000 00001 0F69
p 01 00000 00001 1030
p 01 00000 00001 0000



# -----------------------------------------------------
#
# MUL8_SHIFT
#
# -----------------------------------------------------
#
# SHIFT: AX to the right
p 00 00000 00001 0F6A
p 01 00000 00001 700F
p 01 00000 00001 0000
#
# Isolate r2[0] into Dummy
p 00 00000 00001 0F6B
p 01 00000 00001 4EBF
p 01 00000 00001 0001
#
# Jump if zero over next instruction
p 00 00000 00001 0F6C
p 01 00000 00001 1002
p 01 00000 00001 0F6E
#
# Set AX[15] to 1
p 00 00000 00001 0F6D
p 01 00000 00001 500F
p 01 00000 00001 8000
#
# Shift r2 to the right
p 00 00000 00001 0F6E
p 01 00000 00001 7BBF
p 01 00000 00001 0000
#
# Unconditional Jump to return address
p 00 00000 00001 0F6F
p 01 00000 00001 1030
p 01 00000 00001 0000




# -----------------------------------------------------
#
# MUL8_ENDING
#
# -----------------------------------------------------
#
# Dummy <= AX AND FF00 - Did result overflow into AH
p 00 00000 00001 0F70
p 01 00000 00001 4E0F
p 01 00000 00001 FF00
#
# Jump if zero to SIGN_UPDATE:
p 00 00000 00001 0F71
p 01 00000 00001 1002
p 01 00000 00001 0F73
#
# Set the CF, and OF Flags to indicate part of the answer is in AH
p 00 00000 00001 0F72
p 01 00000 00001 588F
p 01 00000 00001 0801
#
#
# SIGN_UPDATE:
# Isolate r3[0] into Dummy 
p 00 00000 00001 0F73
p 01 00000 00001 4ECF
p 01 00000 00001 0001
#
# Jump if zero over next instructions
p 00 00000 00001 0F74
p 01 00000 00001 1002
p 01 00000 00001 0F77
#
# XOR invert all bits in AX - 1's Complement
p 00 00000 00001 0F75
p 01 00000 00001 600F
p 01 00000 00001 FFFF
#
# Add 1 to AX -  2's Complement
p 00 00000 00001 0F76
p 01 00000 00001 200F
p 01 00000 00001 0001
#
# Isolate System Signals clock counter zero bit into Dummy
p 00 00000 00001 0F77
p 01 00000 00001 4EEF
p 01 00000 00001 1000
#
# Jump to retest if last ALU is zero
p 00 00000 00001 0F78
p 01 00000 00001 1002
p 01 00000 00001 0F77
#
# Jump Unconditional to common code
p 00 00000 00001 0F79
p 01 00000 00001 1000
p 01 00000 00001 00C6
#
#

# DONE 

--------------------------------------------------------------------
--------------------------------------------------------------------
--------------------------------------------------------------------
--------------------------------------------------------------------
#
#
# Initial Opcode Jump Table at address 0x0100 - 0x1FF - 256 locations
# --------------------------------------------------------------------
#
#
#
p 00 00000 00001 0100
p 01 00000 00001 1000
p 01 00000 00001 09A6
#
#
p 00 00000 00001 0101
p 01 00000 00001 1000
p 01 00000 00001 09AC
#
#
p 00 00000 00001 0102
p 01 00000 00001 1000
p 01 00000 00001 09B2
#
#
p 00 00000 00001 0103
p 01 00000 00001 1000
p 01 00000 00001 09B8
#
#
p 00 00000 00001 0104
p 01 00000 00001 1000
p 01 00000 00001 09BE
#
#
p 00 00000 00001 0105
p 01 00000 00001 1000
p 01 00000 00001 09C2
#
#
p 00 00000 00001 0106
p 01 00000 00001 1000
p 01 00000 00001 040A
#
#
p 00 00000 00001 0107
p 01 00000 00001 1000
p 01 00000 00001 0457
#
#
p 00 00000 00001 0108
p 01 00000 00001 1000
p 01 00000 00001 0906
#
#
p 00 00000 00001 0109
p 01 00000 00001 1000
p 01 00000 00001 0915
#
#
p 00 00000 00001 010A
p 01 00000 00001 1000
p 01 00000 00001 0924
#
#
p 00 00000 00001 010B
p 01 00000 00001 1000
p 01 00000 00001 0933
#
#
p 00 00000 00001 010C
p 01 00000 00001 1000
p 01 00000 00001 0940
#
#
p 00 00000 00001 010D
p 01 00000 00001 1000
p 01 00000 00001 0947
#
#
p 00 00000 00001 010E
p 01 00000 00001 1000
p 01 00000 00001 040F
#
#
p 00 00000 00001 010F
p 01 00000 00001 1000
p 01 00000 00001 045C
#
#
p 00 00000 00001 0110
p 01 00000 00001 1000
p 01 00000 00001 09D2
#
#
p 00 00000 00001 0111
p 01 00000 00001 1000
p 01 00000 00001 09D8
#
#
p 00 00000 00001 0112
p 01 00000 00001 1000
p 01 00000 00001 09DE
#
#
p 00 00000 00001 0113
p 01 00000 00001 1000
p 01 00000 00001 09E4
#
#
p 00 00000 00001 0114
p 01 00000 00001 1000
p 01 00000 00001 09EA
#
#
p 00 00000 00001 0115
p 01 00000 00001 1000
p 01 00000 00001 09F4
#
#
p 00 00000 00001 0116
p 01 00000 00001 1000
p 01 00000 00001 0414
#
#
p 00 00000 00001 0117
p 01 00000 00001 1000
p 01 00000 00001 0461
#
#
p 00 00000 00001 0118
p 01 00000 00001 1000
p 01 00000 00001 0A88
#
#
p 00 00000 00001 0119
p 01 00000 00001 1000
p 01 00000 00001 0A8E
#
#
p 00 00000 00001 011A
p 01 00000 00001 1000
p 01 00000 00001 0A94
#
#
p 00 00000 00001 011B
p 01 00000 00001 1000
p 01 00000 00001 0A9A
#
#
p 00 00000 00001 011C
p 01 00000 00001 1000
p 01 00000 00001 0AA0
#
#
p 00 00000 00001 011D
p 01 00000 00001 1000
p 01 00000 00001 0AA8
#
#
p 00 00000 00001 011E
p 01 00000 00001 1000
p 01 00000 00001 0419
#
#
p 00 00000 00001 011F
p 01 00000 00001 1000
p 01 00000 00001 0466
#
#
p 00 00000 00001 0120
p 01 00000 00001 1000
p 01 00000 00001 0970
#
#
p 00 00000 00001 0121
p 01 00000 00001 1000
p 01 00000 00001 0976
#
#
p 00 00000 00001 0122
p 01 00000 00001 1000
p 01 00000 00001 097C
#
#
p 00 00000 00001 0123
p 01 00000 00001 1000
p 01 00000 00001 0982
#
#
p 00 00000 00001 0124
p 01 00000 00001 1000
p 01 00000 00001 09FD
#
#
p 00 00000 00001 0125
p 01 00000 00001 1000
p 01 00000 00001 098B
#
#
p 00 00000 00001 0126
p 01 00000 00001 1000
p 01 00000 00001 00D6
#
#
p 00 00000 00001 0127
p 01 00000 00001 1000
p 01 00000 00001 0270
#
#
p 00 00000 00001 0128
p 01 00000 00001 1000
p 01 00000 00001 0A20
#
#
p 00 00000 00001 0129
p 01 00000 00001 1000
p 01 00000 00001 0A26
#
#
p 00 00000 00001 012A
p 01 00000 00001 1000
p 01 00000 00001 0A2C
#
#
p 00 00000 00001 012B
p 01 00000 00001 1000
p 01 00000 00001 0A32
#
#
p 00 00000 00001 012C
p 01 00000 00001 1000
p 01 00000 00001 0A38
#
#
p 00 00000 00001 012D
p 01 00000 00001 1000
p 01 00000 00001 0A40
#
#
p 00 00000 00001 012E
p 01 00000 00001 1000
p 01 00000 00001 00D8
#
#
p 00 00000 00001 012F
p 01 00000 00001 1000
p 01 00000 00001 0272
#
#
p 00 00000 00001 0130
p 01 00000 00001 1000
p 01 00000 00001 0950
#
#
p 00 00000 00001 0131
p 01 00000 00001 1000
p 01 00000 00001 0956
#
#
p 00 00000 00001 0132
p 01 00000 00001 1000
p 01 00000 00001 095C
#
#
p 00 00000 00001 0133
p 01 00000 00001 1000
p 01 00000 00001 0962
#
#
p 00 00000 00001 0134
p 01 00000 00001 1000
p 01 00000 00001 0968
#
#
p 00 00000 00001 0135
p 01 00000 00001 1000
p 01 00000 00001 096B
#
#
p 00 00000 00001 0136
p 01 00000 00001 1000
p 01 00000 00001 00DA
#
#
p 00 00000 00001 0137
p 01 00000 00001 1000
p 01 00000 00001 0240
#
#
p 00 00000 00001 0138
p 01 00000 00001 1000
p 01 00000 00001 0A60
#
#
p 00 00000 00001 0139
p 01 00000 00001 1000
p 01 00000 00001 0A66
#
#
p 00 00000 00001 013A
p 01 00000 00001 1000
p 01 00000 00001 0A6C
#
#
p 00 00000 00001 013B
p 01 00000 00001 1000
p 01 00000 00001 0A72
#
#
p 00 00000 00001 013C
p 01 00000 00001 1000
p 01 00000 00001 0A78
#
#
p 00 00000 00001 013D
p 01 00000 00001 1000
p 01 00000 00001 0A7D
#
#
p 00 00000 00001 013E
p 01 00000 00001 1000
p 01 00000 00001 00DC
#
#
p 00 00000 00001 013F
p 01 00000 00001 1000
p 01 00000 00001 0256
#
#
p 00 00000 00001 0140
p 01 00000 00001 1000
p 01 00000 00001 0088
#
#
p 00 00000 00001 0141
p 01 00000 00001 1000
p 01 00000 00001 008A
#
#
p 00 00000 00001 0142
p 01 00000 00001 1000
p 01 00000 00001 008C
#
#
p 00 00000 00001 0143
p 01 00000 00001 1000
p 01 00000 00001 008E
#
#
p 00 00000 00001 0144
p 01 00000 00001 1000
p 01 00000 00001 0090
#
#
p 00 00000 00001 0145
p 01 00000 00001 1000
p 01 00000 00001 0092
#
#
p 00 00000 00001 0146
p 01 00000 00001 1000
p 01 00000 00001 0094
#
#
p 00 00000 00001 0147
p 01 00000 00001 1000
p 01 00000 00001 0096
#
#
p 00 00000 00001 0148
p 01 00000 00001 1000
p 01 00000 00001 0098
#
#
p 00 00000 00001 0149
p 01 00000 00001 1000
p 01 00000 00001 009A
#
#
p 00 00000 00001 014A
p 01 00000 00001 1000
p 01 00000 00001 009C
#
#
p 00 00000 00001 014B
p 01 00000 00001 1000
p 01 00000 00001 009E
#
#
p 00 00000 00001 014C
p 01 00000 00001 1000
p 01 00000 00001 00A0
#
#
p 00 00000 00001 014D
p 01 00000 00001 1000
p 01 00000 00001 00A2
#
#
p 00 00000 00001 014E
p 01 00000 00001 1000
p 01 00000 00001 00A4
#
#
p 00 00000 00001 014F
p 01 00000 00001 1000
p 01 00000 00001 00A6
#
#
p 00 00000 00001 0150
p 01 00000 00001 1000
p 01 00000 00001 0423
#
#
p 00 00000 00001 0151
p 01 00000 00001 1000
p 01 00000 00001 0428
#
#
p 00 00000 00001 0152
p 01 00000 00001 1000
p 01 00000 00001 042D
#
#
p 00 00000 00001 0153
p 01 00000 00001 1000
p 01 00000 00001 0432
#
#
p 00 00000 00001 0154
p 01 00000 00001 1000
p 01 00000 00001 0446
#
#
p 00 00000 00001 0155
p 01 00000 00001 1000
p 01 00000 00001 043C
#
#
p 00 00000 00001 0156
p 01 00000 00001 1000
p 01 00000 00001 0441
#
#
p 00 00000 00001 0157
p 01 00000 00001 1000
p 01 00000 00001 0437
#
#
p 00 00000 00001 0158
p 01 00000 00001 1000
p 01 00000 00001 0480
#
#
p 00 00000 00001 0159
p 01 00000 00001 1000
p 01 00000 00001 0483
#
#
p 00 00000 00001 015A
p 01 00000 00001 1000
p 01 00000 00001 0486
#
#
p 00 00000 00001 015B
p 01 00000 00001 1000
p 01 00000 00001 0489
#
#
p 00 00000 00001 015C
p 01 00000 00001 1000
p 01 00000 00001 048C
#
#
p 00 00000 00001 015D
p 01 00000 00001 1000
p 01 00000 00001 048F
#
#
p 00 00000 00001 015E
p 01 00000 00001 1000
p 01 00000 00001 0492
#
#
p 00 00000 00001 015F
p 01 00000 00001 1000
p 01 00000 00001 0495
#
# 
p 00 00000 00001 0160
p 01 00000 00001 1000
p 01 00000 00001 0360
#
#
p 00 00000 00001 0161
p 01 00000 00001 1000
p 01 00000 00001 0363
#
#
p 00 00000 00001 0162
p 01 00000 00001 1000
p 01 00000 00001 0366
#
#
p 00 00000 00001 0163
p 01 00000 00001 1000
p 01 00000 00001 0369
#
#
p 00 00000 00001 0164
p 01 00000 00001 1000
p 01 00000 00001 036C
#
#
p 00 00000 00001 0165
p 01 00000 00001 1000
p 01 00000 00001 036F
#
#
p 00 00000 00001 0166
p 01 00000 00001 1000
p 01 00000 00001 0372
#
#
p 00 00000 00001 0167
p 01 00000 00001 1000
p 01 00000 00001 0375
#
#
p 00 00000 00001 0168
p 01 00000 00001 1000
p 01 00000 00001 0378
#
#
p 00 00000 00001 0169
p 01 00000 00001 1000
p 01 00000 00001 037B
#
#
p 00 00000 00001 016A
p 01 00000 00001 1000
p 01 00000 00001 037E
#
#
p 00 00000 00001 016B
p 01 00000 00001 1000
p 01 00000 00001 0381
#
#
p 00 00000 00001 016C
p 01 00000 00001 1000
p 01 00000 00001 0384
#
#
p 00 00000 00001 016D
p 01 00000 00001 1000
p 01 00000 00001 038D
#
#
p 00 00000 00001 016E
p 01 00000 00001 1000
p 01 00000 00001 0396
#
#
p 00 00000 00001 016F
p 01 00000 00001 1000
p 01 00000 00001 0399
#
#
p 00 00000 00001 0170
p 01 00000 00001 1000
p 01 00000 00001 0360
#
#
p 00 00000 00001 0171
p 01 00000 00001 1000
p 01 00000 00001 0363
#
#
p 00 00000 00001 0172
p 01 00000 00001 1000
p 01 00000 00001 0366
#
#
p 00 00000 00001 0173
p 01 00000 00001 1000
p 01 00000 00001 0369
#
#
p 00 00000 00001 0174
p 01 00000 00001 1000
p 01 00000 00001 036C
#
#
p 00 00000 00001 0175
p 01 00000 00001 1000
p 01 00000 00001 036F
#
#
p 00 00000 00001 0176
p 01 00000 00001 1000
p 01 00000 00001 0372
#
#
p 00 00000 00001 0177
p 01 00000 00001 1000
p 01 00000 00001 0375
#
#
p 00 00000 00001 0178
p 01 00000 00001 1000
p 01 00000 00001 0378
#
#
p 00 00000 00001 0179
p 01 00000 00001 1000
p 01 00000 00001 037B
#
#
p 00 00000 00001 017A
p 01 00000 00001 1000
p 01 00000 00001 037E
#
#
p 00 00000 00001 017B
p 01 00000 00001 1000
p 01 00000 00001 0381
#
#
p 00 00000 00001 017C
p 01 00000 00001 1000
p 01 00000 00001 0384
#
#
p 00 00000 00001 017D
p 01 00000 00001 1000
p 01 00000 00001 038D
#
#
p 00 00000 00001 017E
p 01 00000 00001 1000
p 01 00000 00001 0396
#
#
p 00 00000 00001 017F
p 01 00000 00001 1000
p 01 00000 00001 0399
#
#
p 00 00000 00001 0180
p 01 00000 00001 1000
p 01 00000 00001 0AD0
#
#
p 00 00000 00001 0181
p 01 00000 00001 1000
p 01 00000 00001 0AE0
#
#
p 00 00000 00001 0182
p 01 00000 00001 1000
p 01 00000 00001 0AD0
#
#
p 00 00000 00001 0183
p 01 00000 00001 1000
p 01 00000 00001 0AF0
#
#
p 00 00000 00001 0184
p 01 00000 00001 1000
p 01 00000 00001 0D0A
#
#
p 00 00000 00001 0185
p 01 00000 00001 1000
p 01 00000 00001 0D10
#
#
p 00 00000 00001 0186
p 01 00000 00001 1000
p 01 00000 00001 0D18
#
#
p 00 00000 00001 0187
p 01 00000 00001 1000
p 01 00000 00001 0D1F
#
#
p 00 00000 00001 0188
p 01 00000 00001 1000
p 01 00000 00001 0CF0
#
#
p 00 00000 00001 0189
p 01 00000 00001 1000
p 01 00000 00001 0CF3
#
#
p 00 00000 00001 018A
p 01 00000 00001 1000
p 01 00000 00001 0CF6
#
#
p 00 00000 00001 018B
p 01 00000 00001 1000
p 01 00000 00001 0CF9
#
#
p 00 00000 00001 018C
p 01 00000 00001 1000
p 01 00000 00001 0D70
#
#
p 00 00000 00001 018D
p 01 00000 00001 1000
p 01 00000 00001 0CFD
#
#
p 00 00000 00001 018E
p 01 00000 00001 1000
p 01 00000 00001 0D50
#
#
p 00 00000 00001 018F
p 01 00000 00001 1000
p 01 00000 00001 0D44
#
#
p 00 00000 00001 0190
p 01 00000 00001 1000
p 01 00000 00001 0040
#
#
p 00 00000 00001 0191
p 01 00000 00001 1000
p 01 00000 00001 005E
#
#
p 00 00000 00001 0192
p 01 00000 00001 1000
p 01 00000 00001 0064
#
#
p 00 00000 00001 0193
p 01 00000 00001 1000
p 01 00000 00001 006A
#
#
p 00 00000 00001 0194
p 01 00000 00001 1000
p 01 00000 00001 0070
#
#
p 00 00000 00001 0195
p 01 00000 00001 1000
p 01 00000 00001 0076
#
#
p 00 00000 00001 0196
p 01 00000 00001 1000
p 01 00000 00001 007C
#
#
p 00 00000 00001 0197
p 01 00000 00001 1000
p 01 00000 00001 0082
#
#
p 00 00000 00001 0198
p 01 00000 00001 1000
p 01 00000 00001 0230
#
#
p 00 00000 00001 0199
p 01 00000 00001 1000
p 01 00000 00001 0237
#
#
p 00 00000 00001 019A
p 01 00000 00001 1000
p 01 00000 00001 04A6
#
#
p 00 00000 00001 019B
p 01 00000 00001 1000
p 01 00000 00001 00E8
#
#
p 00 00000 00001 019C
p 01 00000 00001 1000
p 01 00000 00001 041E
#
#
p 00 00000 00001 019D
p 01 00000 00001 1000
p 01 00000 00001 0498
#
#
p 00 00000 00001 019E
p 01 00000 00001 1000
p 01 00000 00001 0220
#
#
p 00 00000 00001 019F
p 01 00000 00001 1000
p 01 00000 00001 0210
#
#
p 00 00000 00001 01A0
p 01 00000 00001 1000
p 01 00000 00001 0D28
#
#
p 00 00000 00001 01A1
p 01 00000 00001 1000
p 01 00000 00001 0D32
#
#
p 00 00000 00001 01A2
p 01 00000 00001 1000
p 01 00000 00001 0D38
#
#
p 00 00000 00001 01A3
p 01 00000 00001 1000
p 01 00000 00001 0D3D
#
#
p 00 00000 00001 01A4
p 01 00000 00001 1000
p 01 00000 00001 05F0
#
#
p 00 00000 00001 01A5
p 01 00000 00001 1000
p 01 00000 00001 0614
#
#
p 00 00000 00001 01A6
p 01 00000 00001 1000
p 01 00000 00001 0637
#
#
p 00 00000 00001 01A7
p 01 00000 00001 1000
p 01 00000 00001 0660
#
#
p 00 00000 00001 01A8
p 01 00000 00001 1000
p 01 00000 00001 0D02
#
#
p 00 00000 00001 01A9
p 01 00000 00001 1000
p 01 00000 00001 0D06
#
#
p 00 00000 00001 01AA
p 01 00000 00001 1000
p 01 00000 00001 0700
#
#
p 00 00000 00001 01AB
p 01 00000 00001 1000
p 01 00000 00001 0720
#
#
p 00 00000 00001 01AC
p 01 00000 00001 1000
p 01 00000 00001 06C6
#
#
p 00 00000 00001 01AD
p 01 00000 00001 1000
p 01 00000 00001 06E4
#
#
p 00 00000 00001 01AE
p 01 00000 00001 1000
p 01 00000 00001 0686
#
#
p 00 00000 00001 01AF
p 01 00000 00001 1000
p 01 00000 00001 06A8
#
#
p 00 00000 00001 01B0
p 01 00000 00001 1000
p 01 00000 00001 02F8
#
#
p 00 00000 00001 01B1
p 01 00000 00001 1000
p 01 00000 00001 02FC
#
#
p 00 00000 00001 01B2
p 01 00000 00001 1000
p 01 00000 00001 0300
#
#
p 00 00000 00001 01B3
p 01 00000 00001 1000
p 01 00000 00001 0304
#
#
p 00 00000 00001 01B4
p 01 00000 00001 1000
p 01 00000 00001 0308
#
#
p 00 00000 00001 01B5
p 01 00000 00001 1000
p 01 00000 00001 030D
#
#
p 00 00000 00001 01B6
p 01 00000 00001 1000
p 01 00000 00001 0312
#
#
p 00 00000 00001 01B7
p 01 00000 00001 1000
p 01 00000 00001 0317
#
#
p 00 00000 00001 01B8
p 01 00000 00001 1000
p 01 00000 00001 031E
#
#
p 00 00000 00001 01B9
p 01 00000 00001 1000
p 01 00000 00001 0321
#
#
p 00 00000 00001 01BA
p 01 00000 00001 1000
p 01 00000 00001 0324
#
#
p 00 00000 00001 01BB
p 01 00000 00001 1000
p 01 00000 00001 0327
#
#
p 00 00000 00001 01BC
p 01 00000 00001 1000
p 01 00000 00001 032A
#
#
p 00 00000 00001 01BD
p 01 00000 00001 1000
p 01 00000 00001 032D
#
#
p 00 00000 00001 01BE
p 01 00000 00001 1000
p 01 00000 00001 0330
#
#
p 00 00000 00001 01BF
p 01 00000 00001 1000
p 01 00000 00001 0333
#
#
p 00 00000 00001 01C0
p 01 00000 00001 1000
p 01 00000 00001 04D5
#
#
p 00 00000 00001 01C1
p 01 00000 00001 1000
p 01 00000 00001 04BC
#
#
p 00 00000 00001 01C2
p 01 00000 00001 1000
p 01 00000 00001 04D5
#
#
p 00 00000 00001 01C3
p 01 00000 00001 1000
p 01 00000 00001 04BC
#
#
p 00 00000 00001 01C4
p 01 00000 00001 1000
p 01 00000 00001 0CC6
#
#
p 00 00000 00001 01C5
p 01 00000 00001 1000
p 01 00000 00001 0CD6
#
#
p 00 00000 00001 01C6
p 01 00000 00001 1000
p 01 00000 00001 0CE7
#
#
p 00 00000 00001 01C7
p 01 00000 00001 1000
p 01 00000 00001 0CEB
#
#
p 00 00000 00001 01C8
p 01 00000 00001 1000
p 01 00000 00001 04E6
#
#
p 00 00000 00001 01C9
p 01 00000 00001 1000
p 01 00000 00001 04C7
#
#
p 00 00000 00001 01CA
p 01 00000 00001 1000
p 01 00000 00001 04E6
#
#
p 00 00000 00001 01CB
p 01 00000 00001 1000
p 01 00000 00001 04C7
#
#
p 00 00000 00001 01CC
p 01 00000 00001 1000
p 01 00000 00001 051B
#
#
p 00 00000 00001 01CD
p 01 00000 00001 1000
p 01 00000 00001 055A
#
#
p 00 00000 00001 01CE
p 01 00000 00001 1000
p 01 00000 00001 054C
#
#
p 00 00000 00001 01CF
p 01 00000 00001 1000
p 01 00000 00001 0525
#
#
p 00 00000 00001 01D0
p 01 00000 00001 1000
p 01 00000 00001 0AF7
#
#
p 00 00000 00001 01D1
p 01 00000 00001 1000
p 01 00000 00001 0BE6
#
#
p 00 00000 00001 01D2
p 01 00000 00001 1000
p 01 00000 00001 0AFC
#
#
p 00 00000 00001 01D3
p 01 00000 00001 1000
p 01 00000 00001 0BEA
#
#
p 00 00000 00001 01D4
p 01 00000 00001 1000
p 01 00000 00001 02C7
#
#
p 00 00000 00001 01D5
p 01 00000 00001 1000
p 01 00000 00001 02AF
#
#
p 00 00000 00001 01D6
p 01 00000 00001 1000
p 01 00000 00001 0CBE
#
#
p 00 00000 00001 01D7
p 01 00000 00001 1000
p 01 00000 00001 0570
#
#
p 00 00000 00001 01D8
p 01 00000 00001 1000
p 01 00000 00001 0CB9
#
#
p 00 00000 00001 01D9
p 01 00000 00001 1000
p 01 00000 00001 0CB9
#
#
p 00 00000 00001 01DA
p 01 00000 00001 1000
p 01 00000 00001 0CB9
#
#
p 00 00000 00001 01DB
p 01 00000 00001 1000
p 01 00000 00001 0CB9
#
#
p 00 00000 00001 01DC
p 01 00000 00001 1000
p 01 00000 00001 0CB9
#
#
p 00 00000 00001 01DD
p 01 00000 00001 1000
p 01 00000 00001 0CB9
#
#
p 00 00000 00001 01DE
p 01 00000 00001 1000
p 01 00000 00001 0CB9
#
#
p 00 00000 00001 01DF
p 01 00000 00001 1000
p 01 00000 00001 0CB9
#
#
p 00 00000 00001 01E0
p 01 00000 00001 1000
p 01 00000 00001 03E5
#
#
p 00 00000 00001 01E1
p 01 00000 00001 1000
p 01 00000 00001 03A8
#
#
p 00 00000 00001 01E2
p 01 00000 00001 1000
p 01 00000 00001 03A2
#
#
p 00 00000 00001 01E3
p 01 00000 00001 1000
p 01 00000 00001 039D
#
#
p 00 00000 00001 01E4
p 01 00000 00001 1000
p 01 00000 00001 05AC
#
#
p 00 00000 00001 01E5
p 01 00000 00001 1000
p 01 00000 00001 05BB
#
#
p 00 00000 00001 01E6
p 01 00000 00001 1000
p 01 00000 00001 05DD
#
#
p 00 00000 00001 01E7
p 01 00000 00001 1000
p 01 00000 00001 05E9
#
#
p 00 00000 00001 01E8
p 01 00000 00001 1000
p 01 00000 00001 04A0
#
#
p 00 00000 00001 01E9
p 01 00000 00001 1000
p 01 00000 00001 03B6
#
#
p 00 00000 00001 01EA
p 01 00000 00001 1000
p 01 00000 00001 03C1
#
#
p 00 00000 00001 01EB
p 01 00000 00001 1000
p 01 00000 00001 03B3
#
#
p 00 00000 00001 01EC
p 01 00000 00001 1000
p 01 00000 00001 0590
#
#
p 00 00000 00001 01ED
p 01 00000 00001 1000
p 01 00000 00001 05A0
#
#
p 00 00000 00001 01EE
p 01 00000 00001 1000
p 01 00000 00001 05C7
#
#
p 00 00000 00001 01EF
p 01 00000 00001 1000
p 01 00000 00001 05D4
#
#
p 00 00000 00001 01F0
p 01 00000 00001 1000
p 01 00000 00001 00D0
#
#
p 00 00000 00001 01F1
p 01 00000 00001 1000
p 01 00000 00001 00D0
#
#
p 00 00000 00001 01F2
p 01 00000 00001 1000
p 01 00000 00001 00D2
#
#
p 00 00000 00001 01F3
p 01 00000 00001 1000
p 01 00000 00001 00D4
#
# HALT 
p 00 00000 00001 01F4
p 01 00000 00001 1000
p 01 00000 00001 0200
#
#
p 00 00000 00001 01F5
p 01 00000 00001 1000
p 01 00000 00001 0052
#
#
p 00 00000 00001 01F6
p 01 00000 00001 1000
p 01 00000 00001 0E12
#
#
p 00 00000 00001 01F7
p 01 00000 00001 1000
p 01 00000 00001 0E83
#
#
p 00 00000 00001 01F8
p 01 00000 00001 1000
p 01 00000 00001 0050
#
#
p 00 00000 00001 01F9
p 01 00000 00001 1000
p 01 00000 00001 0054
#
#
p 00 00000 00001 01FA
p 01 00000 00001 1000
p 01 00000 00001 005A
#
#
p 00 00000 00001 01FB
p 01 00000 00001 1000
p 01 00000 00001 00BA
#
#
p 00 00000 00001 01FC
p 01 00000 00001 1000
p 01 00000 00001 0056
#
#
p 00 00000 00001 01FD
p 01 00000 00001 1000
p 01 00000 00001 0058
#
#
p 00 00000 00001 01FE
p 01 00000 00001 1000
p 01 00000 00001 0DF0
#
#
p 00 00000 00001 01FF
p 01 00000 00001 1000
p 01 00000 00001 0D8B
#


# Set trigger address
p 00 00000 00010 0002
p 01 00000 00010 0000
p 01 00000 00010 E070
#

d 1000


# Start CPU

p 00 00000 00010 0001
p 01 00000 00010 0000
p 01 00000 00010 0000
#

# #####################################################################3

d 1000
#
x
#





